var zn = Object.defineProperty;
var Rn = (e, t, a) => t in e ? zn(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a;
var Ve = (e, t, a) => (Rn(e, typeof t != "symbol" ? t + "" : t, a), a);
import { unref as i, computed as u, ref as z, shallowRef as Na, watch as se, getCurrentScope as Zl, onScopeDispose as Ql, shallowReadonly as mt, watchEffect as De, readonly as Se, isRef as kt, effectScope as Hn, toRef as d, customRef as Mn, getCurrentInstance as ia, onMounted as Xe, nextTick as Te, reactive as dt, defineComponent as H, h as re, Teleport as za, inject as Ie, onActivated as Dn, onBeforeUnmount as eo, openBlock as g, createElementBlock as V, Fragment as fe, createElementVNode as X, renderSlot as x, normalizeProps as ke, guardReactiveProps as Pe, createVNode as $e, withCtx as q, mergeProps as Z, normalizeClass as j, normalizeStyle as je, createTextVNode as ie, toDisplayString as Y, createCommentVNode as J, createApp as jn, provide as Qe, createBlock as D, resolveDynamicComponent as le, toHandlers as qn, Transition as to, useSlots as Fe, resolveComponent as ao, withModifiers as ct, renderList as we, withKeys as Ot, withDirectives as it, vShow as ra, isReactive as Gn, onUnmounted as Wn, useAttrs as lo, vModelCheckbox as Un, vModelRadio as Xn, vModelSelect as Kn, createSlots as oo } from "vue";
const Jn = (e) => typeof e == "boolean" || e === "" || e === "true" || e === "false", no = (e) => typeof e == "boolean" ? e : e === "" ? !0 : e === "true";
class Ze {
  constructor(t, a = {}) {
    Ve(this, "cancelable", !0);
    Ve(this, "componentId", null);
    Ve(this, "_defaultPrevented", !1);
    Ve(this, "eventType", "");
    Ve(this, "nativeEvent", null);
    Ve(this, "_preventDefault");
    Ve(this, "relatedTarget", null);
    Ve(this, "target", null);
    if (!t)
      throw new TypeError(
        `Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`
      );
    Object.assign(this, Ze.Defaults, a, { eventType: t }), this._preventDefault = function() {
      this.cancelable && (this.defaultPrevented = !0);
    };
  }
  // Readable by everyone,
  // But only overwritten by inherrited constructors
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  set defaultPrevented(t) {
    this._defaultPrevented = t;
  }
  // I think this is right
  // We want to be able to have it callable to everyone,
  // But only overwritten by inherrited constructors
  get preventDefault() {
    return this._preventDefault;
  }
  // This may not be correct, because it doesn't get correct type inferences in children
  // Ex overwrite this.preventDefault = () => true is valid. Could be a TS issue
  set preventDefault(t) {
    this._preventDefault = t;
  }
  static get Defaults() {
    return {
      cancelable: !0,
      componentId: null,
      eventType: "",
      nativeEvent: null,
      relatedTarget: null,
      target: null
    };
  }
}
class zt extends Ze {
  constructor(a, l = {}) {
    super(a, l);
    Ve(this, "trigger", null);
    Object.assign(this, Ze.Defaults, l, { eventType: a });
  }
  static get Defaults() {
    return {
      ...super.Defaults,
      trigger: null
    };
  }
}
class so extends Ze {
  constructor(a, l) {
    super(a, l);
    Ve(this, "from");
    Ve(this, "to");
    Ve(this, "direction");
    Object.assign(this, Ze.Defaults, l, { eventType: a });
    const { from: o, direction: n, to: r } = l;
    this.from = o, this.to = r, this.direction = n;
  }
  static get Defaults() {
    return {
      ...super.Defaults
    };
  }
}
const Ba = (e) => e !== null && typeof e == "object", io = (e) => /^[0-9]*\.?[0-9]+$/.test(String(e)), Yn = (e) => Object.prototype.toString.call(e) === "[object Object]", ro = /_/g, uo = /([a-z])([A-Z])/g, Zn = /(\s|^)(\w)/g, Qn = /(\s|^)(\w)/, Ut = /\s+/, es = /^#/, ts = /^#[A-Za-z]+[\w\-:.]*$/, as = /-u-.+/, ls = /[-/\\^$*+?.()|[\]{}]/g, os = /[\s\uFEFF\xA0]+/g, Jt = (e, t = 2) => typeof e == "string" ? e : e == null ? "" : Array.isArray(e) || Yn(e) && e.toString === Object.prototype.toString ? JSON.stringify(e, null, t) : String(e), al = (e) => e.replace(ro, " ").replace(uo, (t, a, l) => `${a} ${l}`).replace(Qn, (t, a, l) => a + l.toUpperCase()), ll = (e) => e.replace(ro, " ").replace(uo, (t, a, l) => `${a} ${l}`).replace(Zn, (t, a, l) => a + l.toUpperCase()), ns = (e) => {
  const t = e.trim();
  return t.charAt(0).toUpperCase() + t.slice(1);
}, ss = (e) => e.replace(ls, "\\$&"), is = (e) => ss(e).replace(os, "\\s"), ba = (e) => `\\${e}`, rs = (e) => {
  const t = Jt(e), { length: a } = t, l = t.charCodeAt(0);
  return t.split("").reduce((o, n, r) => {
    const s = t.charCodeAt(r);
    return s === 0 ? `${o}ï¿½` : (
      // ... is U+007F OR
      s === 127 || // ... is in the range [\1-\1F] (U+0001 to U+001F) OR ...
      s >= 1 && s <= 31 || // ... is the first character and is in the range [0-9] (U+0030 to U+0039) OR ...
      r === 0 && s >= 48 && s <= 57 || // ... is the second character and is in the range [0-9] (U+0030 to U+0039)
      // and the first character is a `-` (U+002D) ...
      r === 1 && s >= 48 && s <= 57 && l === 45 ? o + ba(`${s.toString(16)} `) : (
        // ... is the first character AND ...
        r === 0 && // ... is a `-` (U+002D) AND ...
        s === 45 && // ... there is no second character ...
        a === 1 ? o + ba(n) : (
          // ... is greater than or equal to U+0080 OR ...
          s >= 128 || // ... is `-` (U+002D) OR ...
          s === 45 || // ... is `_` (U+005F) OR ...
          s === 95 || // ... is in the range [0-9] (U+0030 to U+0039) OR ...
          s >= 48 && s <= 57 || // ... is in the range [A-Z] (U+0041 to U+005A) OR ...
          s >= 65 && s <= 90 || // ... is in the range [a-z] (U+0061 to U+007A) ...
          s >= 97 && s <= 122 ? o + n : o + ba(n)
        )
      )
    );
  }, "");
}, co = typeof window < "u", fo = typeof document < "u", us = typeof Element < "u", vo = typeof navigator < "u", ua = co && fo && vo, ut = co ? window : {}, da = fo ? document : {}, mo = vo ? navigator : {}, ds = (mo.userAgent || "").toLowerCase();
ds.indexOf("jsdom") > 0;
(() => {
  let e = !1;
  if (ua)
    try {
      const t = {
        // This function will be called when the browser
        // attempts to access the passive property
        get passive() {
          return e = !0, e;
        }
      };
      ut.addEventListener("test", t, t), ut.removeEventListener("test", t, t);
    } catch {
      e = !1;
    }
  return e;
})();
ua && ("ontouchstart" in da.documentElement || mo.maxTouchPoints > 0);
ua && (ut.PointerEvent || ut.MSPointerEvent);
ua && "IntersectionObserver" in ut && "IntersectionObserverEntry" in ut && // Edge 15 and UC Browser lack support for `isIntersecting`
// but we an use `intersectionRatio > 0` instead
// 'isIntersecting' in window.IntersectionObserverEntry.prototype &&
"intersectionRatio" in ut.IntersectionObserverEntry.prototype;
const Ra = typeof window < "u", cs = typeof document < "u", fs = typeof navigator < "u", Ha = Ra && cs && fs, ol = Ra ? window : {}, vs = (() => {
  let e = !1;
  if (Ha)
    try {
      const t = {
        // This function will be called when the browser
        // attempts to access the passive property
        get passive() {
          e = !0;
        }
      };
      ol.addEventListener("test", t, t), ol.removeEventListener("test", t, t);
    } catch {
      e = !1;
    }
  return e;
})(), Re = us ? Element.prototype : void 0, ms = (Re == null ? void 0 : Re.matches) || (Re == null ? void 0 : Re.msMatchesSelector) || (Re == null ? void 0 : Re.webkitMatchesSelector), et = (e) => !!(e && e.nodeType === Node.ELEMENT_NODE), ps = (e) => et(e) ? e.getBoundingClientRect() : null, gs = (e = []) => {
  const { activeElement: t } = document;
  return t && !e.some((a) => a === t) ? t : null;
}, bs = (e) => et(e) && e === gs(), hs = (e, t = {}) => {
  try {
    e.focus(t);
  } catch (a) {
    console.error(a);
  }
  return bs(e);
}, ys = (e, t) => t && et(e) && e.getAttribute(t) || null, Bs = (e) => {
  if (ys(e, "display") === "none")
    return !1;
  const t = ps(e);
  return !!(t && t.height > 0 && t.width > 0);
}, Oe = (e) => ((e == null ? void 0 : e()) ?? []).length === 0, po = (e, t) => (et(t) ? t : da).querySelector(e) || null, $s = (e, t) => Array.from([(et(t) ? t : da).querySelectorAll(e)]), Ma = (e, t) => t && et(e) ? e.getAttribute(t) : null, ws = (e) => da.getElementById(/^#/.test(e) ? e.slice(1) : e) || null, ks = (e, t, a) => {
  t && et(e) && e.setAttribute(t, a);
}, Ss = (e, t) => {
  t && et(e) && e.removeAttribute(t);
}, Cs = (e, t) => Jt(e).toLowerCase() === Jt(t).toLowerCase(), Mt = Ra ? window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || // Fallback, but not a true polyfill
// Only needed for Opera Mini
((e) => setTimeout(e, 16)) : (e) => setTimeout(e, 0), go = (e, t) => et(e) ? ms.call(e, t) : !1, Ts = (Re == null ? void 0 : Re.closest) || function(e) {
  let t = this;
  if (!t)
    return null;
  do {
    if (go(t, e))
      return t;
    t = t.parentElement || t.parentNode;
  } while (t !== null && t.nodeType === Node.ELEMENT_NODE);
  return null;
}, nl = (e, t, a = !1) => {
  if (!et(t))
    return null;
  const l = Ts.call(t, e);
  return a ? l : l === t ? null : l;
}, $a = (e) => {
  const t = window.getComputedStyle(e), a = t.transitionDelay.split(",")[0] || "", l = t.transitionDuration.split(",")[0] || "", o = Number(a.slice(0, -1)) * 1e3, n = Number(l.slice(0, -1)) * 1e3;
  return o + n;
}, ca = (e, t, a) => t.concat(["sm", "md", "lg", "xl", "xxl"]).reduce((l, o) => (l[e ? `${e}${o.charAt(0).toUpperCase() + o.slice(1)}` : o] = a, l), /* @__PURE__ */ Object.create(null)), bo = (e, t, a, l = a) => Object.keys(t).reduce((o, n) => (e[n] && o.push(
  [l, n.replace(a, ""), e[n]].filter((r) => r && typeof r != "boolean").join("-").toLowerCase()
), o), []), lt = (e = "") => `__BVID__${Math.random().toString().slice(2, 8)}___BV_${e}__`, Et = (e) => !!(e.href || e.to), Me = (e, t = {}, a = {}) => {
  const l = [e];
  let o;
  for (let n = 0; n < l.length && !o; n++) {
    const r = l[n];
    o = a[r];
  }
  return o && typeof o == "function" ? o(t) : o;
}, ot = (e, t = NaN) => Number.isInteger(e) ? e : t, _s = (e, t = NaN) => {
  const a = Number.parseInt(e, 10);
  return Number.isNaN(a) ? t : a;
}, At = (e, t = NaN) => {
  const a = Number.parseFloat(e.toString());
  return Number.isNaN(a) ? t : a;
}, Rt = (e, t) => Object.keys(e).filter((a) => !t.includes(a)).reduce((a, l) => ({ ...a, [l]: e[l] }), {}), Yt = (e) => Array.isArray(e) ? e.map((t) => Yt(t)) : e instanceof Date ? new Date(e.getTime()) : e && typeof e == "object" ? Object.getOwnPropertyNames(e).reduce((t, a) => (Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(e, a) ?? {}), t[a] = Yt(e[a]), t), Object.create(Object.getPrototypeOf(e))) : e, wa = (e) => new Promise((t) => t(Yt(e))), sl = (e, t) => t + (e ? ns(e) : ""), Da = (e, t) => (Array.isArray(t) ? t.slice() : Object.keys(t)).reduce(
  (a, l) => (a[l] = e[l], a),
  {}
), fa = (e, t) => e === !0 || e === "true" || e === "" ? "true" : e === "grammar" || e === "spelling" ? e : t === !1 ? "true" : e === !1 || e === "false" ? "false" : void 0, ho = Symbol("carousel"), yo = Symbol("tabs"), Bo = Symbol("breadcrumb"), $o = Symbol("progress"), wo = Symbol("listGroup"), ko = Symbol("avatarGroup"), So = Symbol("accordion"), Co = Symbol("checkboxGroup"), To = Symbol("radioGroup"), ja = Symbol("collapse"), _o = Symbol("collapse"), ka = (e, t) => ((e == null ? void 0 : e()) ?? []).reduce((a, l) => (typeof l.type == "symbol" ? a = a.concat(l.children) : a.push(l), a), []).filter((a) => {
  var l;
  return ((l = a.type) == null ? void 0 : l.__name) === t;
});
function Je(e) {
  return e.split("-")[1];
}
function qa(e) {
  return e === "y" ? "height" : "width";
}
function Ge(e) {
  return e.split("-")[0];
}
function St(e) {
  return ["top", "bottom"].includes(Ge(e)) ? "x" : "y";
}
function il(e, t, a) {
  let { reference: l, floating: o } = e;
  const n = l.x + l.width / 2 - o.width / 2, r = l.y + l.height / 2 - o.height / 2, s = St(t), f = qa(s), m = l[f] / 2 - o[f] / 2, y = s === "x";
  let b;
  switch (Ge(t)) {
    case "top":
      b = { x: n, y: l.y - o.height };
      break;
    case "bottom":
      b = { x: n, y: l.y + l.height };
      break;
    case "right":
      b = { x: l.x + l.width, y: r };
      break;
    case "left":
      b = { x: l.x - o.width, y: r };
      break;
    default:
      b = { x: l.x, y: l.y };
  }
  switch (Je(t)) {
    case "start":
      b[s] -= m * (a && y ? -1 : 1);
      break;
    case "end":
      b[s] += m * (a && y ? -1 : 1);
  }
  return b;
}
const xs = async (e, t, a) => {
  const { placement: l = "bottom", strategy: o = "absolute", middleware: n = [], platform: r } = a, s = n.filter(Boolean), f = await (r.isRTL == null ? void 0 : r.isRTL(t));
  let m = await r.getElementRects({ reference: e, floating: t, strategy: o }), { x: y, y: b } = il(m, l, f), v = l, B = {}, p = 0;
  for (let S = 0; S < s.length; S++) {
    const { name: h, fn: $ } = s[S], { x: k, y: w, data: A, reset: T } = await $({ x: y, y: b, initialPlacement: l, placement: v, strategy: o, middlewareData: B, rects: m, platform: r, elements: { reference: e, floating: t } });
    y = k ?? y, b = w ?? b, B = { ...B, [h]: { ...B[h], ...A } }, T && p <= 50 && (p++, typeof T == "object" && (T.placement && (v = T.placement), T.rects && (m = T.rects === !0 ? await r.getElementRects({ reference: e, floating: t, strategy: o }) : T.rects), { x: y, y: b } = il(m, v, f)), S = -1);
  }
  return { x: y, y: b, placement: v, strategy: o, middlewareData: B };
};
function Ga(e) {
  return typeof e != "number" ? function(t) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...t };
  }(e) : { top: e, right: e, bottom: e, left: e };
}
function $t(e) {
  return { ...e, top: e.y, left: e.x, right: e.x + e.width, bottom: e.y + e.height };
}
async function It(e, t) {
  var a;
  t === void 0 && (t = {});
  const { x: l, y: o, platform: n, rects: r, elements: s, strategy: f } = e, { boundary: m = "clippingAncestors", rootBoundary: y = "viewport", elementContext: b = "floating", altBoundary: v = !1, padding: B = 0 } = t, p = Ga(B), S = s[v ? b === "floating" ? "reference" : "floating" : b], h = $t(await n.getClippingRect({ element: (a = await (n.isElement == null ? void 0 : n.isElement(S))) == null || a ? S : S.contextElement || await (n.getDocumentElement == null ? void 0 : n.getDocumentElement(s.floating)), boundary: m, rootBoundary: y, strategy: f })), $ = b === "floating" ? { ...r.floating, x: l, y: o } : r.reference, k = await (n.getOffsetParent == null ? void 0 : n.getOffsetParent(s.floating)), w = await (n.isElement == null ? void 0 : n.isElement(k)) && await (n.getScale == null ? void 0 : n.getScale(k)) || { x: 1, y: 1 }, A = $t(n.convertOffsetParentRelativeRectToViewportRelativeRect ? await n.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: $, offsetParent: k, strategy: f }) : $);
  return { top: (h.top - A.top + p.top) / w.y, bottom: (A.bottom - h.bottom + p.bottom) / w.y, left: (h.left - A.left + p.left) / w.x, right: (A.right - h.right + p.right) / w.x };
}
const Zt = Math.min, Qt = Math.max;
function Sa(e, t, a) {
  return Qt(e, Zt(t, a));
}
const As = (e) => ({ name: "arrow", options: e, async fn(t) {
  const { element: a, padding: l = 0 } = e || {}, { x: o, y: n, placement: r, rects: s, platform: f, elements: m } = t;
  if (a == null)
    return {};
  const y = Ga(l), b = { x: o, y: n }, v = St(r), B = qa(v), p = await f.getDimensions(a), S = v === "y", h = S ? "top" : "left", $ = S ? "bottom" : "right", k = S ? "clientHeight" : "clientWidth", w = s.reference[B] + s.reference[v] - b[v] - s.floating[B], A = b[v] - s.reference[v], T = await (f.getOffsetParent == null ? void 0 : f.getOffsetParent(a));
  let C = T ? T[k] : 0;
  C && await (f.isElement == null ? void 0 : f.isElement(T)) || (C = m.floating[k] || s.floating[B]);
  const I = w / 2 - A / 2, O = y[h], F = C - p[B] - y[$], _ = C / 2 - p[B] / 2 + I, P = Sa(O, _, F), L = Je(r) != null && _ != P && s.reference[B] / 2 - (_ < O ? y[h] : y[$]) - p[B] / 2 < 0;
  return { [v]: b[v] - (L ? _ < O ? O - _ : F - _ : 0), data: { [v]: P, centerOffset: _ - P } };
} }), xo = ["top", "right", "bottom", "left"], rl = xo.reduce((e, t) => e.concat(t, t + "-start", t + "-end"), []), Vs = { left: "right", right: "left", bottom: "top", top: "bottom" };
function ea(e) {
  return e.replace(/left|right|bottom|top/g, (t) => Vs[t]);
}
function Ao(e, t, a) {
  a === void 0 && (a = !1);
  const l = Je(e), o = St(e), n = qa(o);
  let r = o === "x" ? l === (a ? "end" : "start") ? "right" : "left" : l === "start" ? "bottom" : "top";
  return t.reference[n] > t.floating[n] && (r = ea(r)), { main: r, cross: ea(r) };
}
const Ps = { start: "end", end: "start" };
function Xt(e) {
  return e.replace(/start|end/g, (t) => Ps[t]);
}
const Os = function(e) {
  return e === void 0 && (e = {}), { name: "autoPlacement", options: e, async fn(t) {
    var a, l, o;
    const { rects: n, middlewareData: r, placement: s, platform: f, elements: m } = t, { crossAxis: y = !1, alignment: b, allowedPlacements: v = rl, autoAlignment: B = !0, ...p } = e, S = b !== void 0 || v === rl ? function(_, P, L) {
      return (_ ? [...L.filter((N) => Je(N) === _), ...L.filter((N) => Je(N) !== _)] : L.filter((N) => Ge(N) === N)).filter((N) => !_ || Je(N) === _ || !!P && Xt(N) !== N);
    }(b || null, B, v) : v, h = await It(t, p), $ = ((a = r.autoPlacement) == null ? void 0 : a.index) || 0, k = S[$];
    if (k == null)
      return {};
    const { main: w, cross: A } = Ao(k, n, await (f.isRTL == null ? void 0 : f.isRTL(m.floating)));
    if (s !== k)
      return { reset: { placement: S[0] } };
    const T = [h[Ge(k)], h[w], h[A]], C = [...((l = r.autoPlacement) == null ? void 0 : l.overflows) || [], { placement: k, overflows: T }], I = S[$ + 1];
    if (I)
      return { data: { index: $ + 1, overflows: C }, reset: { placement: I } };
    const O = C.map((_) => {
      const P = Je(_.placement);
      return [_.placement, P && y ? _.overflows.slice(0, 2).reduce((L, N) => L + N, 0) : _.overflows[0], _.overflows];
    }).sort((_, P) => _[1] - P[1]), F = ((o = O.filter((_) => _[2].slice(0, Je(_[0]) ? 2 : 3).every((P) => P <= 0))[0]) == null ? void 0 : o[0]) || O[0][0];
    return F !== s ? { data: { index: $ + 1, overflows: C }, reset: { placement: F } } : {};
  } };
}, Vo = function(e) {
  return e === void 0 && (e = {}), { name: "flip", options: e, async fn(t) {
    var a;
    const { placement: l, middlewareData: o, rects: n, initialPlacement: r, platform: s, elements: f } = t, { mainAxis: m = !0, crossAxis: y = !0, fallbackPlacements: b, fallbackStrategy: v = "bestFit", fallbackAxisSideDirection: B = "none", flipAlignment: p = !0, ...S } = e, h = Ge(l), $ = Ge(r) === r, k = await (s.isRTL == null ? void 0 : s.isRTL(f.floating)), w = b || ($ || !p ? [ea(r)] : function(P) {
      const L = ea(P);
      return [Xt(P), L, Xt(L)];
    }(r));
    b || B === "none" || w.push(...function(P, L, N, ee) {
      const K = Je(P);
      let G = function(ae, de, he) {
        const Be = ["left", "right"], oe = ["right", "left"], ve = ["top", "bottom"], R = ["bottom", "top"];
        switch (ae) {
          case "top":
          case "bottom":
            return he ? de ? oe : Be : de ? Be : oe;
          case "left":
          case "right":
            return de ? ve : R;
          default:
            return [];
        }
      }(Ge(P), N === "start", ee);
      return K && (G = G.map((ae) => ae + "-" + K), L && (G = G.concat(G.map(Xt)))), G;
    }(r, p, B, k));
    const A = [r, ...w], T = await It(t, S), C = [];
    let I = ((a = o.flip) == null ? void 0 : a.overflows) || [];
    if (m && C.push(T[h]), y) {
      const { main: P, cross: L } = Ao(l, n, k);
      C.push(T[P], T[L]);
    }
    if (I = [...I, { placement: l, overflows: C }], !C.every((P) => P <= 0)) {
      var O, F;
      const P = (((O = o.flip) == null ? void 0 : O.index) || 0) + 1, L = A[P];
      if (L)
        return { data: { index: P, overflows: I }, reset: { placement: L } };
      let N = (F = I.filter((ee) => ee.overflows[0] <= 0).sort((ee, K) => ee.overflows[1] - K.overflows[1])[0]) == null ? void 0 : F.placement;
      if (!N)
        switch (v) {
          case "bestFit": {
            var _;
            const ee = (_ = I.map((K) => [K.placement, K.overflows.filter((G) => G > 0).reduce((G, ae) => G + ae, 0)]).sort((K, G) => K[1] - G[1])[0]) == null ? void 0 : _[0];
            ee && (N = ee);
            break;
          }
          case "initialPlacement":
            N = r;
        }
      if (l !== N)
        return { reset: { placement: N } };
    }
    return {};
  } };
};
function ul(e, t) {
  return { top: e.top - t.height, right: e.right - t.width, bottom: e.bottom - t.height, left: e.left - t.width };
}
function dl(e) {
  return xo.some((t) => e[t] >= 0);
}
const Es = function(e) {
  return e === void 0 && (e = {}), { name: "hide", options: e, async fn(t) {
    const { strategy: a = "referenceHidden", ...l } = e, { rects: o } = t;
    switch (a) {
      case "referenceHidden": {
        const n = ul(await It(t, { ...l, elementContext: "reference" }), o.reference);
        return { data: { referenceHiddenOffsets: n, referenceHidden: dl(n) } };
      }
      case "escaped": {
        const n = ul(await It(t, { ...l, altBoundary: !0 }), o.floating);
        return { data: { escapedOffsets: n, escaped: dl(n) } };
      }
      default:
        return {};
    }
  } };
};
function cl(e) {
  const t = Zt(...e.map((l) => l.left)), a = Zt(...e.map((l) => l.top));
  return { x: t, y: a, width: Qt(...e.map((l) => l.right)) - t, height: Qt(...e.map((l) => l.bottom)) - a };
}
const Is = function(e) {
  return e === void 0 && (e = {}), { name: "inline", options: e, async fn(t) {
    const { placement: a, elements: l, rects: o, platform: n, strategy: r } = t, { padding: s = 2, x: f, y: m } = e, y = Array.from(await (n.getClientRects == null ? void 0 : n.getClientRects(l.reference)) || []), b = function(S) {
      const h = S.slice().sort((w, A) => w.y - A.y), $ = [];
      let k = null;
      for (let w = 0; w < h.length; w++) {
        const A = h[w];
        !k || A.y - k.y > k.height / 2 ? $.push([A]) : $[$.length - 1].push(A), k = A;
      }
      return $.map((w) => $t(cl(w)));
    }(y), v = $t(cl(y)), B = Ga(s), p = await n.getElementRects({ reference: { getBoundingClientRect: function() {
      if (b.length === 2 && b[0].left > b[1].right && f != null && m != null)
        return b.find((S) => f > S.left - B.left && f < S.right + B.right && m > S.top - B.top && m < S.bottom + B.bottom) || v;
      if (b.length >= 2) {
        if (St(a) === "x") {
          const T = b[0], C = b[b.length - 1], I = Ge(a) === "top", O = T.top, F = C.bottom, _ = I ? T.left : C.left, P = I ? T.right : C.right;
          return { top: O, bottom: F, left: _, right: P, width: P - _, height: F - O, x: _, y: O };
        }
        const S = Ge(a) === "left", h = Qt(...b.map((T) => T.right)), $ = Zt(...b.map((T) => T.left)), k = b.filter((T) => S ? T.left === $ : T.right === h), w = k[0].top, A = k[k.length - 1].bottom;
        return { top: w, bottom: A, left: $, right: h, width: h - $, height: A - w, x: $, y: w };
      }
      return v;
    } }, floating: l.floating, strategy: r });
    return o.reference.x !== p.reference.x || o.reference.y !== p.reference.y || o.reference.width !== p.reference.width || o.reference.height !== p.reference.height ? { reset: { rects: p } } : {};
  } };
}, Po = function(e) {
  return e === void 0 && (e = 0), { name: "offset", options: e, async fn(t) {
    const { x: a, y: l } = t, o = await async function(n, r) {
      const { placement: s, platform: f, elements: m } = n, y = await (f.isRTL == null ? void 0 : f.isRTL(m.floating)), b = Ge(s), v = Je(s), B = St(s) === "x", p = ["left", "top"].includes(b) ? -1 : 1, S = y && B ? -1 : 1, h = typeof r == "function" ? r(n) : r;
      let { mainAxis: $, crossAxis: k, alignmentAxis: w } = typeof h == "number" ? { mainAxis: h, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...h };
      return v && typeof w == "number" && (k = v === "end" ? -1 * w : w), B ? { x: k * S, y: $ * p } : { x: $ * p, y: k * S };
    }(t, e);
    return { x: a + o.x, y: l + o.y, data: o };
  } };
};
function Fs(e) {
  return e === "x" ? "y" : "x";
}
const Oo = function(e) {
  return e === void 0 && (e = {}), { name: "shift", options: e, async fn(t) {
    const { x: a, y: l, placement: o } = t, { mainAxis: n = !0, crossAxis: r = !1, limiter: s = { fn: (h) => {
      let { x: $, y: k } = h;
      return { x: $, y: k };
    } }, ...f } = e, m = { x: a, y: l }, y = await It(t, f), b = St(Ge(o)), v = Fs(b);
    let B = m[b], p = m[v];
    if (n) {
      const h = b === "y" ? "bottom" : "right";
      B = Sa(B + y[b === "y" ? "top" : "left"], B, B - y[h]);
    }
    if (r) {
      const h = v === "y" ? "bottom" : "right";
      p = Sa(p + y[v === "y" ? "top" : "left"], p, p - y[h]);
    }
    const S = s.fn({ ...t, [b]: B, [v]: p });
    return { ...S, data: { x: S.x - a, y: S.y - l } };
  } };
};
function Le(e) {
  var t;
  return ((t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Ye(e) {
  return Le(e).getComputedStyle(e);
}
function Eo(e) {
  return e instanceof Le(e).Node;
}
function st(e) {
  return Eo(e) ? (e.nodeName || "").toLowerCase() : "";
}
let Dt;
function Io() {
  if (Dt)
    return Dt;
  const e = navigator.userAgentData;
  return e && Array.isArray(e.brands) ? (Dt = e.brands.map((t) => t.brand + "/" + t.version).join(" "), Dt) : navigator.userAgent;
}
function Ue(e) {
  return e instanceof Le(e).HTMLElement;
}
function We(e) {
  return e instanceof Le(e).Element;
}
function fl(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof Le(e).ShadowRoot || e instanceof ShadowRoot;
}
function va(e) {
  const { overflow: t, overflowX: a, overflowY: l, display: o } = Ye(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + l + a) && !["inline", "contents"].includes(o);
}
function Ls(e) {
  return ["table", "td", "th"].includes(st(e));
}
function Ca(e) {
  const t = /firefox/i.test(Io()), a = Ye(e), l = a.backdropFilter || a.WebkitBackdropFilter;
  return a.transform !== "none" || a.perspective !== "none" || !!l && l !== "none" || t && a.willChange === "filter" || t && !!a.filter && a.filter !== "none" || ["transform", "perspective"].some((o) => a.willChange.includes(o)) || ["paint", "layout", "strict", "content"].some((o) => {
    const n = a.contain;
    return n != null && n.includes(o);
  });
}
function Ta() {
  return /^((?!chrome|android).)*safari/i.test(Io());
}
function Wa(e) {
  return ["html", "body", "#document"].includes(st(e));
}
const vl = Math.min, Vt = Math.max, ta = Math.round;
function Fo(e) {
  const t = Ye(e);
  let a = parseFloat(t.width), l = parseFloat(t.height);
  const o = Ue(e), n = o ? e.offsetWidth : a, r = o ? e.offsetHeight : l, s = ta(a) !== n || ta(l) !== r;
  return s && (a = n, l = r), { width: a, height: l, fallback: s };
}
function Lo(e) {
  return We(e) ? e : e.contextElement;
}
const No = { x: 1, y: 1 };
function Bt(e) {
  const t = Lo(e);
  if (!Ue(t))
    return No;
  const a = t.getBoundingClientRect(), { width: l, height: o, fallback: n } = Fo(t);
  let r = (n ? ta(a.width) : a.width) / l, s = (n ? ta(a.height) : a.height) / o;
  return r && Number.isFinite(r) || (r = 1), s && Number.isFinite(s) || (s = 1), { x: r, y: s };
}
function ft(e, t, a, l) {
  var o, n;
  t === void 0 && (t = !1), a === void 0 && (a = !1);
  const r = e.getBoundingClientRect(), s = Lo(e);
  let f = No;
  t && (l ? We(l) && (f = Bt(l)) : f = Bt(e));
  const m = s ? Le(s) : window, y = Ta() && a;
  let b = (r.left + (y && ((o = m.visualViewport) == null ? void 0 : o.offsetLeft) || 0)) / f.x, v = (r.top + (y && ((n = m.visualViewport) == null ? void 0 : n.offsetTop) || 0)) / f.y, B = r.width / f.x, p = r.height / f.y;
  if (s) {
    const S = Le(s), h = l && We(l) ? Le(l) : l;
    let $ = S.frameElement;
    for (; $ && l && h !== S; ) {
      const k = Bt($), w = $.getBoundingClientRect(), A = getComputedStyle($);
      w.x += ($.clientLeft + parseFloat(A.paddingLeft)) * k.x, w.y += ($.clientTop + parseFloat(A.paddingTop)) * k.y, b *= k.x, v *= k.y, B *= k.x, p *= k.y, b += w.x, v += w.y, $ = Le($).frameElement;
    }
  }
  return $t({ width: B, height: p, x: b, y: v });
}
function nt(e) {
  return ((Eo(e) ? e.ownerDocument : e.document) || window.document).documentElement;
}
function ma(e) {
  return We(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset };
}
function zo(e) {
  return ft(nt(e)).left + ma(e).scrollLeft;
}
function Ft(e) {
  if (st(e) === "html")
    return e;
  const t = e.assignedSlot || e.parentNode || fl(e) && e.host || nt(e);
  return fl(t) ? t.host : t;
}
function Ro(e) {
  const t = Ft(e);
  return Wa(t) ? t.ownerDocument.body : Ue(t) && va(t) ? t : Ro(t);
}
function Pt(e, t) {
  var a;
  t === void 0 && (t = []);
  const l = Ro(e), o = l === ((a = e.ownerDocument) == null ? void 0 : a.body), n = Le(l);
  return o ? t.concat(n, n.visualViewport || [], va(l) ? l : []) : t.concat(l, Pt(l));
}
function ml(e, t, a) {
  let l;
  if (t === "viewport")
    l = function(r, s) {
      const f = Le(r), m = nt(r), y = f.visualViewport;
      let b = m.clientWidth, v = m.clientHeight, B = 0, p = 0;
      if (y) {
        b = y.width, v = y.height;
        const S = Ta();
        (!S || S && s === "fixed") && (B = y.offsetLeft, p = y.offsetTop);
      }
      return { width: b, height: v, x: B, y: p };
    }(e, a);
  else if (t === "document")
    l = function(r) {
      const s = nt(r), f = ma(r), m = r.ownerDocument.body, y = Vt(s.scrollWidth, s.clientWidth, m.scrollWidth, m.clientWidth), b = Vt(s.scrollHeight, s.clientHeight, m.scrollHeight, m.clientHeight);
      let v = -f.scrollLeft + zo(r);
      const B = -f.scrollTop;
      return Ye(m).direction === "rtl" && (v += Vt(s.clientWidth, m.clientWidth) - y), { width: y, height: b, x: v, y: B };
    }(nt(e));
  else if (We(t))
    l = function(r, s) {
      const f = ft(r, !0, s === "fixed"), m = f.top + r.clientTop, y = f.left + r.clientLeft, b = Ue(r) ? Bt(r) : { x: 1, y: 1 };
      return { width: r.clientWidth * b.x, height: r.clientHeight * b.y, x: y * b.x, y: m * b.y };
    }(t, a);
  else {
    const r = { ...t };
    if (Ta()) {
      var o, n;
      const s = Le(e);
      r.x -= ((o = s.visualViewport) == null ? void 0 : o.offsetLeft) || 0, r.y -= ((n = s.visualViewport) == null ? void 0 : n.offsetTop) || 0;
    }
    l = r;
  }
  return $t(l);
}
function pl(e, t) {
  return Ue(e) && Ye(e).position !== "fixed" ? t ? t(e) : e.offsetParent : null;
}
function gl(e, t) {
  const a = Le(e);
  if (!Ue(e))
    return a;
  let l = pl(e, t);
  for (; l && Ls(l) && Ye(l).position === "static"; )
    l = pl(l, t);
  return l && (st(l) === "html" || st(l) === "body" && Ye(l).position === "static" && !Ca(l)) ? a : l || function(o) {
    let n = Ft(o);
    for (; Ue(n) && !Wa(n); ) {
      if (Ca(n))
        return n;
      n = Ft(n);
    }
    return null;
  }(e) || a;
}
function Ns(e, t, a) {
  const l = Ue(t), o = nt(t), n = ft(e, !0, a === "fixed", t);
  let r = { scrollLeft: 0, scrollTop: 0 };
  const s = { x: 0, y: 0 };
  if (l || !l && a !== "fixed")
    if ((st(t) !== "body" || va(o)) && (r = ma(t)), Ue(t)) {
      const f = ft(t, !0);
      s.x = f.x + t.clientLeft, s.y = f.y + t.clientTop;
    } else
      o && (s.x = zo(o));
  return { x: n.left + r.scrollLeft - s.x, y: n.top + r.scrollTop - s.y, width: n.width, height: n.height };
}
const zs = { getClippingRect: function(e) {
  let { element: t, boundary: a, rootBoundary: l, strategy: o } = e;
  const n = a === "clippingAncestors" ? function(m, y) {
    const b = y.get(m);
    if (b)
      return b;
    let v = Pt(m).filter((h) => We(h) && st(h) !== "body"), B = null;
    const p = Ye(m).position === "fixed";
    let S = p ? Ft(m) : m;
    for (; We(S) && !Wa(S); ) {
      const h = Ye(S), $ = Ca(S);
      h.position === "fixed" && (B = null), (p ? $ || B : $ || h.position !== "static" || !B || !["absolute", "fixed"].includes(B.position)) ? B = h : v = v.filter((k) => k !== S), S = Ft(S);
    }
    return y.set(m, v), v;
  }(t, this._c) : [].concat(a), r = [...n, l], s = r[0], f = r.reduce((m, y) => {
    const b = ml(t, y, o);
    return m.top = Vt(b.top, m.top), m.right = vl(b.right, m.right), m.bottom = vl(b.bottom, m.bottom), m.left = Vt(b.left, m.left), m;
  }, ml(t, s, o));
  return { width: f.right - f.left, height: f.bottom - f.top, x: f.left, y: f.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(e) {
  let { rect: t, offsetParent: a, strategy: l } = e;
  const o = Ue(a), n = nt(a);
  if (a === n)
    return t;
  let r = { scrollLeft: 0, scrollTop: 0 }, s = { x: 1, y: 1 };
  const f = { x: 0, y: 0 };
  if ((o || !o && l !== "fixed") && ((st(a) !== "body" || va(n)) && (r = ma(a)), Ue(a))) {
    const m = ft(a);
    s = Bt(a), f.x = m.x + a.clientLeft, f.y = m.y + a.clientTop;
  }
  return { width: t.width * s.x, height: t.height * s.y, x: t.x * s.x - r.scrollLeft * s.x + f.x, y: t.y * s.y - r.scrollTop * s.y + f.y };
}, isElement: We, getDimensions: function(e) {
  return Fo(e);
}, getOffsetParent: gl, getDocumentElement: nt, getScale: Bt, async getElementRects(e) {
  let { reference: t, floating: a, strategy: l } = e;
  const o = this.getOffsetParent || gl, n = this.getDimensions;
  return { reference: Ns(t, await o(a), l), floating: { x: 0, y: 0, ...await n(a) } };
}, getClientRects: (e) => Array.from(e.getClientRects()), isRTL: (e) => Ye(e).direction === "rtl" };
function Rs(e, t, a, l) {
  l === void 0 && (l = {});
  const { ancestorScroll: o = !0, ancestorResize: n = !0, elementResize: r = !0, animationFrame: s = !1 } = l, f = o && !s, m = f || n ? [...We(e) ? Pt(e) : e.contextElement ? Pt(e.contextElement) : [], ...Pt(t)] : [];
  m.forEach((B) => {
    f && B.addEventListener("scroll", a, { passive: !0 }), n && B.addEventListener("resize", a);
  });
  let y, b = null;
  r && (b = new ResizeObserver(() => {
    a();
  }), We(e) && !s && b.observe(e), We(e) || !e.contextElement || s || b.observe(e.contextElement), b.observe(t));
  let v = s ? ft(e) : null;
  return s && function B() {
    const p = ft(e);
    !v || p.x === v.x && p.y === v.y && p.width === v.width && p.height === v.height || a(), v = p, y = requestAnimationFrame(B);
  }(), a(), () => {
    var B;
    m.forEach((p) => {
      f && p.removeEventListener("scroll", a), n && p.removeEventListener("resize", a);
    }), (B = b) == null || B.disconnect(), b = null, s && cancelAnimationFrame(y);
  };
}
const Hs = (e, t, a) => {
  const l = /* @__PURE__ */ new Map(), o = { platform: zs, ...a }, n = { ...o.platform, _c: l };
  return xs(e, t, { ...o, platform: n });
};
function _a(e) {
  var t;
  return (t = e == null ? void 0 : e.$el) != null ? t : e;
}
function Ms(e) {
  return {
    name: "arrow",
    options: e,
    fn(t) {
      const a = _a(i(e.element));
      return a == null ? {} : As({
        element: a,
        padding: e.padding
      }).fn(t);
    }
  };
}
function Ho(e, t, a) {
  a === void 0 && (a = {});
  const l = a.whileElementsMounted, o = u(() => {
    var T;
    return (T = i(a.open)) != null ? T : !0;
  }), n = u(() => i(a.middleware)), r = u(() => {
    var T;
    return (T = i(a.placement)) != null ? T : "bottom";
  }), s = u(() => {
    var T;
    return (T = i(a.strategy)) != null ? T : "absolute";
  }), f = u(() => _a(e.value)), m = u(() => _a(t.value)), y = z(null), b = z(null), v = z(s.value), B = z(r.value), p = Na({}), S = z(!1);
  let h;
  function $() {
    f.value == null || m.value == null || Hs(f.value, m.value, {
      middleware: n.value,
      placement: r.value,
      strategy: s.value
    }).then((T) => {
      y.value = T.x, b.value = T.y, v.value = T.strategy, B.value = T.placement, p.value = T.middlewareData, S.value = !0;
    });
  }
  function k() {
    typeof h == "function" && (h(), h = void 0);
  }
  function w() {
    if (k(), l === void 0) {
      $();
      return;
    }
    if (f.value != null && m.value != null) {
      h = l(f.value, m.value, $);
      return;
    }
  }
  function A() {
    o.value || (S.value = !1);
  }
  return se([n, r, s], $, {
    flush: "sync"
  }), se([f, m], w, {
    flush: "sync"
  }), se(o, A, {
    flush: "sync"
  }), Zl() && Ql(k), {
    x: mt(y),
    y: mt(b),
    strategy: mt(v),
    placement: mt(B),
    middlewareData: mt(p),
    isPositioned: mt(S),
    update: $
  };
}
const Ds = /* @__PURE__ */ new Set([
  "background",
  "cite",
  "href",
  "itemtype",
  "longdesc",
  "poster",
  "src",
  "xlink:href"
]), js = /^aria-[\w-]*$/i, qs = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, Gs = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i, Ws = (e, t) => {
  const a = e.nodeName.toLowerCase();
  return t.includes(a) ? Ds.has(a) ? !!(qs.test(e.nodeValue || "") || Gs.test(e.nodeValue || "")) : !0 : t.filter((l) => l instanceof RegExp).some((l) => l.test(a));
}, bt = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", js],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
}, ht = (e, t, a) => {
  if (!e.length)
    return e;
  if (a && typeof a == "function")
    return a(e);
  const o = new window.DOMParser().parseFromString(e, "text/html"), n = o.body.querySelectorAll("*");
  for (const r of n) {
    const s = r.nodeName.toLowerCase();
    if (!Object.keys(t).includes(s)) {
      r.remove();
      continue;
    }
    const f = r.attributes, m = [...t["*"] || [], ...t[s] || []];
    for (const y of f)
      Ws(y, m) || r.removeAttribute(y.nodeName);
  }
  return o.body.innerHTML;
};
var Us = Object.defineProperty, Xs = Object.defineProperties, Ks = Object.getOwnPropertyDescriptors, bl = Object.getOwnPropertySymbols, Js = Object.prototype.hasOwnProperty, Ys = Object.prototype.propertyIsEnumerable, hl = (e, t, a) => t in e ? Us(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a, Zs = (e, t) => {
  for (var a in t || (t = {}))
    Js.call(t, a) && hl(e, a, t[a]);
  if (bl)
    for (var a of bl(t))
      Ys.call(t, a) && hl(e, a, t[a]);
  return e;
}, Qs = (e, t) => Xs(e, Ks(t));
function Mo(e, t) {
  var a;
  const l = Na();
  return De(() => {
    l.value = e();
  }, Qs(Zs({}, t), {
    flush: (a = t == null ? void 0 : t.flush) != null ? a : "sync"
  })), Se(l);
}
function Lt(e) {
  return Zl() ? (Ql(e), !0) : !1;
}
function ei(e) {
  let t = 0, a, l;
  const o = () => {
    t -= 1, l && t <= 0 && (l.stop(), a = void 0, l = void 0);
  };
  return (...n) => (t += 1, a || (l = Hn(!0), a = l.run(() => e(...n))), Lt(o), a);
}
function Ct(e) {
  return typeof e == "function" ? e() : i(e);
}
const Ee = Ct, aa = typeof window < "u", ti = (e) => typeof e < "u", Nt = () => {
}, ai = /* @__PURE__ */ li();
function li() {
  var e;
  return aa && ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.userAgent) && /* @__PURE__ */ /iP(ad|hone|od)/.test(window.navigator.userAgent);
}
function oi(e, t) {
  function a(...l) {
    return new Promise((o, n) => {
      Promise.resolve(e(() => t.apply(this, l), { fn: t, thisArg: this, args: l })).then(o).catch(n);
    });
  }
  return a;
}
const Do = (e) => e();
function ni(e = Do) {
  const t = z(!0);
  function a() {
    t.value = !1;
  }
  function l() {
    t.value = !0;
  }
  const o = (...n) => {
    t.value && e(...n);
  };
  return { isActive: Se(t), pause: a, resume: l, eventFilter: o };
}
function jo(...e) {
  if (e.length !== 1)
    return d(...e);
  const t = e[0];
  return typeof t == "function" ? Se(Mn(() => ({ get: t, set: Nt }))) : z(t);
}
function si(e, t = !0) {
  ia() ? Xe(e) : t ? e() : Te(e);
}
function ii(e = 0, t = {}) {
  const a = z(e), {
    max: l = 1 / 0,
    min: o = -1 / 0
  } = t, n = (y = 1) => a.value = Math.min(l, a.value + y), r = (y = 1) => a.value = Math.max(o, a.value - y), s = () => a.value, f = (y) => a.value = Math.max(o, Math.min(l, y));
  return { count: a, inc: n, dec: r, get: s, set: f, reset: (y = e) => (e = y, f(y)) };
}
function qo(e, t = 1e3, a = {}) {
  const {
    immediate: l = !0,
    immediateCallback: o = !1
  } = a;
  let n = null;
  const r = z(!1);
  function s() {
    n && (clearInterval(n), n = null);
  }
  function f() {
    r.value = !1, s();
  }
  function m() {
    const y = Ct(t);
    y <= 0 || (r.value = !0, o && e(), s(), n = setInterval(e, y));
  }
  if (l && aa && m(), kt(t) || typeof t == "function") {
    const y = se(t, () => {
      r.value && aa && m();
    });
    Lt(y);
  }
  return Lt(f), {
    isActive: r,
    pause: f,
    resume: m
  };
}
function yt(e, t = {}) {
  const {
    method: a = "parseFloat",
    radix: l,
    nanToZero: o
  } = t;
  return u(() => {
    let n = Ct(e);
    return typeof n == "string" && (n = Number[a](n, l)), o && isNaN(n) && (n = 0), n;
  });
}
var yl = Object.getOwnPropertySymbols, ri = Object.prototype.hasOwnProperty, ui = Object.prototype.propertyIsEnumerable, di = (e, t) => {
  var a = {};
  for (var l in e)
    ri.call(e, l) && t.indexOf(l) < 0 && (a[l] = e[l]);
  if (e != null && yl)
    for (var l of yl(e))
      t.indexOf(l) < 0 && ui.call(e, l) && (a[l] = e[l]);
  return a;
};
function ci(e, t, a = {}) {
  const l = a, {
    eventFilter: o = Do
  } = l, n = di(l, [
    "eventFilter"
  ]);
  return se(
    e,
    oi(
      o,
      t
    ),
    n
  );
}
var fi = Object.defineProperty, vi = Object.defineProperties, mi = Object.getOwnPropertyDescriptors, la = Object.getOwnPropertySymbols, Go = Object.prototype.hasOwnProperty, Wo = Object.prototype.propertyIsEnumerable, Bl = (e, t, a) => t in e ? fi(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a, pi = (e, t) => {
  for (var a in t || (t = {}))
    Go.call(t, a) && Bl(e, a, t[a]);
  if (la)
    for (var a of la(t))
      Wo.call(t, a) && Bl(e, a, t[a]);
  return e;
}, gi = (e, t) => vi(e, mi(t)), bi = (e, t) => {
  var a = {};
  for (var l in e)
    Go.call(e, l) && t.indexOf(l) < 0 && (a[l] = e[l]);
  if (e != null && la)
    for (var l of la(e))
      t.indexOf(l) < 0 && Wo.call(e, l) && (a[l] = e[l]);
  return a;
};
function hi(e, t, a = {}) {
  const l = a, {
    eventFilter: o
  } = l, n = bi(l, [
    "eventFilter"
  ]), { eventFilter: r, pause: s, resume: f, isActive: m } = ni(o);
  return { stop: ci(
    e,
    t,
    gi(pi({}, n), {
      eventFilter: r
    })
  ), pause: s, resume: f, isActive: m };
}
function tt(e) {
  var t;
  const a = Ct(e);
  return (t = a == null ? void 0 : a.$el) != null ? t : a;
}
const at = aa ? window : void 0;
function Ce(...e) {
  let t, a, l, o;
  if (typeof e[0] == "string" || Array.isArray(e[0]) ? ([a, l, o] = e, t = at) : [t, a, l, o] = e, !t)
    return Nt;
  Array.isArray(a) || (a = [a]), Array.isArray(l) || (l = [l]);
  const n = [], r = () => {
    n.forEach((y) => y()), n.length = 0;
  }, s = (y, b, v, B) => (y.addEventListener(b, v, B), () => y.removeEventListener(b, v, B)), f = se(
    () => [tt(t), Ct(o)],
    ([y, b]) => {
      r(), y && n.push(
        ...a.flatMap((v) => l.map((B) => s(y, v, B, b)))
      );
    },
    { immediate: !0, flush: "post" }
  ), m = () => {
    f(), r();
  };
  return Lt(m), m;
}
let $l = !1;
function Uo(e, t, a = {}) {
  const { window: l = at, ignore: o = [], capture: n = !0, detectIframe: r = !1 } = a;
  if (!l)
    return;
  ai && !$l && ($l = !0, Array.from(l.document.body.children).forEach((v) => v.addEventListener("click", Nt)));
  let s = !0;
  const f = (v) => o.some((B) => {
    if (typeof B == "string")
      return Array.from(l.document.querySelectorAll(B)).some((p) => p === v.target || v.composedPath().includes(p));
    {
      const p = tt(B);
      return p && (v.target === p || v.composedPath().includes(p));
    }
  }), y = [
    Ce(l, "click", (v) => {
      const B = tt(e);
      if (!(!B || B === v.target || v.composedPath().includes(B))) {
        if (v.detail === 0 && (s = !f(v)), !s) {
          s = !0;
          return;
        }
        t(v);
      }
    }, { passive: !0, capture: n }),
    Ce(l, "pointerdown", (v) => {
      const B = tt(e);
      B && (s = !v.composedPath().includes(B) && !f(v));
    }, { passive: !0 }),
    r && Ce(l, "blur", (v) => {
      var B;
      const p = tt(e);
      ((B = l.document.activeElement) == null ? void 0 : B.tagName) === "IFRAME" && !(p != null && p.contains(l.document.activeElement)) && t(v);
    })
  ].filter(Boolean);
  return () => y.forEach((v) => v());
}
function yi() {
  const e = z(!1);
  return ia() && Xe(() => {
    e.value = !0;
  }), e;
}
function Bi(e) {
  const t = yi();
  return u(() => (t.value, !!e()));
}
function $i(e, t = {}) {
  const { window: a = at } = t, l = Bi(() => a && "matchMedia" in a && typeof a.matchMedia == "function");
  let o;
  const n = z(!1), r = () => {
    o && ("removeEventListener" in o ? o.removeEventListener("change", s) : o.removeListener(s));
  }, s = () => {
    l.value && (r(), o = a.matchMedia(jo(e).value), n.value = !!(o != null && o.matches), o && ("addEventListener" in o ? o.addEventListener("change", s) : o.addListener(s)));
  };
  return De(s), Lt(() => r()), n;
}
function wi(e) {
  return JSON.parse(JSON.stringify(e));
}
const jt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, qt = "__vueuse_ssr_handlers__", ki = /* @__PURE__ */ Si();
function Si() {
  return qt in jt || (jt[qt] = jt[qt] || {}), jt[qt];
}
function Ua(e, t) {
  return ki[e] || t;
}
function Ci(e) {
  return e == null ? "any" : e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof Date ? "date" : typeof e == "boolean" ? "boolean" : typeof e == "string" ? "string" : typeof e == "object" ? "object" : Number.isNaN(e) ? "any" : "number";
}
var Ti = Object.defineProperty, wl = Object.getOwnPropertySymbols, _i = Object.prototype.hasOwnProperty, xi = Object.prototype.propertyIsEnumerable, kl = (e, t, a) => t in e ? Ti(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a, Sl = (e, t) => {
  for (var a in t || (t = {}))
    _i.call(t, a) && kl(e, a, t[a]);
  if (wl)
    for (var a of wl(t))
      xi.call(t, a) && kl(e, a, t[a]);
  return e;
};
const Ai = {
  boolean: {
    read: (e) => e === "true",
    write: (e) => String(e)
  },
  object: {
    read: (e) => JSON.parse(e),
    write: (e) => JSON.stringify(e)
  },
  number: {
    read: (e) => Number.parseFloat(e),
    write: (e) => String(e)
  },
  any: {
    read: (e) => e,
    write: (e) => String(e)
  },
  string: {
    read: (e) => e,
    write: (e) => String(e)
  },
  map: {
    read: (e) => new Map(JSON.parse(e)),
    write: (e) => JSON.stringify(Array.from(e.entries()))
  },
  set: {
    read: (e) => new Set(JSON.parse(e)),
    write: (e) => JSON.stringify(Array.from(e))
  },
  date: {
    read: (e) => new Date(e),
    write: (e) => e.toISOString()
  }
}, Cl = "vueuse-storage";
function Vi(e, t, a, l = {}) {
  var o;
  const {
    flush: n = "pre",
    deep: r = !0,
    listenToStorageChanges: s = !0,
    writeDefaults: f = !0,
    mergeDefaults: m = !1,
    shallow: y,
    window: b = at,
    eventFilter: v,
    onError: B = (O) => {
      console.error(O);
    }
  } = l, p = (y ? Na : z)(t);
  if (!a)
    try {
      a = Ua("getDefaultStorage", () => {
        var O;
        return (O = at) == null ? void 0 : O.localStorage;
      })();
    } catch (O) {
      B(O);
    }
  if (!a)
    return p;
  const S = Ct(t), h = Ci(S), $ = (o = l.serializer) != null ? o : Ai[h], { pause: k, resume: w } = hi(
    p,
    () => A(p.value),
    { flush: n, deep: r, eventFilter: v }
  );
  return b && s && (Ce(b, "storage", I), Ce(b, Cl, C)), I(), p;
  function A(O) {
    try {
      if (O == null)
        a.removeItem(e);
      else {
        const F = $.write(O), _ = a.getItem(e);
        _ !== F && (a.setItem(e, F), b && b.dispatchEvent(new CustomEvent(Cl, {
          detail: {
            key: e,
            oldValue: _,
            newValue: F,
            storageArea: a
          }
        })));
      }
    } catch (F) {
      B(F);
    }
  }
  function T(O) {
    const F = O ? O.newValue : a.getItem(e);
    if (F == null)
      return f && S !== null && a.setItem(e, $.write(S)), S;
    if (!O && m) {
      const _ = $.read(F);
      return typeof m == "function" ? m(_, S) : h === "object" && !Array.isArray(_) ? Sl(Sl({}, S), _) : _;
    } else
      return typeof F != "string" ? F : $.read(F);
  }
  function C(O) {
    I(O.detail);
  }
  function I(O) {
    if (!(O && O.storageArea !== a)) {
      if (O && O.key == null) {
        p.value = S;
        return;
      }
      if (!(O && O.key !== e)) {
        k();
        try {
          p.value = T(O);
        } catch (F) {
          B(F);
        } finally {
          O ? Te(w) : w();
        }
      }
    }
  }
}
function Pi(e) {
  return $i("(prefers-color-scheme: dark)", e);
}
var Oi = Object.defineProperty, Tl = Object.getOwnPropertySymbols, Ei = Object.prototype.hasOwnProperty, Ii = Object.prototype.propertyIsEnumerable, _l = (e, t, a) => t in e ? Oi(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a, Fi = (e, t) => {
  for (var a in t || (t = {}))
    Ei.call(t, a) && _l(e, a, t[a]);
  if (Tl)
    for (var a of Tl(t))
      Ii.call(t, a) && _l(e, a, t[a]);
  return e;
};
function Li(e = {}) {
  const {
    selector: t = "html",
    attribute: a = "class",
    initialValue: l = "auto",
    window: o = at,
    storage: n,
    storageKey: r = "vueuse-color-scheme",
    listenToStorageChanges: s = !0,
    storageRef: f,
    emitAuto: m,
    disableTransition: y = !0
  } = e, b = Fi({
    auto: "",
    light: "light",
    dark: "dark"
  }, e.modes || {}), v = Pi({ window: o }), B = u(() => v.value ? "dark" : "light"), p = f || (r == null ? jo(l) : Vi(r, l, n, { window: o, listenToStorageChanges: s })), S = u(
    () => p.value === "auto" ? B.value : p.value
  ), h = Ua(
    "updateHTMLAttrs",
    (A, T, C) => {
      const I = typeof A == "string" ? o == null ? void 0 : o.document.querySelector(A) : tt(A);
      if (!I)
        return;
      let O;
      if (y && (O = o.document.createElement("style"), O.appendChild(document.createTextNode("*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")), o.document.head.appendChild(O)), T === "class") {
        const F = C.split(/\s/g);
        Object.values(b).flatMap((_) => (_ || "").split(/\s/g)).filter(Boolean).forEach((_) => {
          F.includes(_) ? I.classList.add(_) : I.classList.remove(_);
        });
      } else
        I.setAttribute(T, C);
      y && (o.getComputedStyle(O).opacity, document.head.removeChild(O));
    }
  );
  function $(A) {
    var T;
    h(t, a, (T = b[A]) != null ? T : A);
  }
  function k(A) {
    e.onChanged ? e.onChanged(A, $) : $(A);
  }
  se(S, k, { flush: "post", immediate: !0 }), si(() => k(S.value));
  const w = u({
    get() {
      return m ? p.value : S.value;
    },
    set(A) {
      p.value = A;
    }
  });
  try {
    return Object.assign(w, { store: p, system: B, state: S });
  } catch {
    return w;
  }
}
function qe(e, t = {}) {
  const { initialValue: a = !1 } = t, l = z(!1), o = u(() => tt(e));
  Ce(o, "focus", () => l.value = !0), Ce(o, "blur", () => l.value = !1);
  const n = u({
    get: () => l.value,
    set(r) {
      var s, f;
      !r && l.value ? (s = o.value) == null || s.blur() : r && !l.value && ((f = o.value) == null || f.focus());
    }
  });
  return se(
    o,
    () => {
      n.value = a;
    },
    { immediate: !0, flush: "post" }
  ), { focused: n };
}
const Ni = {
  page: (e) => [e.pageX, e.pageY],
  client: (e) => [e.clientX, e.clientY],
  screen: (e) => [e.screenX, e.screenY],
  movement: (e) => e instanceof Touch ? null : [e.movementX, e.movementY]
};
function zi(e = {}) {
  const {
    type: t = "page",
    touch: a = !0,
    resetOnTouchEnds: l = !1,
    initialValue: o = { x: 0, y: 0 },
    window: n = at,
    target: r = n,
    eventFilter: s
  } = e, f = z(o.x), m = z(o.y), y = z(null), b = typeof t == "function" ? t : Ni[t], v = ($) => {
    const k = b($);
    k && ([f.value, m.value] = k, y.value = "mouse");
  }, B = ($) => {
    if ($.touches.length > 0) {
      const k = b($.touches[0]);
      k && ([f.value, m.value] = k, y.value = "touch");
    }
  }, p = () => {
    f.value = o.x, m.value = o.y;
  }, S = s ? ($) => s(() => v($), {}) : ($) => v($), h = s ? ($) => s(() => B($), {}) : ($) => B($);
  return r && (Ce(r, "mousemove", S, { passive: !0 }), Ce(r, "dragover", S, { passive: !0 }), a && t !== "movement" && (Ce(r, "touchstart", h, { passive: !0 }), Ce(r, "touchmove", h, { passive: !0 }), l && Ce(r, "touchend", p, { passive: !0 }))), {
    x: f,
    y: m,
    sourceType: y
  };
}
function xl(e, t = {}) {
  const {
    handleOutside: a = !0,
    window: l = at
  } = t, { x: o, y: n, sourceType: r } = zi(t), s = z(e ?? (l == null ? void 0 : l.document.body)), f = z(0), m = z(0), y = z(0), b = z(0), v = z(0), B = z(0), p = z(!0);
  let S = () => {
  };
  return l && (S = se(
    [s, o, n],
    () => {
      const h = tt(s);
      if (!h)
        return;
      const {
        left: $,
        top: k,
        width: w,
        height: A
      } = h.getBoundingClientRect();
      y.value = $ + l.pageXOffset, b.value = k + l.pageYOffset, v.value = A, B.value = w;
      const T = o.value - y.value, C = n.value - b.value;
      p.value = w === 0 || A === 0 || T < 0 || C < 0 || T > w || C > A, (a || !p.value) && (f.value = T, m.value = C);
    },
    { immediate: !0 }
  ), Ce(document, "mouseleave", () => {
    p.value = !0;
  })), {
    x: o,
    y: n,
    sourceType: r,
    elementX: f,
    elementY: m,
    elementPositionX: y,
    elementPositionY: b,
    elementHeight: v,
    elementWidth: B,
    isOutside: p,
    stop: S
  };
}
function Ri(e, t = {}) {
  const {
    threshold: a = 50,
    onSwipe: l,
    onSwipeEnd: o,
    onSwipeStart: n,
    passive: r = !0,
    window: s = at
  } = t, f = dt({ x: 0, y: 0 }), m = dt({ x: 0, y: 0 }), y = u(() => f.x - m.x), b = u(() => f.y - m.y), { max: v, abs: B } = Math, p = u(() => v(B(y.value), B(b.value)) >= a), S = z(!1), h = u(() => p.value ? B(y.value) > B(b.value) ? y.value > 0 ? "left" : "right" : b.value > 0 ? "up" : "down" : "none"), $ = (F) => [F.touches[0].clientX, F.touches[0].clientY], k = (F, _) => {
    f.x = F, f.y = _;
  }, w = (F, _) => {
    m.x = F, m.y = _;
  };
  let A;
  const T = Hi(s == null ? void 0 : s.document);
  r ? A = T ? { passive: !0 } : { capture: !1 } : A = T ? { passive: !1, capture: !0 } : { capture: !0 };
  const C = (F) => {
    S.value && (o == null || o(F, h.value)), S.value = !1;
  }, I = [
    Ce(e, "touchstart", (F) => {
      if (F.touches.length !== 1)
        return;
      A.capture && !A.passive && F.preventDefault();
      const [_, P] = $(F);
      k(_, P), w(_, P), n == null || n(F);
    }, A),
    Ce(e, "touchmove", (F) => {
      if (F.touches.length !== 1)
        return;
      const [_, P] = $(F);
      w(_, P), !S.value && p.value && (S.value = !0), S.value && (l == null || l(F));
    }, A),
    Ce(e, "touchend", C, A),
    Ce(e, "touchcancel", C, A)
  ];
  return {
    isPassiveEventSupported: T,
    isSwiping: S,
    direction: h,
    coordsStart: f,
    coordsEnd: m,
    lengthX: y,
    lengthY: b,
    stop: () => I.forEach((F) => F())
  };
}
function Hi(e) {
  if (!e)
    return !1;
  let t = !1;
  const a = {
    get passive() {
      return t = !0, !1;
    }
  };
  return e.addEventListener("x", Nt, a), e.removeEventListener("x", Nt), t;
}
function xe(e, t, a, l = {}) {
  var o, n, r;
  const {
    clone: s = !1,
    passive: f = !1,
    eventName: m,
    deep: y = !1,
    defaultValue: b,
    shouldEmit: v
  } = l, B = ia(), p = a || (B == null ? void 0 : B.emit) || ((o = B == null ? void 0 : B.$emit) == null ? void 0 : o.bind(B)) || ((r = (n = B == null ? void 0 : B.proxy) == null ? void 0 : n.$emit) == null ? void 0 : r.bind(B == null ? void 0 : B.proxy));
  let S = m;
  t || (t = "modelValue"), S = m || S || `update:${t.toString()}`;
  const h = (w) => s ? typeof s == "function" ? s(w) : wi(w) : w, $ = () => ti(e[t]) ? h(e[t]) : b, k = (w) => {
    v ? v(w) && p(S, w) : p(S, w);
  };
  if (f) {
    const w = $(), A = z(w);
    return se(
      () => e[t],
      (T) => A.value = h(T)
    ), se(
      A,
      (T) => {
        (T !== e[t] || y) && k(T);
      },
      { deep: y }
    ), A;
  } else
    return u({
      get() {
        return $();
      },
      set(w) {
        k(w);
      }
    });
}
const Xa = H({
  name: "ComponentOrEmpty",
  props: {
    tag: {
      type: String,
      default: "div"
    },
    to: {
      type: [String, Object],
      default: null
    },
    skip: {
      type: Boolean,
      default: !1
    }
  },
  setup(e, { slots: t, attrs: a }) {
    return () => {
      var l, o, n;
      return e.skip ? (l = t.default) == null ? void 0 : l.call(t) : e.tag === "Teleport" ? re(za, { to: e.to }, [(o = t.default) == null ? void 0 : o.call(t)]) : re(e.tag, { ...a }, [(n = t.default) == null ? void 0 : n.call(t)]);
    };
  }
}), Ht = (e) => Mo(() => e.value ? `justify-content-${e.value}` : "");
function c(e) {
  return Mo(
    () => e.value === void 0 || e.value === null ? e.value : no(e.value)
  );
}
const Xo = {
  items: dt([]),
  reset() {
    this.items = dt([]);
  }
}, Ko = (e) => {
  e.provide(Bo, Xo);
}, Jo = () => Ie(Bo, null) ?? Xo, Mi = (e = {}) => {
  const t = e.persist ?? !1, a = "data-bs-theme", l = "body";
  return Li({
    attribute: a,
    selector: l,
    storageKey: t === !0 ? `bv-color-${e.attribute ?? a}-${e.selector ?? l}` : null,
    ...e
  });
}, Di = (e, t = z(1e3), a = {}) => {
  const l = z(!1), o = z(0), n = z(Ee(e)), r = z(Ee(t)), s = u(() => Math.ceil(n.value / r.value)), f = u(
    () => b.value || l.value ? Math.round(n.value - o.value * r.value) : 0
  ), { pause: m, resume: y, isActive: b } = qo(
    () => o.value = o.value + 1,
    t,
    a
  ), v = () => {
    l.value = !1, o.value = 0, y();
  }, B = () => {
    l.value = !1, o.value = s.value;
  };
  De(() => {
    const h = Ee(e), $ = n.value;
    h !== $ && (n.value = h, B(), v());
  }), De(() => {
    const h = Ee(t), $ = r.value;
    h !== $ && (r.value = h, B(), v());
  }), De(() => {
    o.value > s.value && (o.value = s.value), o.value === s.value && m();
  });
  const p = () => {
    b.value !== !1 && (l.value = !0, m());
  }, S = () => {
    o.value !== s.value && (l.value = !1, y());
  };
  return {
    isActive: Se(b),
    isPaused: Se(l),
    restart: v,
    stop: B,
    pause: p,
    resume: S,
    value: f
  };
}, Yo = (e) => {
  const t = z(Ee(e));
  return De(() => t.value = Ee(e)), u(() => ({
    "form-check": t.value.plain === !1 && t.value.button === !1,
    "form-check-inline": t.value.inline === !0,
    "form-switch": t.value.switch === !0,
    [`form-control-${t.value.size}`]: t.value.size !== void 0 && t.value.size !== "md" && t.value.button === !1
  }));
}, Zo = (e) => {
  const t = z(Ee(e));
  return De(() => t.value = Ee(e)), u(() => ({
    "form-check-input": t.value.plain === !1 && t.value.button === !1,
    "is-valid": t.value.state === !0,
    "is-invalid": t.value.state === !1,
    "btn-check": t.value.button === !0
  }));
}, Qo = (e) => {
  const t = z(Ee(e));
  return De(() => t.value = Ee(e)), u(() => ({
    "form-check-label": t.value.plain === !1 && t.value.button === !1,
    btn: t.value.button === !0,
    [`btn-${t.value.buttonVariant}`]: t.value.button === !0 && t.value.buttonVariant !== void 0,
    [`btn-${t.value.size}`]: t.value.button && t.value.size && t.value.size !== "md"
  }));
}, en = (e) => {
  const t = z(Ee(e));
  return De(() => t.value = Ee(e)), u(() => ({
    "aria-invalid": fa(t.value.ariaInvalid, t.value.state),
    "aria-required": t.value.required === !0 ? !0 : void 0
  }));
}, tn = (e) => {
  const t = z(Ee(e));
  return De(() => t.value = Ee(e)), u(() => ({
    "was-validated": t.value.validated === !0,
    "btn-group": t.value.buttons === !0 && t.value.stacked === !1,
    "btn-group-vertical": t.value.stacked === !0 && t.value.buttons === !0,
    [`btn-group-${t.value.size}`]: t.value.size !== void 0
  }));
}, an = {
  ariaInvalid: {
    type: [Boolean, String],
    default: void 0
  },
  autocomplete: { type: String, required: !1 },
  autofocus: { type: Boolean, default: !1 },
  disabled: { type: Boolean, default: !1 },
  form: { type: String, required: !1 },
  formatter: { type: Function, required: !1 },
  id: { type: String, required: !1 },
  lazy: { type: Boolean, default: !1 },
  lazyFormatter: { type: Boolean, default: !1 },
  list: { type: String, required: !1 },
  modelValue: { type: [String, Number], default: "" },
  name: { type: String, required: !1 },
  number: { type: Boolean, default: !1 },
  placeholder: { type: String, required: !1 },
  plaintext: { type: Boolean, default: !1 },
  readonly: { type: Boolean, default: !1 },
  required: { type: Boolean, default: !1 },
  size: { type: String, required: !1 },
  state: { type: Boolean, default: null },
  trim: { type: Boolean, default: !1 }
}, ln = (e, t) => {
  const a = z();
  let l = null, o = !0;
  const n = _e(d(e, "id"), "input"), r = c(d(e, "state")), s = (h, $, k = !1) => (h = String(h), typeof e.formatter == "function" && (!e.lazyFormatter || k) ? (o = !1, e.formatter(h, $)) : h), f = (h) => e.trim ? h.trim() : e.number ? Number.parseFloat(h) : h, m = () => {
    var h;
    e.autofocus && ((h = a.value) == null || h.focus());
  };
  Xe(() => {
    a.value && (a.value.value = e.modelValue), Te(() => {
      m();
    });
  }), Dn(() => {
    Te(() => {
    });
  });
  const y = u(
    () => fa(e.ariaInvalid, r.value)
  ), b = (h) => {
    const { value: $ } = h.target, k = s($, h);
    if (k === !1 || h.defaultPrevented) {
      h.preventDefault();
      return;
    }
    if (e.lazy)
      return;
    const w = f(k);
    e.modelValue !== w && (l = $, t("update:modelValue", w)), t("input", k);
  }, v = (h) => {
    const { value: $ } = h.target, k = s($, h);
    if (k === !1 || h.defaultPrevented) {
      h.preventDefault();
      return;
    }
    if (!e.lazy)
      return;
    l = $, t("update:modelValue", k);
    const w = f(k);
    e.modelValue !== w && t("change", k);
  }, B = (h) => {
    if (t("blur", h), !e.lazy && !e.lazyFormatter)
      return;
    const { value: $ } = h.target, k = s($, h, !0);
    l = $, t("update:modelValue", k);
  }, p = () => {
    var h;
    e.disabled || (h = a.value) == null || h.focus();
  }, S = () => {
    var h;
    e.disabled || (h = a.value) == null || h.blur();
  };
  return se(
    () => e.modelValue,
    (h) => {
      a.value && (a.value.value = l && o ? l : h, l = null, o = !0);
    }
  ), {
    input: a,
    computedId: n,
    computedAriaInvalid: y,
    onInput: b,
    onChange: v,
    onBlur: B,
    focus: p,
    blur: S
  };
}, gt = (e, t) => {
  if (!e)
    return e;
  if (t in e)
    return e[t];
  const a = t.split(".");
  return gt(e[a[0]], a.splice(1).join("."));
}, ha = (e, t = null, a, l) => {
  if (Object.prototype.toString.call(e) === "[object Object]") {
    const o = gt(e, l.valueField), n = gt(e, l.textField), r = gt(e, l.htmlField), s = gt(e, l.disabledField), f = e[l.optionsField] || null;
    return f !== null ? {
      label: String(gt(e, l.labelField) || n),
      options: Ka(f, a, l)
    } : {
      value: typeof o > "u" ? t || n : o,
      text: String(typeof n > "u" ? t : n),
      html: r,
      disabled: !!s
    };
  }
  return {
    value: t || e,
    text: String(e),
    disabled: !1
  };
}, Ka = (e, t, a) => Array.isArray(e) ? e.map((l) => ha(l, null, t, a)) : Object.prototype.toString.call(e) === "[object Object]" ? (console.warn(
  `[BootstrapVue warn]: ${t} - Setting prop "options" to an object is deprecated. Use the array format instead.`
), Object.keys(e).map((l) => {
  const o = e[l];
  switch (typeof o) {
    case "object":
      return ha(o.text, String(o.value), t, a);
    default:
      return ha(o, String(l), t, a);
  }
})) : [], _e = (e, t) => u(() => (e == null ? void 0 : e.value) || lt(t)), ya = "modal-open", ji = ei(() => {
  const { count: e, inc: t, dec: a } = ii(), l = Ua("updateHTMLAttrs", (o, n, r) => {
    const s = typeof o == "string" ? window == null ? void 0 : window.document.querySelector(o) : tt(o);
    s && (n === "class" ? s.classList.toggle(ya, r === ya) : s.setAttribute(n, r));
  });
  return se(e, (o) => {
    l("body", "class", o > 0 ? ya : "");
  }), { inc: t, dec: a };
}), qi = (e) => {
  const { inc: t, dec: a } = ji();
  se(
    e,
    (l, o) => {
      l ? t() : o && !l && a();
    },
    { immediate: !0 }
  );
}, Gi = ["id"], Wi = ["innerHTML"], Ui = ["innerHTML"], Xi = {
  inheritAttrs: !1
}, Ja = /* @__PURE__ */ H({
  ...Xi,
  __name: "BPopover",
  props: {
    modelValue: { default: !1 },
    container: { default: void 0 },
    target: { type: [Function, String, null], default: null },
    reference: { type: [Function, String, null], default: null },
    content: { default: void 0 },
    id: { default: void 0 },
    title: { default: void 0 },
    delay: { default: () => ({ show: 100, hide: 300 }) },
    click: { default: !1 },
    manual: { default: !1 },
    variant: { default: void 0 },
    offset: { default: null },
    customClass: { default: "" },
    placement: { default: "top" },
    strategy: { default: "absolute" },
    floatingMiddleware: { default: void 0 },
    noFlip: { default: !1 },
    noShift: { default: !1 },
    noFade: { default: !1 },
    noAutoClose: { default: !1 },
    hide: { default: !0 },
    realtime: { default: !1 },
    inline: { default: !1 },
    tooltip: { default: !1 },
    html: { default: !1 }
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = c(d(a, "modelValue")), o = z(l.value), n = z(l.value);
    De(() => {
      t("update:modelValue", o.value);
    }), se(l, () => {
      l.value !== o.value && (l.value ? ne() : ce(new Event("update:modelValue")));
    });
    const r = _e(d(a, "id"), "popover"), s = c(d(a, "click")), f = c(d(a, "manual")), m = c(d(a, "noShift")), y = c(d(a, "noFlip")), b = c(d(a, "noFade")), v = c(d(a, "noAutoClose")), B = c(d(a, "hide")), p = c(d(a, "realtime")), S = c(d(a, "inline")), h = c(d(a, "tooltip")), $ = c(d(a, "html")), k = z(!1), w = z(null), A = z(null), T = z(null), C = z(null), I = z(null), O = (te) => {
      if (typeof te == "string" || te instanceof HTMLElement)
        return te;
      if (typeof te == "function")
        return te().$el ? te().$el : te();
      if (typeof te < "u")
        return te.$el;
    }, F = (te) => {
      if (te) {
        if (typeof te == "string") {
          const ue = document.getElementById(te);
          return ue || void 0;
        }
        return te;
      }
    }, _ = u(
      () => a.title ? ht(a.title, bt) : ""
    ), P = u(
      () => a.content ? ht(a.content, bt) : ""
    ), L = u(() => a.placement.startsWith("auto")), N = u(() => {
      if (a.floatingMiddleware !== void 0)
        return a.floatingMiddleware;
      const te = a.offset ? a.offset : h.value ? 0 : 10, ue = [Po(te)];
      return y.value === !1 && !L.value && ue.push(Vo()), L.value && ue.push(
        Os({
          alignment: a.placement.split("-")[1] || void 0
        })
      ), m.value === !1 && ue.push(Oo()), B.value === !0 && ue.push(Es({ padding: 10 })), S.value === !0 && ue.push(Is()), ue.push(Ms({ element: T, padding: 10 })), ue;
    }), ee = u(
      () => L.value ? void 0 : a.placement
    ), { x: K, y: G, strategy: ae, middlewareData: de, placement: he, update: Be } = Ho(A, w, {
      placement: ee,
      middleware: N,
      strategy: a.strategy,
      whileElementsMounted: (...te) => Rs(...te, { animationFrame: p.value })
    }), oe = z({ position: "absolute" });
    se(de, () => {
      var te;
      if (B.value === !0 && ((te = de.value.hide) != null && te.referenceHidden ? k.value = !0 : k.value = !1), de.value.arrow) {
        const { x: ue, y: E } = de.value.arrow;
        oe.value = {
          position: "absolute",
          top: E ? `${E}px` : "",
          left: ue ? `${ue}px` : ""
        };
      }
    });
    const ve = u(() => {
      const te = h.value ? "tooltip" : "popover";
      return [
        te,
        `b-${te}`,
        {
          [`b-${te}-${a.variant}`]: a.variant !== void 0,
          show: o.value && !k.value,
          ["pe-none"]: !o.value,
          fade: !b.value,
          ["d-none"]: !o.value && b.value,
          [`${a.customClass}`]: a.customClass !== void 0,
          [`bs-${te}-${Ji(he.value)}`]: he.value !== void 0
        }
      ];
    }), { isOutside: R } = xl(w), { isOutside: U } = xl(C), pe = (te) => {
      const ue = te ?? new Event("click");
      o.value ? ce(ue) : ne();
    }, Q = (te, ue = {}) => new zt(te, {
      cancelable: !1,
      target: w.value || null,
      relatedTarget: null,
      trigger: null,
      ...ue,
      componentId: r.value
    }), ne = () => {
      const te = Q("show", { cancelable: !0 });
      if (t("show", te), te.defaultPrevented) {
        t("show-prevented");
        return;
      }
      n.value = !0, Te(() => {
        var ue;
        Be(), setTimeout(
          () => {
            Be(), o.value = !0, Te(() => {
              t("shown", Q("shown"));
            });
          },
          typeof a.delay == "number" ? a.delay : ((ue = a.delay) == null ? void 0 : ue.show) || 0
        );
      });
    }, ce = (te) => {
      var W;
      const ue = Q("hide", { cancelable: !0 });
      if (t("hide", ue), ue.defaultPrevented) {
        t("hide-prevented");
        return;
      }
      const E = typeof a.delay == "number" ? a.delay : ((W = a.delay) == null ? void 0 : W.hide) || 100;
      setTimeout(() => {
        var ge;
        (te == null ? void 0 : te.type) === "click" || R.value && U.value && !((ge = w.value) != null && ge.contains(document == null ? void 0 : document.activeElement)) ? (o.value = !1, Te(() => {
          setTimeout(
            () => {
              n.value = !1;
            },
            w.value ? $a(w.value) : 150
          ), t("hidden", Q("hidden"));
        })) : setTimeout(() => {
          ce(te);
        }, E);
      }, E);
    }, ye = () => {
      var te;
      if (a.target) {
        const ue = F(O(a.target));
        ue ? C.value = ue : console.warn("Target element not found", a.target);
      } else
        C.value = (te = I.value) == null ? void 0 : te.nextElementSibling;
      if (a.reference) {
        const ue = F(O(a.reference));
        ue ? A.value = ue : console.warn("Reference element not found", a.reference);
      } else
        A.value = C.value;
      !C.value || f.value || Ha && (s.value && C.value.addEventListener("click", pe), !s.value && C.value.addEventListener("pointerenter", ne), !s.value && C.value.addEventListener("pointerleave", ce), !s.value && C.value.addEventListener("focus", ne), !s.value && C.value.addEventListener("blur", ce));
    }, Ae = () => {
      C.value && (C.value.removeEventListener("click", pe), C.value.removeEventListener("pointerenter", ne), C.value.removeEventListener("pointerleave", ce), C.value.removeEventListener("focus", ne), C.value.removeEventListener("blur", ce));
    };
    return Uo(
      w,
      () => {
        o.value && s.value && !v.value && !f.value && ce(new Event("clickOutside"));
      },
      { ignore: [C] }
    ), se(
      () => [a.click, a.target, a.reference],
      () => {
        Ae(), ye();
      }
    ), Xe(ye), eo(Ae), (te, ue) => (g(), V(fe, null, [
      X("span", {
        ref_key: "placeholder",
        ref: I
      }, null, 512),
      x(te.$slots, "target", ke(Pe({ show: ne, hide: ce, toggle: pe, showState: o.value }))),
      $e(Xa, {
        tag: "Teleport",
        to: e.container,
        skip: !e.container
      }, {
        default: q(() => [
          n.value ? (g(), V("div", Z({
            key: 0,
            id: e.id
          }, te.$attrs, {
            ref_key: "element",
            ref: w,
            class: i(ve),
            role: "tooltip",
            tabindex: "-1",
            style: {
              position: i(ae),
              top: `${i(G) ?? 0}px`,
              left: `${i(K) ?? 0}px`,
              width: "max-content"
            }
          }), [
            X("div", {
              ref_key: "arrow",
              ref: T,
              class: j(`${i(h) ? "tooltip" : "popover"}-arrow`),
              style: je(oe.value),
              "data-popper-arrow": ""
            }, null, 6),
            e.title || te.$slots.title ? (g(), V(fe, { key: 0 }, [
              i($) ? (g(), V("div", {
                key: 1,
                class: j(i(h) ? "tooltip-inner" : "popover-header"),
                innerHTML: i(_)
              }, null, 10, Wi)) : (g(), V("div", {
                key: 0,
                class: j(i(h) ? "tooltip-inner" : "popover-header")
              }, [
                x(te.$slots, "title", {}, () => [
                  ie(Y(e.title), 1)
                ])
              ], 2))
            ], 64)) : J("", !0),
            i(h) && !te.$slots.title && !e.title || !i(h) ? (g(), V(fe, { key: 1 }, [
              i($) ? (g(), V("div", {
                key: 1,
                class: j(i(h) ? "tooltip-inner" : "popover-body"),
                innerHTML: i(P)
              }, null, 10, Ui)) : (g(), V("div", {
                key: 0,
                class: j(i(h) ? "tooltip-inner" : "popover-body")
              }, [
                x(te.$slots, "default", {}, () => [
                  ie(Y(e.content), 1)
                ])
              ], 2))
            ], 64)) : J("", !0)
          ], 16, Gi)) : J("", !0)
        ]),
        _: 3
      }, 8, ["to", "skip"])
    ], 64));
  }
}), Ki = ({
  top: e,
  end: t,
  start: a,
  alignCenter: l,
  alignEnd: o
}) => {
  const n = e ? "top" : a ? "left" : t ? "right" : "bottom", r = o ? "end" : l ? null : "start";
  return `${n}${r ? `-${r}` : ""}`;
}, Ji = (e) => {
  const [t] = e.split("-");
  switch (t) {
    case "left":
      return "start";
    case "right":
      return "end";
    default:
      return t;
  }
}, oa = (e, t) => {
  if ((typeof e > "u" || typeof e == "object" && !(e != null && e.title) && !(e != null && e.content)) && !t.getAttribute("title"))
    return console.warn(
      "Review tooltip directive usage. Some uses are not defining a title in root component or a value like `v-b-tooltip='{title: \"my title\"}'` nor `v-b-tooltip=\"'my title'\"` to define a title"
    ), {};
  if ((typeof e > "u" || typeof e == "object" && !(e != null && e.title) && !(e != null && e.content)) && (t.getAttribute("title") || t.getAttribute("data-original-title"))) {
    const a = t.getAttribute("title") ?? t.getAttribute("data-original-title");
    if (a && a !== "")
      return t.removeAttribute("title"), t.setAttribute("data-original-title", a), {
        content: ht(a, bt)
      };
  }
  return typeof e == "string" ? {
    content: ht(e, bt)
  } : {
    title: e != null && e.title ? ht(e == null ? void 0 : e.title, bt) : void 0,
    content: e != null && e.content ? ht(e == null ? void 0 : e.content, bt) : void 0
  };
}, na = (e, t) => ({
  target: () => t,
  modelValue: e.modifiers.show,
  inline: e.modifiers.inline,
  click: e.modifiers.click,
  realtime: e.modifiers.realtime,
  placement: e.modifiers.left ? "left" : e.modifiers.right ? "right" : e.modifiers.bottom ? "bottom" : e.modifiers.top ? "top" : void 0,
  html: !0,
  ...typeof e.value == "object" ? e.value : {},
  title: null,
  content: null
}), on = (e, t) => {
  var l;
  const a = document.createElement("span");
  t.modifiers.body ? document.body.appendChild(a) : t.modifiers.child ? e.appendChild(a) : (l = e.parentNode) == null || l.insertBefore(a, e.nextSibling), e.$__app = jn({ render: () => {
    var o;
    return re(Ja, { ...(o = e.$__state) == null ? void 0 : o.value });
  } }), e.$__app.mount(a), e.$__element = a;
}, nn = (e) => {
  var a;
  const t = e.$__element;
  (a = e.$__app) == null || a.unmount(), delete e.$__app, delete e.$__state, setTimeout(() => {
    t == null || t.remove();
  }, 0), delete e.$__element;
}, Yi = ["id"], Zi = /* @__PURE__ */ H({
  __name: "BAccordion",
  props: {
    flush: { default: !1 },
    free: { default: !1 },
    id: { default: void 0 },
    modelValue: null
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = xe(a, "modelValue", t, { passive: !0 }), o = _e(d(a, "id"), "accordion"), n = c(d(a, "flush")), r = c(d(a, "free")), s = u(() => ({
      "accordion-flush": n.value
    }));
    return Qe(So, {
      openItem: Se(l),
      free: r,
      setOpenItem: (f) => {
        l.value = f;
      }
    }), (f, m) => (g(), V("div", {
      id: i(o),
      class: j(["accordion", i(s)])
    }, [
      x(f.$slots, "default")
    ], 10, Yi));
  }
}), Qi = {
  inheritAttrs: !1
}, sn = /* @__PURE__ */ H({
  ...Qi,
  __name: "BCollapse",
  props: {
    id: { default: void 0 },
    modelValue: { default: !1 },
    tag: { default: "div" },
    toggle: { default: !1 },
    horizontal: { default: !1 },
    visible: { default: !1 },
    isNav: { default: !1 }
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "update:modelValue"],
  setup(e, { expose: t, emit: a }) {
    const l = e, o = (T, C = {}) => new zt(T, {
      cancelable: !1,
      target: v.value || null,
      relatedTarget: null,
      trigger: null,
      ...C,
      componentId: b.value
    }), n = xe(l, "modelValue", a, { passive: !0 }), r = c(n), s = c(d(l, "toggle")), f = c(d(l, "horizontal")), m = c(d(l, "isNav")), y = c(d(l, "visible")), b = _e(d(l, "id"), "collapse"), v = z(null), B = z(!1), p = z(r.value), S = u(() => ({
      show: p.value,
      "navbar-collapse": m.value,
      collapsing: B.value,
      closing: p.value && !r.value,
      "collapse-horizontal": f.value
    })), h = () => n.value = !1, $ = () => n.value = !0, k = () => n.value = !r.value, w = () => {
      p.value = !0, B.value = !0;
      const T = o("show", { cancelable: !0 });
      if (a("show", T), T.defaultPrevented) {
        a("show-prevented");
        return;
      }
      Te(() => {
        v.value !== null && (f.value ? v.value.style.width = `${v.value.scrollWidth}px` : v.value.style.height = `${v.value.scrollHeight}px`, setTimeout(() => {
          B.value = !1, a("shown", o("shown")), v.value !== null && (v.value.style.height = "", v.value.style.width = "");
        }, $a(v.value)));
      });
    }, A = () => {
      const T = o("hide", { cancelable: !0 });
      if (a("hide", T), T.defaultPrevented) {
        a("hide-prevented");
        return;
      }
      v.value !== null && (f.value ? v.value.style.width = `${v.value.scrollWidth}px` : v.value.style.height = `${v.value.scrollHeight}px`, v.value.offsetHeight, B.value = !0, Te(() => {
        v.value !== null && (v.value.style.height = "", v.value.style.width = "", setTimeout(() => {
          p.value = !1, B.value = !1, a("hidden", o("hidden"));
        }, $a(v.value)));
      }));
    };
    return se([n, p], () => {
      if (r.value === !0) {
        if (p.value)
          return;
        w();
        return;
      }
      A();
    }), Xe(() => {
      v.value !== null && !r.value && s.value && Te(() => {
        n.value = !0;
      });
    }), y.value && (n.value = !0, p.value = !0), se(y, (T) => {
      T ? $() : h();
    }), Ce(v, "bv-toggle", () => {
      n.value = !r.value;
    }), t({
      close: h,
      open: $,
      toggle: k,
      visible: Se(p),
      isNav: m
    }), Qe(ja, {
      id: b,
      close: h,
      open: $,
      toggle: k,
      visible: Se(p),
      isNav: m
    }), (T, C) => (g(), V(fe, null, [
      x(T.$slots, "header", ke(Pe({ visible: i(r), toggle: k, open: $, close: h, id: i(b) }))),
      (g(), D(le(e.tag), Z({
        id: i(b),
        ref_key: "element",
        ref: v,
        class: ["collapse", i(S)],
        "is-nav": i(m)
      }, T.$attrs), {
        default: q(() => [
          x(T.$slots, "default", ke(Pe({ visible: i(r), toggle: k, open: $, close: h })))
        ]),
        _: 3
      }, 16, ["id", "class", "is-nav"])),
      x(T.$slots, "footer", ke(Pe({ visible: i(r), toggle: k, open: $, close: h, id: i(b) })))
    ], 64));
  }
}), er = { class: "accordion-item" }, tr = ["aria-expanded", "aria-controls", "onClick"], ar = { class: "accordion-body" }, lr = {
  inheritAttrs: !1
}, or = /* @__PURE__ */ H({
  ...lr,
  __name: "BAccordionItem",
  props: {
    id: { default: void 0 },
    title: { default: void 0 },
    modelValue: { default: !1 },
    headerTag: { default: "h2" },
    tag: null,
    toggle: null,
    horizontal: null,
    visible: { default: !1 },
    isNav: null
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = {
      show: (s) => t("show", s),
      shown: (s) => t("shown", s),
      hide: (s) => t("hide", s),
      hidden: (s) => t("hidden", s),
      "hide-prevented": () => t("hide-prevented"),
      "show-prevented": () => t("show-prevented")
    }, o = xe(a, "modelValue", t, { passive: !0 }), n = Ie(So, null), r = _e(d(a, "id"), "accordion_item");
    return Xe(() => {
      o.value && !(n != null && n.free.value) && (n == null || n.setOpenItem(r.value)), !o.value && (n == null ? void 0 : n.openItem.value) === r.value && (o.value = !0);
    }), se(
      () => n == null ? void 0 : n.openItem.value,
      () => o.value = (n == null ? void 0 : n.openItem.value) === r.value && !(n != null && n.free.value)
    ), se(o, () => {
      o.value && !(n != null && n.free.value) && (n == null || n.setOpenItem(r.value));
    }), (s, f) => (g(), V("div", er, [
      $e(sn, Z({
        id: i(r),
        modelValue: i(o),
        "onUpdate:modelValue": f[0] || (f[0] = (m) => kt(o) ? o.value = m : null),
        class: "accordion-collapse"
      }, s.$attrs, {
        "aria-labelledby": `heading${i(r)}`,
        tag: e.tag,
        toggle: e.toggle,
        horizontal: e.horizontal,
        visible: e.visible,
        "is-nav": e.isNav
      }, qn(l)), {
        header: q(({ visible: m, toggle: y }) => [
          (g(), D(le(e.headerTag), {
            id: `heading${i(r)}`,
            class: "accordion-header"
          }, {
            default: q(() => [
              X("button", {
                class: j(["accordion-button", { collapsed: !m }]),
                type: "button",
                "aria-expanded": m ? "true" : "false",
                "aria-controls": i(r),
                onClick: y
              }, [
                x(s.$slots, "title", {}, () => [
                  ie(Y(e.title), 1)
                ])
              ], 10, tr)
            ]),
            _: 2
          }, 1032, ["id"]))
        ]),
        default: q(() => [
          X("div", ar, [
            x(s.$slots, "default")
          ])
        ]),
        _: 3
      }, 16, ["id", "modelValue", "aria-labelledby", "tag", "toggle", "horizontal", "visible", "is-nav"])
    ]));
  }
}), Tt = /* @__PURE__ */ H({
  __name: "BTransition",
  props: {
    appear: { default: !1 },
    mode: { default: void 0 },
    noFade: { default: !1 },
    transProps: { default: void 0 }
  },
  setup(e) {
    const t = e, a = c(d(t, "appear")), l = c(d(t, "noFade")), o = u(() => {
      const s = {
        name: "",
        enterActiveClass: "",
        enterToClass: "",
        leaveActiveClass: "",
        leaveToClass: "showing",
        enterFromClass: "showing",
        leaveFromClass: ""
      }, f = {
        ...s,
        enterActiveClass: "fade showing",
        leaveActiveClass: "fade showing"
      };
      return l.value ? s : f;
    }), n = u(() => ({ mode: t.mode, css: !0, ...o.value })), r = u(
      () => t.transProps !== void 0 ? {
        // Order matters here since the props.transProps would get overwritten if it came first
        // But the goal of props.transProps is to overwrite base properties
        ...n.value,
        ...t.transProps
      } : a.value ? {
        ...n.value,
        appear: !0,
        appearActiveClass: o.value.enterActiveClass,
        appearToClass: o.value.enterToClass
      } : n.value
    );
    return (s, f) => (g(), D(to, ke(Pe(i(r))), {
      default: q(() => [
        x(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), nr = ["type", "disabled", "aria-label"], _t = /* @__PURE__ */ H({
  __name: "BCloseButton",
  props: {
    ariaLabel: { default: "Close" },
    disabled: { default: !1 },
    white: { default: !1 },
    type: { default: "button" }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = e, l = c(d(a, "disabled")), o = c(d(a, "white")), n = u(() => ({
      "btn-close-white": o.value
    }));
    return (r, s) => (g(), V("button", {
      type: e.type,
      class: j(["btn-close", i(n)]),
      disabled: i(l),
      "aria-label": e.ariaLabel,
      onClick: s[0] || (s[0] = (f) => t("click", f))
    }, null, 10, nr));
  }
}), sr = {
  key: 0,
  class: "visually-hidden"
}, pa = /* @__PURE__ */ H({
  __name: "BSpinner",
  props: {
    label: { default: void 0 },
    role: { default: "status" },
    small: { default: !1 },
    tag: { default: "span" },
    type: { default: "border" },
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = Fe(), l = c(d(t, "small")), o = u(() => ({
      "spinner-border": t.type === "border",
      "spinner-border-sm": t.type === "border" && l.value,
      "spinner-grow": t.type === "grow",
      "spinner-grow-sm": t.type === "grow" && l.value,
      [`text-${t.variant}`]: t.variant !== void 0
    })), n = u(() => !Oe(a.label));
    return (r, s) => (g(), D(le(e.tag), {
      class: j(i(o)),
      role: e.label || i(n) ? e.role : null,
      "aria-hidden": e.label || i(n) ? null : !0
    }, {
      default: q(() => [
        e.label || i(n) ? (g(), V("span", sr, [
          x(r.$slots, "label", {}, () => [
            ie(Y(e.label), 1)
          ])
        ])) : J("", !0)
      ]),
      _: 3
    }, 8, ["class", "role", "aria-hidden"]));
  }
}), vt = {
  active: { type: [Boolean, String, void 0], default: void 0 },
  activeClass: { type: String, default: "router-link-active" },
  append: { type: [Boolean, String], default: !1 },
  disabled: { type: [Boolean, String], default: !1 },
  event: { type: [String, Array], default: "click" },
  href: { type: String },
  // noPrefetch: {type: [Boolean, String] as PropType<Booleanish>, default: false},
  // prefetch: {type: [Boolean, String] as PropType<Booleanish>, default: null},
  rel: { type: String, default: null },
  replace: { type: [Boolean, String], default: !1 },
  routerComponentName: { type: String, default: "router-link" },
  routerTag: { type: String, default: "a" },
  target: { type: String, default: "_self" },
  to: { type: [String, Object], default: null }
}, ir = H({
  // TODO this component will likely have an issue with inheritAttrs
  props: vt,
  emits: ["click"],
  setup(e, { emit: t, attrs: a }) {
    const l = c(d(e, "active")), o = c(d(e, "append")), n = c(d(e, "disabled")), r = c(d(e, "replace")), s = Ie(ja, null), f = () => {
      var h;
      (h = s == null ? void 0 : s.close) == null || h.call(s);
    }, m = ia(), y = z(null), b = u(() => {
      const h = e.routerComponentName.split("-").map((k) => k.charAt(0).toUpperCase() + k.slice(1)).join("");
      return !((m == null ? void 0 : m.appContext.app.component(h)) !== void 0) || n.value || !e.to ? "a" : e.routerComponentName;
    }), v = u(() => {
      const h = "#";
      if (e.href)
        return e.href;
      if (typeof e.to == "string")
        return e.to || h;
      const $ = e.to;
      if (Object.prototype.toString.call($) === "[object Object]" && ($.path || $.query || $.hash)) {
        const k = $.path || "", w = $.query ? `?${Object.keys($.query).map((T) => `${T}=${$.query[T]}`).join("=")}` : "", A = !$.hash || $.hash.charAt(0) === "#" ? $.hash || "" : `#${$.hash}`;
        return `${k}${w}${A}` || h;
      }
      return h;
    }), B = u(() => ({
      to: e.to,
      href: v.value,
      target: e.target,
      rel: e.target === "_blank" && e.rel === null ? "noopener" : e.rel || null,
      tabindex: n.value ? "-1" : typeof a.tabindex > "u" ? null : a.tabindex,
      "aria-disabled": n.value ? !0 : null
    }));
    return {
      computedLinkClasses: u(() => ({
        active: l.value,
        disabled: n.value
      })),
      tag: b,
      routerAttr: B,
      link: y,
      clicked: (h) => {
        var $;
        if (n.value) {
          h.preventDefault(), h.stopImmediatePropagation();
          return;
        }
        ($ = s == null ? void 0 : s.close) == null || $.call(s), t("click", h);
      },
      activeBoolean: l,
      appendBoolean: o,
      disabledBoolean: n,
      replaceBoolean: r,
      closeCollapse: f
    };
  }
}), ze = (e, t) => {
  const a = e.__vccOpts || e;
  for (const [l, o] of t)
    a[l] = o;
  return a;
};
function rr(e, t, a, l, o, n) {
  return e.tag === "router-link" ? (g(), D(le(e.tag), Z({ key: 0 }, e.routerAttr, { custom: "" }), {
    default: q(({ href: r, navigate: s, isActive: f }) => [
      (g(), D(le(e.routerTag), Z({
        ref: "link",
        href: r,
        class: [(e.activeBoolean ?? f) && e.activeClass]
      }, e.$attrs, {
        onClick: (m) => {
          s(m), e.closeCollapse();
        }
      }), {
        default: q(() => [
          x(e.$slots, "default")
        ]),
        _: 2
      }, 1040, ["href", "class", "onClick"]))
    ]),
    _: 3
  }, 16)) : (g(), D(le(e.tag), Z({
    key: 1,
    ref: "link",
    class: e.computedLinkClasses
  }, e.routerAttr, { onClick: e.clicked }), {
    default: q(() => [
      x(e.$slots, "default")
    ]),
    _: 3
  }, 16, ["class", "onClick"]));
}
const Ne = /* @__PURE__ */ ze(ir, [["render", rr]]), ur = H({
  components: { BLink: Ne, BSpinner: pa },
  props: {
    ...vt,
    active: { type: [Boolean, String], default: !1 },
    disabled: { type: [Boolean, String], default: !1 },
    href: { type: String, default: void 0 },
    pill: { type: [Boolean, String], default: !1 },
    pressed: { type: [Boolean, String], default: null },
    rel: { type: String, default: void 0 },
    size: { type: String, default: "md" },
    squared: { type: [Boolean, String], default: !1 },
    tag: { type: String, default: "button" },
    target: { type: String, default: "_self" },
    type: { type: String, default: "button" },
    variant: { type: String, default: "secondary" },
    loading: { type: [Boolean, String], default: !1 },
    loadingMode: { type: String, default: "inline" },
    block: { type: [Boolean, String], default: !1 }
  },
  emits: ["click", "update:pressed"],
  setup(e, { emit: t }) {
    const a = xe(e, "pressed", t), l = c(d(e, "active")), o = c(d(e, "block")), n = c(d(e, "disabled")), r = c(d(e, "pill")), s = c(d(e, "pressed")), f = c(d(e, "squared")), m = c(d(e, "loading")), y = u(() => typeof s.value == "boolean"), b = u(
      () => e.tag === "button" && e.href === void 0 && e.to === null
    ), v = u(() => Et(e)), B = u(() => e.to !== null), p = u(
      () => e.href !== void 0 ? !1 : !b.value
    ), S = u(() => [
      [`btn-${e.variant}`],
      [`btn-${e.size}`],
      {
        "btn-block": o.value,
        active: l.value || s.value,
        "rounded-pill": r.value,
        "rounded-0": f.value,
        disabled: n.value
      }
    ]), h = u(() => ({
      "aria-disabled": p.value ? n.value : null,
      "aria-pressed": y.value ? s.value : null,
      autocomplete: y.value ? "off" : null,
      disabled: b.value ? n.value : null,
      href: e.href,
      rel: v.value ? e.rel : null,
      role: p.value || v.value ? "button" : null,
      target: v.value ? e.target : null,
      type: b.value ? e.type : null,
      to: b.value ? null : e.to,
      append: v.value ? e.append : null,
      activeClass: B.value ? e.activeClass : null,
      event: B.value ? e.event : null,
      replace: B.value ? e.replace : null,
      routerComponentName: B.value ? e.routerComponentName : null,
      routerTag: B.value ? e.routerTag : null
    })), $ = u(
      () => B.value ? Ne : e.href ? "a" : e.tag
    );
    return {
      computedClasses: S,
      computedAttrs: h,
      computedTag: $,
      clicked: (w) => {
        if (n.value) {
          w.preventDefault(), w.stopPropagation();
          return;
        }
        t("click", w), y.value && (a.value = !s.value);
      },
      loadingBoolean: m
    };
  }
});
function dr(e, t, a, l, o, n) {
  const r = ao("b-spinner");
  return g(), D(le(e.computedTag), Z({
    class: ["btn", e.computedClasses]
  }, e.computedAttrs, { onClick: e.clicked }), {
    default: q(() => [
      e.loadingBoolean ? (g(), V("div", {
        key: 0,
        class: j(["btn-loading", { "mode-fill": e.loadingMode === "fill", "mode-inline": e.loadingMode === "inline" }])
      }, [
        x(e.$slots, "loading", {}, () => [
          $e(r, {
            class: "btn-spinner",
            small: e.size !== "lg"
          }, null, 8, ["small"])
        ])
      ], 2)) : J("", !0),
      X("div", {
        class: j(["btn-content", { "btn-loading-fill": e.loadingBoolean && e.loadingMode === "fill" }])
      }, [
        x(e.$slots, "default")
      ], 2)
    ]),
    _: 3
  }, 16, ["class", "onClick"]);
}
const wt = /* @__PURE__ */ ze(ur, [["render", dr]]), cr = ["onMouseenter"], fr = /* @__PURE__ */ H({
  __name: "BAlert",
  props: {
    noHoverPause: { default: !1 },
    dismissLabel: { default: "Close" },
    dismissible: { default: !1 },
    fade: { default: !1 },
    closeVariant: { default: "secondary" },
    modelValue: { type: [Boolean, Number], default: !1 },
    variant: { default: "info" },
    closeContent: { default: void 0 },
    immediate: { default: !0 },
    interval: { default: 1e3 },
    showOnPause: { default: !0 }
  },
  emits: ["closed", "close-countdown", "update:modelValue"],
  setup(e, { expose: t, emit: a }) {
    const l = e, o = Fe(), n = xe(l, "modelValue", a), r = c(d(l, "dismissible")), s = c(d(l, "fade")), f = c(d(l, "immediate")), m = c(d(l, "showOnPause")), y = c(d(l, "noHoverPause")), b = u(() => !Oe(o.close)), v = u(
      () => typeof n.value == "boolean" ? 0 : n.value
    ), B = u(() => [
      [`alert-${l.variant}`],
      {
        "alert-dismissible": r.value
      }
    ]), {
      isActive: p,
      pause: S,
      restart: h,
      resume: $,
      stop: k,
      isPaused: w,
      value: A
    } = Di(v, d(l, "interval"), {
      immediate: typeof n.value == "number" && f.value
    }), T = u(
      () => typeof n.value == "boolean" ? n.value : p.value || m.value && w.value
    ), C = u(() => ({
      variant: l.closeVariant,
      type: "button"
    }));
    De(() => a("close-countdown", A.value));
    const I = () => {
      typeof n.value == "boolean" ? n.value = !1 : (n.value = 0, k()), a("closed");
    }, O = () => {
      y.value || S();
    };
    return eo(k), t({ pause: S, resume: $, restart: h, stop: k }), (F, _) => (g(), D(Tt, {
      "no-fade": !i(s),
      "trans-props": { enterToClass: "show" }
    }, {
      default: q(() => [
        i(T) ? (g(), V("div", {
          key: 0,
          class: j(["alert", i(B)]),
          role: "alert",
          "aria-live": "polite",
          "aria-atomic": "true",
          onMouseenter: ct(O, ["stop"]),
          onMouseleave: _[0] || (_[0] = ct(
            //@ts-ignore
            (...P) => i($) && i($)(...P),
            ["stop"]
          ))
        }, [
          x(F.$slots, "default"),
          i(r) ? (g(), V(fe, { key: 0 }, [
            i(b) || e.closeContent ? (g(), D(wt, Z({ key: 0 }, i(C), { onClick: I }), {
              default: q(() => [
                x(F.$slots, "close", {}, () => [
                  ie(Y(e.closeContent), 1)
                ])
              ]),
              _: 3
            }, 16)) : (g(), D(_t, Z({
              key: 1,
              "aria-label": e.dismissLabel
            }, i(C), { onClick: I }), null, 16, ["aria-label"]))
          ], 64)) : J("", !0)
        ], 42, cr)) : J("", !0)
      ]),
      _: 3
    }, 8, ["no-fade"]));
  }
}), vr = {
  key: 0,
  class: "b-avatar-custom"
}, mr = {
  key: 1,
  class: "b-avatar-img"
}, pr = ["src", "alt"], xa = (e) => {
  const t = typeof e == "string" && io(e) ? At(e, 0) : e;
  return typeof t == "number" ? `${t}px` : t || null;
}, gr = /* @__PURE__ */ H({
  __name: "BAvatar",
  props: {
    alt: { default: "avatar" },
    ariaLabel: { default: void 0 },
    badge: { type: [Boolean, String], default: !1 },
    badgeLeft: { default: !1 },
    badgeOffset: { default: void 0 },
    badgeTop: { default: !1 },
    badgeVariant: { default: "primary" },
    button: { default: !1 },
    buttonType: { default: "button" },
    disabled: { default: !1 },
    icon: { default: void 0 },
    rounded: { type: [Boolean, String], default: "circle" },
    size: { default: void 0 },
    square: { default: !1 },
    src: { default: void 0 },
    text: { default: void 0 },
    textVariant: { default: void 0 },
    variant: { default: "secondary" }
  },
  emits: ["click", "img-error"],
  setup(e, { emit: t }) {
    const a = e, l = Fe(), o = Ie(ko, null), n = ["sm", null, "lg"], r = 0.4, s = r * 0.7, f = c(d(a, "badgeLeft")), m = c(d(a, "badgeTop")), y = c(d(a, "button")), b = c(d(a, "disabled")), v = c(d(a, "square")), B = u(() => !Oe(l.default)), p = u(() => !Oe(l.badge)), S = u(() => !!a.badge || a.badge === "" || p.value), h = u(
      () => (o == null ? void 0 : o.size.value) ?? xa(a.size)
    ), $ = u(() => (o == null ? void 0 : o.variant.value) ?? a.variant), k = u(() => (o == null ? void 0 : o.rounded.value) ?? a.rounded), w = u(() => ({
      type: y.value ? a.buttonType : void 0,
      "aria-label": a.ariaLabel || null,
      disabled: b.value || null
    })), A = u(() => [`bg-${a.badgeVariant}`]), T = u(() => a.badge === !0 ? "" : a.badge), C = u(() => [[`text-${ee(a.badgeVariant)}`]]), I = u(() => ({
      [`b-avatar-${a.size}`]: !!a.size && n.indexOf(xa(a.size)) !== -1,
      [`bg-${$.value}`]: !!$.value,
      badge: !y.value && $.value && B.value,
      rounded: k.value === "" || k.value === !0,
      ["rounded-circle"]: !v.value && k.value === "circle",
      ["rounded-0"]: v.value || k.value === "0",
      ["rounded-1"]: !v.value && k.value === "sm",
      ["rounded-3"]: !v.value && k.value === "lg",
      ["rounded-top"]: !v.value && k.value === "top",
      ["rounded-bottom"]: !v.value && k.value === "bottom",
      ["rounded-start"]: !v.value && k.value === "left",
      ["rounded-end"]: !v.value && k.value === "right",
      btn: y.value,
      [`btn-${$.value}`]: y.value ? !!$.value : !1
    })), O = u(() => [
      [`text-${a.textVariant || ee($.value)}`]
    ]), F = u(() => {
      const ae = a.badgeOffset || "0px";
      return {
        fontSize: (n.indexOf(h.value || null) === -1 ? `calc(${h.value} * ${s})` : "") || "",
        top: m.value ? ae : "",
        bottom: m.value ? "" : ae,
        left: f.value ? ae : "",
        right: f.value ? "" : ae
      };
    }), _ = u(() => {
      const ae = n.indexOf(h.value || null) === -1 ? `calc(${h.value} * ${r})` : null;
      return ae ? { fontSize: ae } : {};
    }), P = u(() => {
      var he;
      const ae = ((he = o == null ? void 0 : o.overlapScale) == null ? void 0 : he.value) || 0, de = h.value && ae ? `calc(${h.value} * -${ae})` : null;
      return de ? { marginLeft: de, marginRight: de } : {};
    }), L = u(() => y.value ? "button" : "span"), N = u(() => ({
      ...P.value,
      width: h.value ?? void 0,
      height: h.value ?? void 0
    })), ee = (ae) => ae === "light" || ae === "warning" ? "dark" : "light", K = (ae) => {
      !b.value && y.value && t("click", ae);
    }, G = (ae) => t("img-error", ae);
    return (ae, de) => (g(), D(le(i(L)), Z({
      class: ["b-avatar", i(I)],
      style: i(N)
    }, i(w), { onClick: K }), {
      default: q(() => [
        i(B) ? (g(), V("span", vr, [
          x(ae.$slots, "default")
        ])) : e.src ? (g(), V("span", mr, [
          X("img", {
            src: e.src,
            alt: e.alt,
            onError: G
          }, null, 40, pr)
        ])) : e.text ? (g(), V("span", {
          key: 2,
          class: j(["b-avatar-text", i(O)]),
          style: je(i(_))
        }, Y(e.text), 7)) : J("", !0),
        i(S) ? (g(), V("span", {
          key: 3,
          class: j(["b-avatar-badge", i(A)]),
          style: je(i(F))
        }, [
          i(p) ? x(ae.$slots, "badge", { key: 0 }) : (g(), V("span", {
            key: 1,
            class: j(i(C))
          }, Y(i(T)), 3))
        ], 6)) : J("", !0)
      ]),
      _: 3
    }, 16, ["class", "style"]));
  }
}), br = /* @__PURE__ */ H({
  __name: "BAvatarGroup",
  props: {
    overlap: { default: 0.3 },
    rounded: { type: [Boolean, String], default: !1 },
    size: { default: void 0 },
    square: { default: !1 },
    tag: { default: "div" },
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = c(d(t, "square")), l = u(() => xa(t.size)), o = u(
      () => Math.min(Math.max(r(t.overlap), 0), 1) / 2
    ), n = u(() => {
      const s = l.value ? `calc(${l.value} * ${o.value})` : null;
      return s ? { paddingLeft: s, paddingRight: s } : {};
    }), r = (s) => typeof s == "string" && io(s) ? At(s, 0) : s || 0;
    return Qe(ko, {
      overlapScale: o,
      size: Se(d(t, "size")),
      square: a,
      rounded: Se(d(t, "rounded")),
      variant: Se(d(t, "variant"))
    }), (s, f) => (g(), D(le(e.tag), {
      class: "b-avatar-group",
      role: "group"
    }, {
      default: q(() => [
        X("div", {
          class: "b-avatar-group-inner",
          style: je(i(n))
        }, [
          x(s.$slots, "default")
        ], 4)
      ]),
      _: 3
    }));
  }
}), Al = Rt(vt, ["event", "routerTag"]), hr = H({
  components: { BLink: Ne },
  props: {
    pill: { type: [Boolean, String], default: !1 },
    tag: { type: String, default: "span" },
    variant: { type: String, default: "secondary" },
    textIndicator: { type: [Boolean, String], default: !1 },
    dotIndicator: { type: [Boolean, String], default: !1 },
    ...Al
  },
  setup(e) {
    const t = c(d(e, "pill")), a = c(d(e, "textIndicator")), l = c(d(e, "dotIndicator")), o = c(d(e, "active")), n = c(d(e, "disabled")), r = u(() => Et(e)), s = u(
      () => r.value ? Ne : e.tag
    ), f = u(() => [
      [`bg-${e.variant}`],
      {
        active: o.value,
        disabled: n.value,
        "text-dark": ["warning", "info", "light"].includes(e.variant),
        "rounded-pill": t.value,
        "position-absolute top-0 start-100 translate-middle": a.value || l.value,
        "p-2 border border-light rounded-circle": l.value,
        "text-decoration-none": r.value
      }
    ]), m = u(
      () => r.value ? Da(e, Al) : {}
    );
    return {
      computedClasses: f,
      computedLinkProps: m,
      computedTag: s
    };
  }
});
function yr(e, t, a, l, o, n) {
  return g(), D(le(e.computedTag), Z({
    class: ["badge", e.computedClasses]
  }, e.computedLinkProps), {
    default: q(() => [
      x(e.$slots, "default")
    ]),
    _: 3
  }, 16, ["class"]);
}
const Br = /* @__PURE__ */ ze(hr, [["render", yr]]), Vl = Rt(vt, ["event", "routerTag"]), $r = H({
  components: { BLink: Ne },
  props: {
    ...Vl,
    active: { type: [Boolean, String], default: !1 },
    ariaCurrent: { type: String, default: "location" },
    disabled: { type: [Boolean, String], default: !1 },
    text: { type: String, default: void 0 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = c(d(e, "active")), l = c(d(e, "disabled")), o = u(() => ({
      active: a.value
    })), n = u(
      () => a.value ? "span" : Ne
    ), r = u(
      () => a.value ? e.ariaCurrent : void 0
    );
    return {
      computedLinkProps: u(
        () => n.value !== "span" ? Da(e, Vl) : {}
      ),
      computedClasses: o,
      computedTag: n,
      computedAriaCurrent: r,
      clicked: (m) => {
        if (l.value || a.value) {
          m.preventDefault(), m.stopImmediatePropagation();
          return;
        }
        l.value || t("click", m);
      }
    };
  }
});
function wr(e, t, a, l, o, n) {
  return g(), V("li", {
    class: j(["breadcrumb-item", e.computedClasses])
  }, [
    (g(), D(le(e.computedTag), Z({ "aria-current": e.computedAriaCurrent }, e.computedLinkProps, { onClick: e.clicked }), {
      default: q(() => [
        x(e.$slots, "default", {}, () => [
          ie(Y(e.text), 1)
        ])
      ]),
      _: 3
    }, 16, ["aria-current", "onClick"]))
  ], 2);
}
const rn = /* @__PURE__ */ ze($r, [["render", wr]]), kr = { "aria-label": "breadcrumb" }, Sr = { class: "breadcrumb" }, Cr = /* @__PURE__ */ H({
  __name: "BBreadcrumb",
  props: {
    items: { default: void 0 }
  },
  setup(e) {
    const t = e, a = Jo(), l = u(() => {
      const o = t.items || (a == null ? void 0 : a.items) || [];
      let n = !1;
      return o.map((s, f) => (typeof s == "string" && (s = { text: s }, f < o.length - 1 && (s.href = "#")), s.active && (n = !0), !s.active && !n && (s.active = f + 1 === o.length), s));
    });
    return (o, n) => (g(), V("nav", kr, [
      X("ol", Sr, [
        x(o.$slots, "prepend"),
        (g(!0), V(fe, null, we(i(l), (r, s) => (g(), D(rn, Z({ key: s }, r), {
          default: q(() => [
            ie(Y(r.text), 1)
          ]),
          _: 2
        }, 1040))), 128)),
        x(o.$slots, "default"),
        x(o.$slots, "append")
      ])
    ]));
  }
}), Tr = /* @__PURE__ */ H({
  __name: "BButtonGroup",
  props: {
    ariaLabel: { default: "Group" },
    size: { default: "md" },
    tag: { default: "div" },
    vertical: { default: !1 }
  },
  setup(e) {
    const t = e, a = c(d(t, "vertical")), l = u(() => ({
      "btn-group": !a.value,
      [`btn-group-${t.size}`]: t.size !== "md",
      "btn-group-vertical": a.value
    }));
    return (o, n) => (g(), D(le(e.tag), {
      class: j(i(l)),
      role: "group",
      "aria-label": e.ariaLabel
    }, {
      default: q(() => [
        x(o.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "aria-label"]));
  }
}), _r = ["role", "aria-label"], xr = /* @__PURE__ */ H({
  __name: "BButtonToolbar",
  props: {
    ariaLabel: { default: "Group" },
    justify: { default: !1 },
    role: { default: "toolbar" }
  },
  setup(e) {
    const a = c(d(e, "justify")), l = u(() => ({
      "justify-content-between": a.value
    }));
    return (o, n) => (g(), V("div", {
      class: j([i(l), "btn-toolbar"]),
      role: e.role,
      "aria-label": e.ariaLabel
    }, [
      x(o.$slots, "default")
    ], 10, _r));
  }
}), Ya = /* @__PURE__ */ H({
  __name: "BImg",
  props: {
    alt: { default: void 0 },
    blank: { default: !1 },
    blankColor: { default: "transparent" },
    block: { default: !1 },
    center: { default: !1 },
    fluid: { default: !1 },
    lazy: { default: !1 },
    fluidGrow: { default: !1 },
    height: { default: void 0 },
    start: { default: !1 },
    end: { default: !1 },
    rounded: { type: [Boolean, String], default: !1 },
    sizes: { default: void 0 },
    src: { default: void 0 },
    srcset: { default: void 0 },
    thumbnail: { default: !1 },
    width: { default: void 0 }
  },
  emits: ["load"],
  setup(e, { emit: t }) {
    const a = e, l = '<svg width="%{w}" height="%{h}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 %{w} %{h}" preserveAspectRatio="none"><rect width="100%" height="100%" style="fill:%{f};"></rect></svg>', o = c(d(a, "lazy")), n = c(d(a, "blank")), r = c(d(a, "block")), s = c(d(a, "center")), f = c(d(a, "fluid")), m = c(d(a, "fluidGrow")), y = c(d(a, "start")), b = c(d(a, "end")), v = c(d(a, "thumbnail")), B = u(
      () => typeof a.srcset == "string" ? a.srcset.split(",").filter((T) => T).join(",") : Array.isArray(a.srcset) ? a.srcset.filter((T) => T).join(",") : void 0
    ), p = u(
      () => typeof a.sizes == "string" ? a.sizes.split(",").filter((T) => T).join(",") : Array.isArray(a.sizes) ? a.sizes.filter((T) => T).join(",") : void 0
    ), S = u(() => {
      const T = (O) => O === void 0 ? void 0 : typeof O == "number" ? O : Number.parseInt(O, 10) || void 0, C = T(a.width), I = T(a.height);
      if (n.value) {
        if (C !== void 0 && I === void 0)
          return { height: C, width: C };
        if (C === void 0 && I !== void 0)
          return { height: I, width: I };
        if (C === void 0 && I === void 0)
          return { height: 1, width: 1 };
      }
      return {
        width: C,
        height: I
      };
    }), h = u(
      () => A(S.value.width, S.value.height, a.blankColor)
    ), $ = u(() => ({
      src: n.value ? h.value : a.src,
      alt: a.alt,
      width: S.value.width || void 0,
      height: S.value.height || void 0,
      srcset: n.value ? void 0 : B.value,
      sizes: n.value ? void 0 : p.value,
      loading: o.value ? "lazy" : "eager"
    })), k = u(
      () => y.value ? "float-start" : b.value ? "float-end" : s.value ? "mx-auto" : void 0
    ), w = u(() => ({
      "img-thumbnail": v.value,
      "img-fluid": f.value || m.value,
      "w-100": m.value,
      rounded: a.rounded === "" || a.rounded === !0,
      [`rounded-${a.rounded}`]: typeof a.rounded == "string" && a.rounded !== "",
      [`${k.value}`]: k.value !== void 0,
      "d-block": r.value || s.value
    })), A = (T, C, I) => `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(
      l.replace("%{w}", String(T)).replace("%{h}", String(C)).replace("%{f}", I)
    )}`;
    return (T, C) => (g(), V("img", Z({ class: i(w) }, i($), {
      onLoad: C[0] || (C[0] = (I) => t("load", I))
    }), null, 16));
  }
}), sa = /* @__PURE__ */ H({
  __name: "BCardImg",
  props: {
    alt: { default: void 0 },
    blank: { default: !1 },
    blankColor: { default: void 0 },
    bottom: { default: !1 },
    lazy: { default: !1 },
    height: { default: void 0 },
    start: { default: !1 },
    end: { default: !1 },
    sizes: { default: void 0 },
    src: { default: void 0 },
    srcset: { default: void 0 },
    top: { default: !1 },
    width: { default: void 0 }
  },
  emits: ["load"],
  setup(e, { emit: t }) {
    const a = e, l = c(d(a, "bottom")), o = c(d(a, "end")), n = c(d(a, "start")), r = c(d(a, "top")), s = u(
      () => r.value ? "card-img-top" : o.value ? "card-img-right" : l.value ? "card-img-bottom" : n.value ? "card-img-left" : "card-img"
    ), f = u(() => ({
      alt: a.alt,
      height: a.height,
      src: a.src,
      lazy: a.lazy,
      width: a.width,
      blank: a.blank,
      blankColor: a.blankColor,
      sizes: a.sizes,
      srcset: a.srcset
    }));
    return (m, y) => (g(), D(Ya, Z({ class: i(s) }, i(f), {
      onLoad: y[0] || (y[0] = (b) => t("load", b))
    }), null, 16, ["class"]));
  }
}), Ar = ["innerHTML"], un = /* @__PURE__ */ H({
  __name: "BCardHeadFoot",
  props: {
    text: { default: void 0 },
    bgVariant: { default: void 0 },
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    textVariant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = u(() => ({
      [`text-${t.textVariant}`]: t.textVariant !== void 0,
      [`bg-${t.bgVariant}`]: t.bgVariant !== void 0,
      [`border-${t.borderVariant}`]: t.borderVariant !== void 0
    }));
    return (l, o) => (g(), D(le(e.tag), {
      class: j(i(a))
    }, {
      default: q(() => [
        e.html ? (g(), V("div", {
          key: 0,
          innerHTML: e.html
        }, null, 8, Ar)) : x(l.$slots, "default", { key: 1 }, () => [
          ie(Y(e.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), dn = /* @__PURE__ */ H({
  __name: "BCardHeader",
  props: {
    text: { default: void 0 },
    bgVariant: { default: void 0 },
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    textVariant: { default: void 0 }
  },
  setup(e) {
    const t = e;
    return (a, l) => (g(), D(un, Z({ class: "card-header" }, t), {
      default: q(() => [
        x(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), cn = /* @__PURE__ */ H({
  __name: "BCardTitle",
  props: {
    text: { default: void 0 },
    tag: { default: "h4" }
  },
  setup(e) {
    return (t, a) => (g(), D(le(e.tag), { class: "card-title" }, {
      default: q(() => [
        x(t.$slots, "default", {}, () => [
          ie(Y(e.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), fn = /* @__PURE__ */ H({
  __name: "BCardSubtitle",
  props: {
    text: { default: void 0 },
    tag: { default: "h6" },
    textVariant: { default: "muted" }
  },
  setup(e) {
    const t = e, a = u(() => [`text-${t.textVariant}`]);
    return (l, o) => (g(), D(le(e.tag), {
      class: j(["card-subtitle mb-2", i(a)])
    }, {
      default: q(() => [
        x(l.$slots, "default", {}, () => [
          ie(Y(e.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), vn = /* @__PURE__ */ H({
  __name: "BCardBody",
  props: {
    bodyBgVariant: { default: void 0 },
    bodyTag: { default: "div" },
    bodyTextVariant: { default: void 0 },
    overlay: { default: !1 },
    subtitle: { default: void 0 },
    subtitleTag: { default: "h4" },
    subtitleTextVariant: { default: void 0 },
    title: { default: void 0 },
    titleTag: { default: "h4" },
    text: { default: void 0 }
  },
  setup(e) {
    const t = e, a = Fe(), l = c(d(t, "overlay")), o = u(() => !Oe(a.title)), n = u(() => !Oe(a.subtitle)), r = u(() => ({
      "card-img-overlay": l.value,
      [`text-${t.bodyTextVariant}`]: t.bodyTextVariant !== void 0,
      [`bg-${t.bodyBgVariant}`]: t.bodyBgVariant !== void 0
    }));
    return (s, f) => (g(), D(le(e.bodyTag), {
      class: j(["card-body", i(r)])
    }, {
      default: q(() => [
        e.title || i(o) ? (g(), D(cn, {
          key: 0,
          tag: e.titleTag
        }, {
          default: q(() => [
            x(s.$slots, "title", {}, () => [
              ie(Y(e.title), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag"])) : J("", !0),
        e.subtitle || i(n) ? (g(), D(fn, {
          key: 1,
          tag: e.subtitleTag,
          "text-variant": e.subtitleTextVariant
        }, {
          default: q(() => [
            x(s.$slots, "subtitle", {}, () => [
              ie(Y(e.subtitle), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag", "text-variant"])) : J("", !0),
        x(s.$slots, "default", {}, () => [
          ie(Y(e.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), mn = /* @__PURE__ */ H({
  __name: "BCardFooter",
  props: {
    text: { default: void 0 },
    bgVariant: { default: void 0 },
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    textVariant: { default: void 0 }
  },
  setup(e) {
    const t = e;
    return (a, l) => (g(), D(un, Z({ class: "card-footer" }, t), {
      default: q(() => [
        x(a.$slots, "default", {}, () => [
          ie(Y(e.text), 1)
        ])
      ]),
      _: 3
    }, 16));
  }
}), pn = /* @__PURE__ */ H({
  __name: "BCard",
  props: {
    align: { default: void 0 },
    bgVariant: { default: void 0 },
    bodyBgVariant: { default: void 0 },
    bodyClass: { default: void 0 },
    bodyTag: { default: "div" },
    bodyTextVariant: { default: void 0 },
    borderVariant: { default: void 0 },
    footer: { default: void 0 },
    footerBgVariant: { default: void 0 },
    footerBorderVariant: { default: void 0 },
    footerClass: { default: void 0 },
    footerHtml: { default: "" },
    footerTag: { default: "div" },
    footerTextVariant: { default: void 0 },
    header: { default: void 0 },
    headerBgVariant: { default: void 0 },
    headerBorderVariant: { default: void 0 },
    headerClass: { default: void 0 },
    headerHtml: { default: "" },
    headerTag: { default: "div" },
    headerTextVariant: { default: void 0 },
    imgAlt: { default: void 0 },
    imgBottom: { default: !1 },
    imgEnd: { default: !1 },
    imgHeight: { default: void 0 },
    imgSrc: { default: void 0 },
    imgStart: { default: !1 },
    imgTop: { default: !1 },
    imgWidth: { default: void 0 },
    noBody: { default: !1 },
    overlay: { default: !1 },
    subtitle: { default: void 0 },
    subtitleTag: { default: "h6" },
    subtitleTextVariant: { default: "muted" },
    tag: { default: "div" },
    textVariant: { default: void 0 },
    title: { default: void 0 },
    titleTag: { default: "h4" },
    bodyText: { default: "" }
  },
  setup(e) {
    const t = e, a = Fe(), l = c(d(t, "imgBottom")), o = c(d(t, "imgEnd")), n = c(d(t, "imgStart")), r = c(d(t, "noBody")), s = u(() => !Oe(a.header)), f = u(() => !Oe(a.footer)), m = u(() => ({
      [`text-${t.align}`]: t.align !== void 0,
      [`text-${t.textVariant}`]: t.textVariant !== void 0,
      [`bg-${t.bgVariant}`]: t.bgVariant !== void 0,
      [`border-${t.borderVariant}`]: t.borderVariant !== void 0,
      "flex-row": n.value,
      "flex-row-reverse": o.value
    })), y = u(() => ({
      bgVariant: t.headerBgVariant,
      borderVariant: t.headerBorderVariant,
      html: t.headerHtml,
      tag: t.headerTag,
      textVariant: t.headerTextVariant
    })), b = u(() => ({
      overlay: t.overlay,
      bodyBgVariant: t.bodyBgVariant,
      bodyTag: t.bodyTag,
      bodyTextVariant: t.bodyTextVariant,
      subtitle: t.subtitle,
      subtitleTag: t.subtitleTag,
      subtitleTextVariant: t.subtitleTextVariant,
      title: t.title,
      titleTag: t.titleTag
    })), v = u(() => ({
      bgVariant: t.footerBgVariant,
      borderVariant: t.footerBorderVariant,
      html: t.footerHtml,
      tag: t.footerTag,
      textVariant: t.footerTextVariant
    })), B = u(() => ({
      src: t.imgSrc,
      alt: t.imgAlt,
      height: t.imgHeight,
      width: t.imgWidth,
      bottom: t.imgBottom,
      end: t.imgEnd,
      start: t.imgStart,
      top: t.imgTop
    }));
    return (p, S) => (g(), D(le(e.tag), {
      class: j(["card", i(m)])
    }, {
      default: q(() => [
        i(l) ? J("", !0) : x(p.$slots, "img", { key: 0 }, () => [
          e.imgSrc ? (g(), D(sa, ke(Z({ key: 0 }, i(B))), null, 16)) : J("", !0)
        ]),
        e.header || i(s) || e.headerHtml ? (g(), D(dn, Z({ key: 1 }, i(y), { class: e.headerClass }), {
          default: q(() => [
            x(p.$slots, "header", {}, () => [
              ie(Y(e.header), 1)
            ])
          ]),
          _: 3
        }, 16, ["class"])) : J("", !0),
        i(r) ? x(p.$slots, "default", { key: 3 }, () => [
          ie(Y(e.bodyText), 1)
        ]) : (g(), D(vn, Z({ key: 2 }, i(b), { class: e.bodyClass }), {
          default: q(() => [
            x(p.$slots, "default", {}, () => [
              ie(Y(e.bodyText), 1)
            ])
          ]),
          _: 3
        }, 16, ["class"])),
        e.footer || i(f) || e.footerHtml ? (g(), D(mn, Z({ key: 4 }, i(v), { class: e.footerClass }), {
          default: q(() => [
            x(p.$slots, "footer", {}, () => [
              ie(Y(e.footer), 1)
            ])
          ]),
          _: 3
        }, 16, ["class"])) : J("", !0),
        i(l) ? x(p.$slots, "img", { key: 5 }, () => [
          e.imgSrc ? (g(), D(sa, ke(Z({ key: 0 }, i(B))), null, 16)) : J("", !0)
        ]) : J("", !0)
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Vr = /* @__PURE__ */ H({
  __name: "BCardGroup",
  props: {
    columns: { default: !1 },
    deck: { default: !1 },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, a = c(d(t, "columns")), l = c(d(t, "deck")), o = u(
      () => l.value ? "card-deck" : a.value ? "card-columns" : "card-group"
    ), n = u(() => [o.value]);
    return (r, s) => (g(), D(le(e.tag), {
      class: j(i(n))
    }, {
      default: q(() => [
        x(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Pr = /* @__PURE__ */ H({
  __name: "BCardText",
  props: {
    text: { default: void 0 },
    tag: { default: "p" }
  },
  setup(e) {
    return (t, a) => (g(), D(le(e.tag), { class: "card-text" }, {
      default: q(() => [
        x(t.$slots, "default", {}, () => [
          ie(Y(e.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), Or = ["id", "onMouseenter", "onMouseleave"], Er = {
  key: 0,
  class: "carousel-indicators"
}, Ir = ["aria-current", "aria-label", "onClick"], Fr = { class: "carousel-inner" }, Lr = /* @__PURE__ */ X("span", {
  class: "carousel-control-prev-icon",
  "aria-hidden": "true"
}, null, -1), Nr = { class: "visually-hidden" }, zr = /* @__PURE__ */ X("span", {
  class: "carousel-control-next-icon",
  "aria-hidden": "true"
}, null, -1), Rr = { class: "visually-hidden" }, Hr = /* @__PURE__ */ H({
  __name: "BCarousel",
  props: {
    ride: { type: [Boolean, String], default: !1 },
    noHoverPause: { default: !1 },
    rideReverse: { default: !1 },
    fade: { default: !1 },
    id: { default: void 0 },
    imgHeight: { default: void 0 },
    imgWidth: { default: void 0 },
    background: { default: void 0 },
    modelValue: { default: 0 },
    controls: { default: !1 },
    indicators: { default: !1 },
    interval: { default: 5e3 },
    noTouch: { default: !1 },
    noWrap: { default: !1 },
    controlsPrevText: { default: "Previous" },
    controlsNextText: { default: "Next" },
    indicatorsButtonLabel: { default: "Slide" },
    keyboard: { default: !0 },
    touchThreshold: { default: 50 }
  },
  emits: ["slid", "slide", "update:modelValue"],
  setup(e, { expose: t, emit: a }) {
    const l = e, o = Fe(), n = _e(d(l, "id"), "carousel"), r = xe(l, "modelValue", a, { passive: !0 }), s = c(d(l, "keyboard")), f = c(d(l, "rideReverse")), m = c(d(l, "noHoverPause")), y = c(d(l, "fade")), b = c(d(l, "controls")), v = c(d(l, "indicators")), B = c(d(l, "noTouch")), p = c(d(l, "noWrap")), S = yt(d(l, "touchThreshold"), {
      nanToZero: !0,
      method: "parseInt"
    }), h = z(!1), $ = z(!1), k = z(!0), w = z(null), A = z(null), T = u(
      () => Jn(l.ride) ? no(l.ride) : l.ride
    ), { pause: C, resume: I } = qo(
      () => {
        f.value ? N() : ee();
      },
      d(l, "interval"),
      { immediate: T.value === "carousel" }
    ), O = u(
      () => T.value === !0 && $.value === !0 || T.value === "carousel"
    ), F = u(() => ka(o.default, "BCarouselSlide")), _ = u(() => [
      "carousel",
      "slide",
      "pointer-event",
      { "carousel-fade": y.value }
    ]), P = (oe, ve) => {
      var R;
      return new so(oe, {
        componentId: n.value,
        cancelable: !1,
        target: A.value,
        direction: k.value ? "right" : "left",
        from: ve,
        to: r.value,
        relatedTarget: ((R = w.value) == null ? void 0 : R.children[r.value]) ?? null
      });
    }, L = (oe) => {
      if (h.value !== !0) {
        if (T.value === !0 && ($.value = !0), O.value === !0 && I(), k.value = !(oe < r.value), oe >= F.value.length) {
          if (p.value)
            return;
          r.value = 0;
          return;
        }
        if (oe < 0) {
          if (p.value)
            return;
          r.value = F.value.length - 1;
          return;
        }
        r.value = oe;
      }
    }, N = () => L(r.value - 1), ee = () => L(r.value + 1), K = (oe) => {
      s.value !== !1 && oe();
    }, G = () => {
      m.value || C();
    }, ae = () => {
      O.value && I();
    }, { lengthX: de } = Ri(A, {
      passive: !0,
      onSwipeStart() {
        B.value !== !0 && C();
      },
      onSwipeEnd() {
        if (B.value === !0)
          return;
        const oe = () => {
          O.value !== !1 && I();
        };
        if (de.value >= S.value) {
          ee(), oe();
          return;
        }
        de.value <= -S.value && (N(), oe());
      }
    }), he = (oe) => {
      a("slide", P("slide", oe)), h.value = !0;
    }, Be = (oe) => {
      a("slid", P("slid", oe)), h.value = !1;
    };
    return se(
      () => l.ride,
      () => $.value = !1
    ), t({ pause: C, resume: I, prev: N, next: ee }), Qe(ho, {
      background: Se(d(l, "background")),
      width: Se(d(l, "imgWidth")),
      height: Se(d(l, "imgHeight"))
    }), (oe, ve) => (g(), V("div", {
      id: i(n),
      ref_key: "target",
      ref: A,
      class: j(i(_)),
      onKeydown: [
        ve[0] || (ve[0] = Ot((R) => K(N), ["left"])),
        ve[1] || (ve[1] = Ot((R) => K(ee), ["right"]))
      ],
      onMouseenter: ct(G, ["stop"]),
      onMouseleave: ct(ae, ["stop"])
    }, [
      i(v) ? (g(), V("div", Er, [
        (g(!0), V(fe, null, we(i(F).length, (R, U) => (g(), V("button", {
          key: U,
          type: "button",
          "data-bs-target": "",
          class: j(U === i(r) ? "active" : ""),
          "aria-current": U === i(r) ? !0 : void 0,
          "aria-label": `${e.indicatorsButtonLabel} ${U}`,
          onClick: (pe) => L(U)
        }, null, 10, Ir))), 128))
      ])) : J("", !0),
      X("div", {
        ref_key: "relatedTarget",
        ref: w,
        class: "carousel-inner"
      }, [
        (g(!0), V(fe, null, we(i(F), (R, U) => (g(), D(to, {
          key: U,
          "enter-from-class": `carousel-item-next carousel-item-${k.value ? "end" : "start"}`,
          "leave-active-class": "active",
          "leave-to-class": `carousel-item-prev carousel-item-${k.value ? "start" : "end"}`,
          onBeforeLeave: he,
          onAfterLeave: Be
        }, {
          default: q(() => [
            it((g(), D(le(R), {
              class: j({ active: U === i(r) })
            }, null, 8, ["class"])), [
              [ra, U === i(r)]
            ])
          ]),
          _: 2
        }, 1032, ["enter-from-class", "leave-to-class"]))), 128))
      ], 512),
      X("div", Fr, [
        x(oe.$slots, "default")
      ]),
      i(b) ? (g(), V(fe, { key: 1 }, [
        X("button", {
          class: "carousel-control-prev",
          type: "button",
          onClick: N
        }, [
          Lr,
          X("span", Nr, Y(e.controlsPrevText), 1)
        ]),
        X("button", {
          class: "carousel-control-next",
          type: "button",
          onClick: ee
        }, [
          zr,
          X("span", Rr, Y(e.controlsNextText), 1)
        ])
      ], 64)) : J("", !0)
    ], 42, Or));
  }
}), Mr = ["innerHTML"], Dr = { key: 1 }, jr = ["innerHTML"], qr = { key: 1 }, Gr = /* @__PURE__ */ H({
  __name: "BCarouselSlide",
  props: {
    imgSrc: { default: void 0 },
    imgHeight: { default: void 0 },
    imgWidth: { default: void 0 },
    interval: { default: void 0 },
    background: { default: void 0 },
    caption: { default: void 0 },
    captionHtml: { default: void 0 },
    captionTag: { default: "h3" },
    contentTag: { default: "div" },
    contentVisibleUp: { default: void 0 },
    id: { default: void 0 },
    imgAlt: { default: void 0 },
    imgBlank: { default: !1 },
    imgBlankColor: { default: "transparent" },
    text: { default: void 0 },
    textHtml: { default: void 0 },
    textTag: { default: "p" }
  },
  setup(e) {
    const t = e, a = Fe(), l = Ie(ho, null), o = u(() => t.text || t.textHtml || !Oe(a.text)), n = u(() => t.caption || t.captionHtml || !Oe(a.caption)), r = u(() => o.value || n.value || !Oe(a.default)), s = u(() => ({
      background: `${t.background || (l == null ? void 0 : l.background.value) || "rgb(171, 171, 171)"} none repeat scroll 0% 0%`
    })), f = u(() => ({
      "d-none": t.contentVisibleUp !== void 0,
      [`d-${t.contentVisibleUp}-block`]: t.contentVisibleUp !== void 0
    }));
    return (m, y) => (g(), V("div", {
      class: "carousel-item",
      style: je(i(s))
    }, [
      x(m.$slots, "img", {}, () => {
        var b, v;
        return [
          $e(Ya, {
            class: "d-block w-100",
            alt: e.imgAlt,
            src: e.imgSrc,
            width: e.imgWidth || ((b = i(l)) == null ? void 0 : b.width.value),
            height: e.imgHeight || ((v = i(l)) == null ? void 0 : v.height.value),
            blank: e.imgBlank,
            "blank-color": e.imgBlankColor
          }, null, 8, ["alt", "src", "width", "height", "blank", "blank-color"])
        ];
      }),
      i(r) ? (g(), D(le(e.contentTag), {
        key: 0,
        class: j(["carousel-caption", i(f)])
      }, {
        default: q(() => [
          i(n) ? (g(), D(le(e.captionTag), { key: 0 }, {
            default: q(() => [
              x(m.$slots, "caption", {}, () => [
                e.captionHtml ? (g(), V("span", {
                  key: 0,
                  innerHTML: e.captionHtml
                }, null, 8, Mr)) : (g(), V("span", Dr, Y(e.caption), 1))
              ])
            ]),
            _: 3
          })) : J("", !0),
          i(o) ? (g(), D(le(e.textTag), { key: 1 }, {
            default: q(() => [
              x(m.$slots, "text", {}, () => [
                e.textHtml ? (g(), V("span", {
                  key: 0,
                  innerHTML: e.textHtml
                }, null, 8, jr)) : (g(), V("span", qr, Y(e.text), 1))
              ])
            ]),
            _: 3
          })) : J("", !0),
          x(m.$slots, "default")
        ]),
        _: 3
      }, 8, ["class"])) : J("", !0)
    ], 4));
  }
}), Pl = ca("", [], { type: [Boolean, String, Number], default: !1 }), Ol = ca("offset", [""], { type: [String, Number], default: null }), El = ca("order", [""], { type: [String, Number], default: null }), Wr = H({
  name: "BCol",
  props: {
    col: { type: [Boolean, String], default: !1 },
    // Generic flexbox .col (xs)
    cols: { type: [String, Number], default: null },
    // .col-[1-12]|auto (xs)
    ...Pl,
    offset: { type: [String, Number], default: null },
    ...Ol,
    order: { type: [String, Number], default: null },
    ...El,
    alignSelf: { type: String, default: null },
    tag: { type: String, default: "div" }
  },
  setup(e) {
    const t = [
      { content: Pl, propPrefix: "cols", classPrefix: "col" },
      { content: Ol, propPrefix: "offset" },
      { content: El, propPrefix: "order" }
    ], a = c(d(e, "col")), l = u(
      () => t.flatMap((n) => bo(e, n.content, n.propPrefix, n.classPrefix))
    );
    return {
      computedClasses: u(() => [
        l.value,
        {
          col: a.value || !l.value.some((n) => /^col-/.test(n)) && !e.cols,
          [`col-${e.cols}`]: !!e.cols,
          [`offset-${e.offset}`]: !!e.offset,
          [`order-${e.order}`]: !!e.order,
          [`align-self-${e.alignSelf}`]: !!e.alignSelf
        }
      ])
    };
  }
});
function Ur(e, t, a, l, o, n) {
  return g(), D(le(e.tag), {
    class: j(e.computedClasses)
  }, {
    default: q(() => [
      x(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
const xt = /* @__PURE__ */ ze(Wr, [["render", Ur]]), pt = {
  autoHide: !0,
  delay: 5e3,
  noCloseButton: !1,
  pos: "top-right",
  value: !0
};
class Il {
  constructor(t) {
    Ve(this, "vm");
    Ve(this, "containerPositions");
    Gn(t) ? this.vm = t : this.vm = dt(t), this.containerPositions = u(() => {
      const a = /* @__PURE__ */ new Set([]);
      return this.vm.toasts.map((l) => {
        l.options.pos && a.add(l.options.pos);
      }), a;
    });
  }
  toasts(t) {
    return t ? u(
      () => this.vm.toasts.filter((a) => {
        if (a.options.pos === t && a.options.value)
          return a;
      })
    ) : u(() => this.vm.toasts);
  }
  remove(...t) {
    this.vm.toasts = this.vm.toasts.filter((a) => {
      if (a.options.id && !t.includes(a.options.id))
        return a;
    });
  }
  isRoot() {
    return this.vm.root ?? !1;
  }
  show(t, a = pt) {
    const l = { id: lt(), ...pt, ...a }, o = {
      options: dt(l),
      content: t
    };
    return this.vm.toasts.push(o), o;
  }
  info(t, a = pt) {
    return this.show(t, { variant: "info", ...a });
  }
  danger(t, a = pt) {
    return this.show(t, { variant: "danger", ...a });
  }
  warning(t, a = pt) {
    return this.show(t, { variant: "warning", ...a });
  }
  success(t, a = pt) {
    return this.show(t, { variant: "success", ...a });
  }
  hide() {
  }
}
class Xr {
  constructor() {
    Ve(this, "vms");
    Ve(this, "rootInstance");
    Ve(this, "useToast", bn);
    this.vms = {};
  }
  getOrCreateViewModel(t) {
    if (!t) {
      if (this.rootInstance)
        return this.vms[this.rootInstance];
      const a = { root: !0, toasts: [], container: void 0, id: Symbol("toast") };
      return this.rootInstance = a.id, this.vms[a.id] = a, a;
    }
    if (t.root) {
      if (this.rootInstance)
        return this.vms[this.rootInstance];
      this.rootInstance = t.id;
    }
    return this.vms[t.id] = t, t;
  }
  getVM(t) {
    if (!t && this.rootInstance)
      return this.vms[this.rootInstance];
    if (t)
      return this.vms[t];
  }
}
const Aa = Symbol("toast"), gn = Symbol("toastFetch"), Kr = {
  container: void 0,
  toasts: [],
  root: !1
};
function Jr() {
  return Ie(gn);
}
function bn(e, t = Aa) {
  const a = Ie(Jr());
  if (!e)
    return new Il(a.getOrCreateViewModel());
  const l = { id: Symbol("toastInstance") }, o = { ...Kr, ...l, ...e }, n = a.getOrCreateViewModel(o);
  return new Il(n);
}
const Yr = {
  install: (e, t = {}) => {
    var a, l;
    e.provide(gn, ((a = t == null ? void 0 : t.BToast) == null ? void 0 : a.injectkey) ?? Aa), e.provide(((l = t == null ? void 0 : t.BToast) == null ? void 0 : l.injectkey) ?? Aa, new Xr());
  }
}, Zr = "toast-title", Fl = 1e3, hn = H({
  components: { BLink: Ne },
  props: {
    ...vt,
    delay: { type: Number, default: 5e3 },
    bodyClass: { type: String, default: void 0 },
    body: { type: [Object, String], default: void 0 },
    headerClass: { type: String, default: void 0 },
    headerTag: { type: String, default: "div" },
    animation: { type: [Boolean, String], default: !0 },
    id: { type: String, default: void 0 },
    // Switches role to 'status' and aria-live to 'polite'
    isStatus: { type: [Boolean, String], default: !1 },
    autoHide: { type: [Boolean, String], default: !0 },
    noCloseButton: { type: [Boolean, String], default: !1 },
    noFade: { type: [Boolean, String], default: !1 },
    noHoverPause: { type: [Boolean, String], default: !1 },
    solid: { type: [Boolean, String], default: !1 },
    // Render the toast in place, rather than in a portal-target
    static: { type: [Boolean, String], default: !1 },
    title: { type: String, default: void 0 },
    modelValue: { type: [Boolean, String], default: !1 },
    toastClass: { type: Array, default: void 0 },
    variant: { type: String, default: void 0 }
  },
  emits: ["destroyed", "update:modelValue"],
  setup(e, { emit: t, slots: a }) {
    c(d(e, "animation"));
    const l = c(d(e, "isStatus")), o = c(d(e, "autoHide")), n = c(d(e, "noCloseButton")), r = c(d(e, "noFade")), s = c(d(e, "noHoverPause"));
    c(d(e, "solid")), c(d(e, "static"));
    const f = c(d(e, "modelValue")), m = z(!1), y = z(!1), b = z(!1), v = u(() => ({
      [`b-toast-${e.variant}`]: e.variant !== void 0,
      show: b.value || m.value
    }));
    let B, p, S;
    const h = () => {
      typeof B > "u" || (clearTimeout(B), B = void 0);
    }, $ = u(
      () => (
        // Minimum supported duration is 1 second
        Math.max(ot(e.delay, 0), Fl)
      )
    ), k = () => {
      f.value && (p = S = 0, h(), y.value = !0, Mt(() => {
        b.value = !1;
      }));
    }, w = () => {
      h(), t("update:modelValue", !0), p = S = 0, y.value = !1, Te(() => {
        Mt(() => {
          b.value = !0;
        });
      });
    }, A = () => {
      if (!o.value || s.value || !B || S)
        return;
      const L = Date.now() - p;
      L > 0 && (h(), S = Math.max($.value - L, Fl));
    }, T = () => {
      (!o.value || s.value || !S) && (S = p = 0), C();
    };
    se(f, (L) => {
      L ? w() : k();
    });
    const C = () => {
      h(), o.value && (B = setTimeout(k, S || $.value), p = Date.now(), S = 0);
    }, I = () => {
      m.value = !0, t("update:modelValue", !0);
    }, O = () => {
      m.value = !1, C();
    }, F = () => {
      m.value = !0;
    }, _ = () => {
      m.value = !1, S = p = 0, t("update:modelValue", !1);
    };
    Wn(() => {
      h(), o.value && t("destroyed", e.id);
    }), Xe(() => {
      Te(() => {
        f.value && Mt(() => {
          w();
        });
      });
    });
    const P = () => {
      Te(() => {
        Mt(() => {
          k();
        });
      });
    };
    return () => {
      const L = () => {
        const N = [], ee = Me(Zr, { hide: k }, a);
        ee ? N.push(re(ee)) : e.title && N.push(re("strong", { class: "me-auto" }, e.title)), !n.value && N.length !== 0 && N.push(
          re(_t, {
            class: ["btn-close"],
            onClick: () => {
              k();
            }
          })
        );
        const K = [];
        if (N.length > 0 && K.push(
          re(
            e.headerTag,
            {
              class: "toast-header"
            },
            { default: () => N }
          )
        ), Me("default", { hide: k }, a) || e.body) {
          const G = re(
            Et(e) ? "b-link" : "div",
            {
              class: ["toast-body", e.bodyClass],
              onClick: Et(e) ? { click: P } : {}
            },
            Me("default", { hide: k }, a) || e.body
          );
          K.push(G);
        }
        return re(
          "div",
          {
            class: ["toast", e.toastClass, v.value],
            tabindex: "0"
          },
          K
        );
      };
      return re(
        "div",
        {
          class: ["b-toast"],
          id: e.id,
          role: y.value ? null : l.value ? "status" : "alert",
          "aria-live": y.value ? null : l.value ? "polite" : "assertive",
          "aria-atomic": y.value ? null : !0,
          onmouseenter: A,
          onmouseleave: T
        },
        [
          re(
            Tt,
            {
              noFade: r.value,
              onAfterEnter: O,
              onBeforeEnter: I,
              onAfterLeave: _,
              onBeforeLeave: F
            },
            () => [b.value ? L() : ""]
          )
        ]
      );
    };
  }
}), Va = /* @__PURE__ */ H({
  __name: "BToaster",
  props: {
    position: { default: "top-right" },
    instance: { default: void 0 }
  },
  setup(e) {
    const t = e, a = {
      "top-left": "top-0 start-0",
      "top-center": "top-0 start-50 translate-middle-x",
      "top-right": "top-0 end-0",
      "middle-left": "top-50 start-0 translate-middle-y",
      "middle-center": "top-50 start-50 translate-middle",
      "middle-right": "top-50 end-0 translate-middle-y",
      "bottom-left": "bottom-0 start-0",
      "bottom-center": "bottom-0 start-50 translate-middle-x",
      "bottom-right": "bottom-0 end-0"
    }, l = u(() => a[t.position]), o = (n) => {
      var r;
      (r = t.instance) == null || r.remove(n);
    };
    return (n, r) => {
      var s;
      return g(), V("div", {
        class: j([[i(l)], "b-toaster position-fixed p-3"]),
        style: { "z-index": "11" }
      }, [
        (g(!0), V(fe, null, we((s = e.instance) == null ? void 0 : s.toasts(e.position).value, (f) => (g(), D(hn, {
          id: f.options.id,
          key: f.options.id,
          modelValue: f.options.value,
          "onUpdate:modelValue": (m) => f.options.value = m,
          "auto-hide": f.options.autoHide,
          delay: f.options.delay,
          "no-close-button": f.options.noCloseButton,
          title: f.content.title,
          body: f.content.body,
          component: f.content.body,
          variant: f.options.variant,
          onDestroyed: o
        }, null, 8, ["id", "modelValue", "onUpdate:modelValue", "auto-hide", "delay", "no-close-button", "title", "body", "component", "variant"]))), 128))
      ], 2);
    };
  }
}), Qr = H({
  props: {
    gutterX: { type: String, default: null },
    gutterY: { type: String, default: null },
    fluid: { type: [Boolean, String], default: !1 },
    toast: { type: Object, default: void 0 },
    position: { type: String, default: void 0 }
  },
  setup(e, { slots: t, expose: a }) {
    const l = z();
    let o;
    const n = u(() => ({
      container: !e.fluid,
      ["container-fluid"]: typeof e.fluid == "boolean" && e.fluid,
      [`container-${e.fluid}`]: typeof e.fluid == "string",
      [`gx-${e.gutterX}`]: e.gutterX !== null,
      [`gy-${e.gutterY}`]: e.gutterY !== null
    }));
    return Xe(() => {
      e.toast;
    }), e.toast && (o = bn({ container: l, root: e.toast.root }), a({
      // ...toastInstance?.useMethods,
    })), () => {
      var s;
      const r = [];
      return o == null || o.containerPositions.value.forEach((f) => {
        r.push(re(Va, { key: f, instance: o, position: f }));
      }), re("div", { class: [n.value, e.position], ref: l }, [
        ...r,
        (s = t.default) == null ? void 0 : s.call(t)
      ]);
    };
  },
  methods: {}
}), eu = { class: "visually-hidden" }, tu = ["aria-labelledby", "role"], au = {
  inheritAttrs: !1
}, yn = /* @__PURE__ */ H({
  ...au,
  __name: "BDropdown",
  props: {
    id: { default: void 0 },
    menuClass: { default: void 0 },
    size: { default: "md" },
    splitClass: { default: void 0 },
    splitVariant: { default: void 0 },
    text: { default: void 0 },
    toggleClass: { default: void 0 },
    autoClose: { type: [Boolean, String], default: !0 },
    block: { default: !1 },
    dark: { default: !1 },
    disabled: { default: !1 },
    isNav: { default: !1 },
    dropup: { default: !1 },
    dropend: { default: !1 },
    dropstart: { default: !1 },
    center: { default: !1 },
    end: { default: !1 },
    noFlip: { default: !1 },
    noShift: { default: !1 },
    offset: { default: 0 },
    role: { default: "menu" },
    split: { default: !1 },
    splitButtonType: { default: "button" },
    splitHref: { default: void 0 },
    splitDisabled: { default: void 0 },
    noCaret: { default: !1 },
    toggleText: { default: "Toggle dropdown" },
    variant: { default: "secondary" },
    modelValue: { default: !1 },
    lazy: { default: !1 },
    strategy: { default: "absolute" },
    floatingMiddleware: { default: void 0 },
    splitTo: { default: void 0 }
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "click", "toggle", "update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = _e(d(a, "id"), "dropdown"), o = xe(a, "modelValue", t, { passive: !0 }), n = c(o), r = c(d(a, "block")), s = c(d(a, "dark")), f = c(d(a, "dropup")), m = c(d(a, "dropend")), y = c(d(a, "isNav")), b = c(d(a, "dropstart")), v = c(d(a, "center")), B = c(d(a, "end")), p = c(d(a, "split")), S = c(d(a, "noCaret")), h = c(d(a, "noFlip")), $ = c(d(a, "noShift")), k = c(d(a, "lazy")), w = c(d(a, "splitDisabled")), A = u(
      () => typeof a.offset == "string" || typeof a.offset == "number" ? a.offset : NaN
    ), T = yt(A, { method: "parseInt", nanToZero: !0 }), C = z(null), I = z(null), O = z(null), F = u(() => p.value ? I.value : O.value), _ = u(
      () => Ki({
        top: f.value,
        start: b.value,
        end: m.value,
        alignCenter: v.value,
        alignEnd: B.value
      })
    ), P = u(() => {
      if (a.floatingMiddleware !== void 0)
        return a.floatingMiddleware;
      const R = typeof a.offset == "string" || typeof a.offset == "number" ? T.value : a.offset, U = [Po(R)];
      return h.value === !1 && U.push(Vo()), $.value === !1 && U.push(Oo()), U;
    }), { x: L, y: N, strategy: ee, update: K } = Ho(F, C, {
      placement: _,
      middleware: P,
      strategy: a.strategy
    }), G = u(() => ({
      "d-grid": r.value,
      dropup: f.value,
      dropend: m.value,
      dropstart: b.value,
      "d-flex": r.value && p.value
    })), ae = u(() => [
      p.value ? a.splitClass : a.toggleClass,
      {
        "nav-link": y.value,
        "dropdown-toggle": !p.value,
        "dropdown-toggle-no-caret": S.value && !p.value,
        "w-100": p.value && r.value,
        show: p.value ? void 0 : n.value
      }
    ]), de = u(() => [
      a.menuClass,
      {
        "dropdown-menu-dark": s.value
      }
    ]), he = u(() => ({
      "aria-expanded": p.value ? void 0 : n.value,
      "aria-haspopup": p.value ? void 0 : "menu",
      href: p.value ? a.splitHref : void 0,
      to: p.value && a.splitTo ? a.splitTo : void 0
    })), Be = () => {
      t("toggle");
      const R = n.value, U = new Ze(R ? "hide" : "show");
      if (t(R ? "hide" : "show", U), U.defaultPrevented) {
        t(R ? "hide-prevented" : "show-prevented");
        return;
      }
      o.value = !R, t(R ? "hidden" : "shown");
    }, oe = (R) => {
      p.value ? t("click", R) : Be();
    };
    Uo(
      C,
      () => {
        n.value && (a.autoClose === !0 || a.autoClose === "outside") && (o.value = !n.value);
      },
      { ignore: [I, O] }
    );
    const ve = () => {
      n.value && (a.autoClose === !0 || a.autoClose === "inside") && (o.value = !n.value);
    };
    return se(n, K), Qe(_o, {
      id: l,
      open: () => {
        o.value = !0;
      },
      close: () => {
        o.value = !1;
      },
      toggle: () => {
        o.value = !n.value;
      },
      visible: n,
      isNav: y
    }), (R, U) => (g(), V(fe, null, [
      X("div", Z({
        class: [i(G), "btn-group"]
      }, R.$attrs), [
        $e(wt, Z({
          id: i(l),
          ref_key: "splitButton",
          ref: O,
          variant: e.splitVariant || e.variant,
          size: e.size,
          class: i(ae),
          disabled: i(w) || e.disabled,
          type: e.splitButtonType
        }, i(he), {
          onClick: oe,
          onKeydown: U[0] || (U[0] = Ot((pe) => o.value = !i(n), ["esc"]))
        }), {
          default: q(() => [
            x(R.$slots, "button-content", {}, () => [
              ie(Y(e.text), 1)
            ])
          ]),
          _: 3
        }, 16, ["id", "variant", "size", "class", "disabled", "type"]),
        i(p) ? (g(), D(wt, {
          key: 0,
          ref_key: "button",
          ref: I,
          variant: e.variant,
          size: e.size,
          disabled: e.disabled,
          class: j([[e.toggleClass, i(n) ? "show" : void 0], "dropdown-toggle-split dropdown-toggle"]),
          "aria-expanded": i(n),
          "aria-haspopup": "menu",
          onClick: Be
        }, {
          default: q(() => [
            X("span", eu, [
              x(R.$slots, "toggle-text", {}, () => [
                ie(Y(e.toggleText), 1)
              ])
            ])
          ]),
          _: 3
        }, 8, ["variant", "size", "disabled", "class", "aria-expanded"])) : J("", !0)
      ], 16),
      !i(k) || i(n) ? it((g(), V("ul", {
        key: 0,
        ref_key: "floating",
        ref: C,
        style: je({
          position: i(ee) === "absolute" ? void 0 : "fixed",
          top: `${i(N) ?? 0}px`,
          left: `${i(L) ?? 0}px`,
          width: "max-content"
        }),
        class: j(["dropdown-menu show", i(de)]),
        "aria-labelledby": i(l),
        role: e.role,
        onClick: ve
      }, [
        x(R.$slots, "default")
      ], 14, tu)), [
        [ra, i(k) || i(n)]
      ]) : J("", !0)
    ], 64));
  }
}), lu = { role: "presentation" }, ou = /* @__PURE__ */ H({
  __name: "BDropdownDivider",
  props: {
    tag: { default: "hr" }
  },
  setup(e) {
    return (t, a) => (g(), V("li", lu, [
      (g(), D(le(e.tag), {
        class: "dropdown-divider",
        role: "separator",
        "aria-orientation": "horizontal"
      }))
    ]));
  }
}), nu = {}, su = { role: "presentation" }, iu = { class: "px-4 py-3" };
function ru(e, t) {
  return g(), V("li", su, [
    X("form", iu, [
      x(e.$slots, "default")
    ])
  ]);
}
const uu = /* @__PURE__ */ ze(nu, [["render", ru]]), du = { role: "presentation" }, cu = ["id", "aria-describedby"], fu = {
  inheritAttrs: !1
}, vu = /* @__PURE__ */ H({
  ...fu,
  __name: "BDropdownGroup",
  props: {
    id: { default: void 0 },
    ariaDescribedby: { default: void 0 },
    header: { default: void 0 },
    headerClass: { default: void 0 },
    headerTag: { default: "header" },
    headerVariant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = u(
      () => t.id ? `${t.id}_group_dd_header` : void 0
    ), l = u(
      () => t.headerTag === "header" ? void 0 : "heading"
    ), o = u(() => [
      t.headerClass,
      {
        [`text-${t.headerVariant}`]: t.headerVariant !== void 0
      }
    ]);
    return (n, r) => (g(), V("li", du, [
      (g(), D(le(e.headerTag), {
        id: i(a),
        class: j(["dropdown-header", i(o)]),
        role: i(l)
      }, {
        default: q(() => [
          x(n.$slots, "header", {}, () => [
            ie(Y(e.header), 1)
          ])
        ]),
        _: 3
      }, 8, ["id", "class", "role"])),
      X("ul", Z({
        id: e.id,
        role: "group",
        class: "list-unstyled"
      }, n.$attrs, {
        "aria-describedby": e.ariaDescribedby || i(a)
      }), [
        x(n.$slots, "default")
      ], 16, cu)
    ]));
  }
}), mu = {}, pu = { class: "dropdown-header" };
function gu(e, t) {
  return g(), V("li", null, [
    X("h6", pu, [
      x(e.$slots, "default")
    ])
  ]);
}
const bu = /* @__PURE__ */ ze(mu, [["render", gu]]), hu = {
  inheritAttrs: !1
}, yu = /* @__PURE__ */ H({
  ...hu,
  __name: "BDropdownItem",
  props: {
    href: { default: void 0 },
    linkClass: { default: void 0 },
    active: { default: !1 },
    disabled: { default: !1 },
    rel: { default: void 0 },
    target: { default: "_self" },
    variant: { default: void 0 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = e, l = c(d(a, "active")), o = c(d(a, "disabled")), n = lo(), r = u(() => [
      a.linkClass,
      {
        active: l.value,
        disabled: o.value,
        [`text-${a.variant}`]: a.variant !== void 0
      }
    ]), s = u(
      () => a.href ? "a" : n.to ? Ne : "button"
    ), f = u(() => ({
      disabled: o.value,
      "aria-current": l.value ? !0 : null,
      href: s.value === "a" ? a.href : null,
      rel: a.rel,
      type: s.value === "button" ? "button" : null,
      target: a.target,
      ...n.to ? { activeClass: "active", ...n } : n
    })), m = Ie(ja, null), y = Ie(_o, null), b = (v) => {
      var B, p;
      t("click", v), (B = m == null ? void 0 : m.close) == null || B.call(m), (p = y == null ? void 0 : y.close) == null || p.call(y);
    };
    return (v, B) => (g(), V("li", {
      role: "presentation",
      class: j(v.$attrs.class)
    }, [
      (g(), D(le(i(s)), Z({
        class: ["dropdown-item", i(r)]
      }, i(f), { onClick: b }), {
        default: q(() => [
          x(v.$slots, "default")
        ]),
        _: 3
      }, 16, ["class"]))
    ], 2));
  }
}), Bu = ["disabled"], $u = {
  inheritAttrs: !1
}, wu = /* @__PURE__ */ H({
  ...$u,
  __name: "BDropdownItemButton",
  props: {
    buttonClass: { default: void 0 },
    active: { default: !1 },
    activeClass: { default: "active" },
    disabled: { default: !1 },
    variant: { default: void 0 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = e, l = c(d(a, "active")), o = c(d(a, "disabled")), n = u(() => [
      a.buttonClass,
      {
        [a.activeClass]: l.value,
        disabled: o.value,
        [`text-${a.variant}`]: a.variant !== void 0
      }
    ]), r = (s) => t("click", s);
    return (s, f) => (g(), V("li", {
      role: "presentation",
      class: j(s.$attrs.class)
    }, [
      X("button", {
        role: "menu",
        type: "button",
        class: j(["dropdown-item", i(n)]),
        disabled: i(o),
        onClick: r
      }, [
        x(s.$slots, "default")
      ], 10, Bu)
    ], 2));
  }
}), ku = { role: "presentation" }, Su = { class: "px-4 py-1 mb-0 text-muted" }, Cu = /* @__PURE__ */ H({
  __name: "BDropdownText",
  props: {
    text: { default: "" }
  },
  setup(e) {
    return (t, a) => (g(), V("li", ku, [
      X("p", Su, [
        x(t.$slots, "default", {}, () => [
          ie(Y(e.text), 1)
        ])
      ])
    ]));
  }
}), Tu = ["id", "novalidate", "onSubmit"], Bn = /* @__PURE__ */ H({
  __name: "BForm",
  props: {
    id: { default: void 0 },
    floating: { default: !1 },
    novalidate: { default: !1 },
    validated: { default: !1 }
  },
  emits: ["submit"],
  setup(e, { emit: t }) {
    const a = e, l = c(d(a, "floating")), o = c(d(a, "novalidate")), n = c(d(a, "validated")), r = u(() => ({
      "form-floating": l.value,
      "was-validated": n.value
    })), s = (f) => t("submit", f);
    return (f, m) => (g(), V("form", {
      id: e.id,
      novalidate: i(o),
      class: j(i(r)),
      onSubmit: ct(s, ["prevent"])
    }, [
      x(f.$slots, "default")
    ], 42, Tu));
  }
}), _u = { class: "form-floating" }, xu = ["for"], Au = /* @__PURE__ */ H({
  __name: "BFormFloatingLabel",
  props: {
    labelFor: { default: void 0 },
    label: { default: void 0 },
    text: { default: void 0 }
  },
  setup(e) {
    return (t, a) => (g(), V("div", _u, [
      x(t.$slots, "default", {}, () => [
        ie(Y(e.text), 1)
      ]),
      X("label", { for: e.labelFor }, [
        x(t.$slots, "label", {}, () => [
          ie(Y(e.label), 1)
        ])
      ], 8, xu)
    ]));
  }
}), Pa = /* @__PURE__ */ H({
  __name: "BFormInvalidFeedback",
  props: {
    ariaLive: { default: void 0 },
    forceShow: { default: !1 },
    id: { default: void 0 },
    text: { default: void 0 },
    role: { default: void 0 },
    state: { default: null },
    tag: { default: "div" },
    tooltip: { default: !1 }
  },
  setup(e) {
    const t = e, a = c(d(t, "forceShow")), l = c(d(t, "state")), o = c(d(t, "tooltip")), n = u(
      () => a.value === !0 || l.value === !1
    ), r = u(() => ({
      "d-block": n.value,
      "invalid-feedback": !o.value,
      "invalid-tooltip": o.value
    })), s = u(() => ({
      id: t.id,
      role: t.role,
      "aria-live": t.ariaLive,
      "aria-atomic": t.ariaLive ? !0 : void 0
    }));
    return (f, m) => (g(), D(le(e.tag), Z({ class: i(r) }, i(s)), {
      default: q(() => [
        x(f.$slots, "default", {}, () => [
          ie(Y(e.text), 1)
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Kt = /* @__PURE__ */ H({
  __name: "BFormRow",
  props: {
    tag: { default: "div" }
  },
  setup(e) {
    return (t, a) => (g(), D(le(e.tag), { class: "row d-flex flex-wrap" }, {
      default: q(() => [
        x(t.$slots, "default")
      ]),
      _: 3
    }));
  }
}), Oa = /* @__PURE__ */ H({
  __name: "BFormText",
  props: {
    id: { default: void 0 },
    inline: { default: !1 },
    tag: { default: "small" },
    text: { default: void 0 },
    textVariant: { default: "muted" }
  },
  setup(e) {
    const t = e, a = c(d(t, "inline")), l = u(() => [
      [`text-${t.textVariant}`],
      {
        "form-text": !a.value
      }
    ]);
    return (o, n) => (g(), D(le(e.tag), {
      id: e.id,
      class: j(i(l))
    }, {
      default: q(() => [
        x(o.$slots, "default", {}, () => [
          ie(Y(e.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), Ea = /* @__PURE__ */ H({
  __name: "BFormValidFeedback",
  props: {
    ariaLive: { default: void 0 },
    forceShow: { default: !1 },
    id: { default: void 0 },
    role: { default: void 0 },
    text: { default: void 0 },
    state: { default: null },
    tag: { default: "div" },
    tooltip: { default: !1 }
  },
  setup(e) {
    const t = e, a = c(d(t, "forceShow")), l = c(d(t, "state")), o = c(d(t, "tooltip")), n = u(
      () => a.value === !0 || l.value === !0
    ), r = u(() => ({
      "d-block": n.value,
      "valid-feedback": !o.value,
      "valid-tooltip": o.value
    })), s = u(() => t.ariaLive ? !0 : void 0);
    return (f, m) => (g(), D(le(e.tag), {
      id: e.id,
      role: e.role,
      "aria-live": e.ariaLive,
      "aria-atomic": i(s),
      class: j(i(r))
    }, {
      default: q(() => [
        x(f.$slots, "default", {}, () => [
          ie(Y(e.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "role", "aria-live", "aria-atomic", "class"]));
  }
}), Vu = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "aria-required", "value", "indeterminate"], Pu = ["for"], Ou = {
  inheritAttrs: !1
}, $n = /* @__PURE__ */ H({
  ...Ou,
  __name: "BFormCheckbox",
  props: {
    ariaLabel: { default: void 0 },
    ariaLabelledBy: { default: void 0 },
    form: { default: void 0 },
    indeterminate: { default: void 0 },
    name: { default: void 0 },
    id: { default: void 0 },
    autofocus: { default: !1 },
    plain: { default: !1 },
    button: { default: !1 },
    buttonGroup: { default: !1 },
    switch: { default: !1 },
    disabled: { default: !1 },
    buttonVariant: { default: void 0 },
    inline: { default: !1 },
    required: { default: void 0 },
    size: { default: void 0 },
    state: { default: null },
    uncheckedValue: { type: [Array, Set, Boolean, String, Object, Number, null], default: !1 },
    value: { type: [Array, Set, Boolean, String, Object, Number, null], default: !0 },
    modelValue: { type: [Array, Set, Boolean, String, Object, Number, null], default: void 0 }
  },
  emits: ["update:modelValue", "input", "change"],
  setup(e, { emit: t }) {
    const a = e, l = Fe(), o = xe(a, "modelValue", t, { passive: !0 }), n = _e(d(a, "id"), "form-check"), r = c(d(a, "indeterminate")), s = c(d(a, "autofocus")), f = c(d(a, "plain")), m = c(d(a, "button")), y = c(d(a, "buttonGroup")), b = c(d(a, "switch")), v = c(d(a, "disabled")), B = c(d(a, "inline")), p = c(d(a, "required")), S = c(d(a, "state")), h = Ie(Co, null), $ = z(null);
    qe($, {
      initialValue: s.value
    });
    const k = u(() => !Oe(l.default)), w = u({
      get: () => h !== null ? h.modelValue.value.map((_) => JSON.stringify(_)).includes(JSON.stringify(a.value)) : JSON.stringify(o.value) === JSON.stringify(a.value),
      set: (_) => {
        const P = _ ? a.value : a.uncheckedValue;
        t("input", P), o.value = P, Te(() => {
          t("change", P);
        });
      }
    });
    se(o, (_) => {
      if (h !== null) {
        if (_ === !1) {
          h.remove(a.value);
          return;
        }
        h.set(a.value);
      }
    });
    const A = u(
      () => !!(a.name ?? (h == null ? void 0 : h.name.value)) && (p.value || (h == null ? void 0 : h.required.value))
    ), T = u(
      () => y.value || ((h == null ? void 0 : h.buttons.value) ?? !1)
    ), C = u(() => ({
      plain: f.value || ((h == null ? void 0 : h.plain.value) ?? !1),
      button: m.value || ((h == null ? void 0 : h.buttons.value) ?? !1),
      inline: B.value || ((h == null ? void 0 : h.inline.value) ?? !1),
      switch: b.value || ((h == null ? void 0 : h.switch.value) ?? !1),
      state: S.value || (h == null ? void 0 : h.state.value),
      size: a.size !== void 0 ? a.size : (h == null ? void 0 : h.size.value) ?? "md",
      // This is where the true default is made
      buttonVariant: a.buttonVariant !== void 0 ? a.buttonVariant : (h == null ? void 0 : h.buttonVariant.value) ?? "secondary"
      // This is where the true default is made
    })), I = Yo(C), O = Zo(C), F = Qo(C);
    return (_, P) => (g(), D(Xa, {
      skip: i(T),
      class: j(i(I))
    }, {
      default: q(() => {
        var L, N, ee;
        return [
          it(X("input", Z({ id: i(n) }, _.$attrs, {
            ref_key: "input",
            ref: $,
            "onUpdate:modelValue": P[0] || (P[0] = (K) => kt(w) ? w.value = K : null),
            class: i(O),
            type: "checkbox",
            disabled: i(v) || ((L = i(h)) == null ? void 0 : L.disabled.value),
            required: i(A) ? !0 : void 0,
            name: e.name || ((N = i(h)) == null ? void 0 : N.name.value),
            form: e.form || ((ee = i(h)) == null ? void 0 : ee.form.value),
            "aria-label": e.ariaLabel,
            "aria-labelledby": e.ariaLabelledBy,
            "aria-required": i(A) ? !0 : void 0,
            value: e.value,
            indeterminate: i(r)
          }), null, 16, Vu), [
            [Un, i(w)]
          ]),
          i(k) || i(f) === !1 ? (g(), V("label", {
            key: 0,
            for: i(n),
            class: j(i(F))
          }, [
            x(_.$slots, "default")
          ], 10, Pu)) : J("", !0)
        ];
      }),
      _: 3
    }, 8, ["skip", "class"]));
  }
}), Eu = ["id"], Iu = ["innerHTML"], Fu = ["textContent"], Lu = /* @__PURE__ */ H({
  __name: "BFormCheckboxGroup",
  props: {
    id: { default: void 0 },
    form: { default: void 0 },
    modelValue: { default: () => [] },
    ariaInvalid: { default: void 0 },
    autofocus: { default: !1 },
    buttonVariant: { default: "secondary" },
    buttons: { default: !1 },
    disabled: { default: !1 },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    name: { default: void 0 },
    options: { default: () => [] },
    plain: { default: !1 },
    required: { default: !1 },
    size: { default: "md" },
    stacked: { default: !1 },
    state: { default: null },
    switches: { default: !1 },
    textField: { default: "text" },
    validated: { default: !1 },
    valueField: { default: "value" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { emit: t }) {
    const a = e, l = xe(a, "modelValue", t), o = _e(d(a, "id"), "checkbox"), n = _e(d(a, "name"), "checkbox"), r = c(d(a, "autofocus")), s = c(d(a, "buttons")), f = c(d(a, "disabled")), m = c(d(a, "plain")), y = c(d(a, "required")), b = c(d(a, "stacked")), v = c(d(a, "state")), B = c(d(a, "switches")), p = c(d(a, "validated")), S = z(null);
    qe(S, {
      initialValue: r.value
    }), Qe(Co, {
      set: (A) => {
        const T = [...l.value];
        T.push(A), t("input", T), l.value = T, Te(() => {
          t("change", T);
        });
      },
      remove: (A) => {
        const T = [...l.value];
        T.splice(l.value.indexOf(A), 1), t("input", T), l.value = T, Te(() => {
          t("change", T);
        });
      },
      modelValue: u(() => l.value),
      switch: B,
      buttonVariant: Se(d(a, "buttonVariant")),
      form: Se(d(a, "form")),
      name: n,
      state: v,
      plain: m,
      size: Se(d(a, "size")),
      inline: u(() => !b.value),
      required: y,
      buttons: s,
      disabled: f
    });
    const h = u(
      () => a.options.map(
        (A, T) => typeof A == "string" || typeof A == "number" ? {
          props: {
            value: A,
            disabled: f.value
          },
          text: A.toString(),
          html: void 0,
          self: Symbol(`checkboxGroupOptionItem${T}`)
        } : {
          props: {
            value: A[a.valueField],
            disabled: A[a.disabledField],
            ...A.props ? A.props : {}
          },
          text: A[a.textField],
          html: A[a.htmlField],
          self: Symbol(`checkboxGroupOptionItem${T}`)
        }
      )
    ), $ = u(() => ({
      required: y.value,
      ariaInvalid: a.ariaInvalid,
      state: v.value,
      validated: p.value,
      buttons: s.value,
      stacked: b.value,
      size: a.size
    })), k = en($), w = tn($);
    return (A, T) => (g(), V("div", Z(i(k), {
      id: i(o),
      ref_key: "element",
      ref: S,
      role: "group",
      class: [i(w), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      x(A.$slots, "first"),
      (g(!0), V(fe, null, we(i(h), (C) => (g(), D($n, Z({
        key: C.self
      }, C.props), {
        default: q(() => [
          C.html ? (g(), V("span", {
            key: 0,
            innerHTML: C.html
          }, null, 8, Iu)) : (g(), V("span", {
            key: 1,
            textContent: Y(C.text)
          }, null, 8, Fu))
        ]),
        _: 2
      }, 1040))), 128)),
      x(A.$slots, "default")
    ], 16, Eu));
  }
}), wn = ["input", "select", "textarea"], Nu = wn.map((e) => `${e}:not([disabled])`).join(), zu = [...wn, "a", "button", "label"], Ru = "label", Hu = "invalid-feedback", Mu = "valid-feedback", Du = "description", ju = "default", qu = H({
  components: { BCol: xt, BFormInvalidFeedback: Pa, BFormRow: Kt, BFormText: Oa, BFormValidFeedback: Ea },
  props: {
    contentCols: { type: [Boolean, String, Number], default: void 0 },
    contentColsLg: { type: [Boolean, String, Number], default: void 0 },
    contentColsMd: { type: [Boolean, String, Number], default: void 0 },
    contentColsSm: { type: [Boolean, String, Number], default: void 0 },
    contentColsXl: { type: [Boolean, String, Number], default: void 0 },
    description: { type: [String], default: void 0 },
    disabled: { type: [Boolean, String], default: !1 },
    feedbackAriaLive: { type: String, default: "assertive" },
    id: { type: String, default: void 0 },
    invalidFeedback: { type: String, default: void 0 },
    label: { type: String, default: void 0 },
    labelAlign: { type: [Boolean, String, Number], default: void 0 },
    labelAlignLg: { type: [Boolean, String, Number], default: void 0 },
    labelAlignMd: { type: [Boolean, String, Number], default: void 0 },
    labelAlignSm: { type: [Boolean, String, Number], default: void 0 },
    labelAlignXl: { type: [Boolean, String, Number], default: void 0 },
    labelClass: { type: [Array, Object, String], default: void 0 },
    labelCols: { type: [Boolean, String, Number], default: void 0 },
    labelColsLg: { type: [Boolean, String, Number], default: void 0 },
    labelColsMd: { type: [Boolean, String, Number], default: void 0 },
    labelColsSm: { type: [Boolean, String, Number], default: void 0 },
    labelColsXl: { type: [Boolean, String, Number], default: void 0 },
    labelFor: { type: String, default: void 0 },
    labelSize: { type: String, default: void 0 },
    labelSrOnly: { type: [Boolean, String], default: !1 },
    state: { type: [Boolean, String], default: null },
    tooltip: { type: [Boolean, String], default: !1 },
    validFeedback: { type: String, default: void 0 },
    validated: { type: [Boolean, String], default: !1 },
    floating: { type: [Boolean, String], default: !1 }
  },
  setup(e, { attrs: t }) {
    const a = c(d(e, "disabled")), l = c(d(e, "labelSrOnly")), o = c(d(e, "state")), n = c(d(e, "tooltip")), r = c(d(e, "validated")), s = c(d(e, "floating")), f = null, m = ["xs", "sm", "md", "lg", "xl"], y = (C, I) => m.reduce((O, F) => {
      const _ = sl(F === "xs" ? "" : F, `${I}Align`), P = C[_] || null;
      return P && (F === "xs" ? O.push(`text-${P}`) : O.push(`text-${F}-${P}`)), O;
    }, []), b = (C, I) => m.reduce((O, F) => {
      const _ = sl(F === "xs" ? "" : F, `${I}Cols`);
      let P = C[_];
      return P = P === "" ? !0 : P || !1, typeof P != "boolean" && P !== "auto" && (P = _s(P, 0), P = P > 0 ? P : !1), P && (F === "xs" ? O[typeof P == "boolean" ? "col" : "cols"] = P : O[F || (typeof P == "boolean" ? "col" : "cols")] = P), O;
    }, {}), v = z(), B = (C, I = null) => {
      if (Ha && e.labelFor) {
        const O = po(`#${rs(e.labelFor)}`, v);
        if (O) {
          const F = "aria-describedby", _ = (C || "").split(Ut), P = (I || "").split(Ut), L = (Ma(O, F) || "").split(Ut).filter((N) => !P.includes(N)).concat(_).filter((N, ee, K) => K.indexOf(N) === ee).filter((N) => N).join(" ").trim();
          L ? ks(O, F, L) : Ss(O, F);
        }
      }
    }, p = u(() => b(e, "content")), S = u(() => y(e, "label")), h = u(() => b(e, "label")), $ = u(
      () => (
        // Determine if the form group will be rendered horizontal
        // based on the existence of 'content-col' or 'label-col' props
        Object.keys(p.value).length > 0 || Object.keys(h.value).length > 0
      )
    ), k = u(
      () => (
        // If not a boolean, ensure that value is null
        typeof o.value == "boolean" ? o.value : null
      )
    ), w = u(() => {
      const C = k.value;
      return C === !0 ? "is-valid" : C === !1 ? "is-invalid" : null;
    }), A = u(
      () => fa(t.ariaInvalid, o.value)
    );
    return se(
      () => f,
      (C, I) => {
        C !== I && B(C, I);
      }
    ), Xe(() => {
      Te(() => {
        B(f);
      });
    }), {
      disabledBoolean: a,
      labelSrOnlyBoolean: l,
      stateBoolean: o,
      tooltipBoolean: n,
      validatedBoolean: r,
      floatingBoolean: s,
      ariaDescribedby: f,
      computedAriaInvalid: A,
      contentColProps: p,
      isHorizontal: $,
      labelAlignClasses: S,
      labelColProps: h,
      onLegendClick: (C) => {
        if (e.labelFor)
          return;
        const { target: I } = C, O = I ? I.tagName : "";
        if (zu.indexOf(O) !== -1)
          return;
        const F = $s(Nu, v).filter(Bs);
        F.length === 1 && hs(F[0]);
      },
      stateClass: w
    };
  },
  render() {
    const e = this.$props, t = this.$slots, a = _e(), l = !e.labelFor;
    let o = null;
    const n = Me(Ru, {}, t) || e.label, r = n ? lt("_BV_label_") : null;
    if (n || this.isHorizontal) {
      const A = l ? "legend" : "label";
      if (this.labelSrOnlyBoolean)
        n && (o = re(
          A,
          {
            class: "visually-hidden",
            id: r,
            for: e.labelFor || null
          },
          n
        )), this.isHorizontal ? o = re(xt, this.labelColProps, { default: () => o }) : o = re("div", {}, [o]);
      else {
        const T = {
          onClick: l ? this.onLegendClick : null,
          ...this.isHorizontal ? this.labelColProps : {},
          tag: this.isHorizontal ? A : null,
          id: r,
          for: e.labelFor || null,
          tabIndex: l ? "-1" : null,
          class: [
            this.isHorizontal ? "col-form-label" : "form-label",
            {
              "bv-no-focus-ring": l,
              "col-form-label": this.isHorizontal || l,
              "pt-0": !this.isHorizontal && l,
              "d-block": !this.isHorizontal && !l,
              [`col-form-label-${e.labelSize}`]: !!e.labelSize
            },
            this.labelAlignClasses,
            e.labelClass
          ]
        };
        this.isHorizontal ? o = re(xt, T, { default: () => n }) : o = re(A, T, n);
      }
    }
    let s = null;
    const f = Me(Hu, {}, t) || this.invalidFeedback, m = f ? lt("_BV_feedback_invalid_") : void 0;
    f && (s = re(
      Pa,
      {
        ariaLive: e.feedbackAriaLive,
        id: m,
        state: this.stateBoolean,
        tooltip: this.tooltipBoolean
      },
      { default: () => f }
    ));
    let y = null;
    const b = Me(Mu, {}, t) || this.validFeedback, v = b ? lt("_BV_feedback_valid_") : void 0;
    b && (y = re(
      Ea,
      {
        ariaLive: e.feedbackAriaLive,
        id: v,
        state: this.stateBoolean,
        tooltip: this.tooltipBoolean
      },
      { default: () => b }
      // validFeedbackContent
    ));
    let B = null;
    const p = Me(Du, {}, t) || this.description, S = p ? lt("_BV_description_") : void 0;
    p && (B = re(
      Oa,
      {
        id: S
      },
      { default: () => p }
    ));
    const h = this.ariaDescribedby = [
      S,
      this.stateBoolean === !1 ? m : null,
      this.stateBoolean === !0 ? v : null
    ].filter((A) => A).join(" ") || null, $ = [
      Me(ju, { ariaDescribedby: h, descriptionId: S, id: a, labelId: r }, t) || "",
      s,
      y,
      B
    ];
    !this.isHorizontal && this.floatingBoolean && $.push(o);
    let k = re(
      "div",
      {
        ref: "content",
        class: [
          {
            "form-floating": !this.isHorizontal && this.floatingBoolean
          }
        ]
      },
      $
    );
    this.isHorizontal && (k = re(xt, { ref: "content", ...this.contentColProps }, { default: () => $ }));
    const w = {
      class: [
        this.stateClass,
        {
          "was-validated": this.validatedBoolean
        }
      ],
      id: _e(d(e, "id")).value,
      disabled: l ? this.disabledBoolean : null,
      role: l ? null : "group",
      "aria-invalid": this.computedAriaInvalid,
      // Only apply `aria-labelledby` if we are a horizontal fieldset
      // as the legend is no longer a direct child of fieldset
      "aria-labelledby": l && this.isHorizontal ? r : null
    };
    return this.isHorizontal && !l ? re(Kt, w, { default: () => [o, k] }) : re(
      l ? "fieldset" : "div",
      w,
      this.isHorizontal && l ? [re(Kt, null, { default: () => [o, k] })] : this.isHorizontal || !this.floatingBoolean ? [o, k] : [k]
    );
  }
}), Ll = [
  "text",
  "number",
  "email",
  "password",
  "search",
  "url",
  "tel",
  "date",
  "time",
  "range",
  "color",
  "datetime",
  "datetime-local",
  "month",
  "week"
], Gu = H({
  props: {
    ...an,
    // debounce: {type: [String, Number], default: 0}, TODO: not implemented yet
    max: { type: [String, Number], default: void 0 },
    min: { type: [String, Number], default: void 0 },
    // noWheel: {type: [Boolean, String] as PropType<Booleanish>, default: false}, TODO: not implemented yet
    step: { type: [String, Number], default: void 0 },
    type: {
      type: String,
      default: "text",
      validator: (e) => Ll.includes(e)
    }
  },
  emits: ["update:modelValue", "change", "blur", "input"],
  setup(e, { emit: t }) {
    const { input: a, computedId: l, computedAriaInvalid: o, onInput: n, onChange: r, onBlur: s, focus: f, blur: m } = ln(e, t), y = z(!1), b = u(() => {
      const p = e.type === "range", S = e.type === "color";
      return {
        "form-control-highlighted": y.value,
        "form-range": p,
        "form-control": S || !e.plaintext && !p,
        "form-control-color": S,
        "form-control-plaintext": e.plaintext && !p && !S,
        [`form-control-${e.size}`]: !!e.size,
        "is-valid": e.state === !0,
        "is-invalid": e.state === !1
      };
    }), v = u(
      () => Ll.includes(e.type) ? e.type : "text"
    );
    return {
      computedClasses: b,
      localType: v,
      input: a,
      computedId: l,
      computedAriaInvalid: o,
      onInput: n,
      onChange: r,
      onBlur: s,
      focus: f,
      blur: m,
      highlight: () => {
        y.value !== !0 && (y.value = !0, setTimeout(() => {
          y.value = !1;
        }, 2e3));
      }
    };
  }
}), Wu = ["id", "name", "form", "type", "disabled", "placeholder", "required", "autocomplete", "readonly", "min", "max", "step", "list", "aria-required", "aria-invalid"];
function Uu(e, t, a, l, o, n) {
  return g(), V("input", {
    id: e.computedId,
    ref: "input",
    class: j(e.computedClasses),
    name: e.name || void 0,
    form: e.form || void 0,
    type: e.localType,
    disabled: e.disabled,
    placeholder: e.placeholder,
    required: e.required,
    autocomplete: e.autocomplete || void 0,
    readonly: e.readonly || e.plaintext,
    min: e.min,
    max: e.max,
    step: e.step,
    list: e.type !== "password" ? e.list : void 0,
    "aria-required": e.required ? !0 : void 0,
    "aria-invalid": e.computedAriaInvalid,
    onInput: t[0] || (t[0] = (r) => e.onInput(r)),
    onChange: t[1] || (t[1] = (r) => e.onChange(r)),
    onBlur: t[2] || (t[2] = (r) => e.onBlur(r))
  }, null, 42, Wu);
}
const Xu = /* @__PURE__ */ ze(Gu, [["render", Uu]]), Ku = ["id", "checked", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "value", "aria-required"], Ju = ["for"], Yu = {
  inheritAttrs: !1
}, kn = /* @__PURE__ */ H({
  ...Yu,
  __name: "BFormRadio",
  props: {
    ariaLabel: { default: void 0 },
    ariaLabelledby: { default: void 0 },
    form: { default: void 0 },
    id: { default: void 0 },
    name: { default: void 0 },
    size: { default: void 0 },
    autofocus: { default: !1 },
    modelValue: { type: [Boolean, String, Array, Object, Number, null], default: void 0 },
    plain: { default: !1 },
    button: { default: !1 },
    buttonGroup: { default: !1 },
    disabled: { default: !1 },
    buttonVariant: { default: void 0 },
    inline: { default: !1 },
    required: { default: !1 },
    state: { default: null },
    value: { type: [String, Boolean, Object, Number], default: !0 }
  },
  emits: ["input", "change", "update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = Fe(), o = xe(a, "modelValue", t, { passive: !0 }), n = _e(d(a, "id"), "form-check"), r = c(d(a, "autofocus")), s = c(d(a, "plain")), f = c(d(a, "button")), m = c(d(a, "buttonGroup")), y = c(d(a, "disabled")), b = c(d(a, "inline")), v = c(d(a, "required")), B = c(d(a, "state")), p = Ie(To, null), S = z(null);
    qe(S, {
      initialValue: r.value
    });
    const h = u(() => !Oe(l.default)), $ = u({
      get: () => p !== null ? JSON.stringify(p.modelValue.value) === JSON.stringify(a.value) : JSON.stringify(o.value) === JSON.stringify(a.value),
      set: (O) => {
        const F = O || O === 0 ? a.value : !1;
        t("input", F), o.value = F, Te(() => {
          t("change", F);
        });
      }
    });
    se(
      () => p == null ? void 0 : p.modelValue.value,
      (O) => {
        JSON.stringify(O) === JSON.stringify(a.value) !== !0 && ($.value = !1);
      }
    ), se(o, (O) => {
      p === null || O === !1 || p.set(a.value);
    });
    const k = u(
      () => !!(a.name ?? (p == null ? void 0 : p.name.value)) && (v.value || (p == null ? void 0 : p.required.value))
    ), w = u(
      () => m.value || ((p == null ? void 0 : p.buttons.value) ?? !1)
    ), A = u(() => ({
      plain: s.value || ((p == null ? void 0 : p.plain.value) ?? !1),
      button: f.value || ((p == null ? void 0 : p.buttons.value) ?? !1),
      inline: b.value || ((p == null ? void 0 : p.inline.value) ?? !1),
      state: B.value || (p == null ? void 0 : p.state.value),
      size: a.size !== void 0 ? a.size : (p == null ? void 0 : p.size.value) ?? "md",
      // This is where the true default is made
      buttonVariant: a.buttonVariant !== void 0 ? a.buttonVariant : (p == null ? void 0 : p.buttonVariant.value) ?? "secondary"
      // This is where the true default is made
    })), T = Yo(A), C = Zo(A), I = Qo(A);
    return (O, F) => (g(), D(Xa, {
      skip: i(w),
      class: j(i(T))
    }, {
      default: q(() => {
        var _, P, L;
        return [
          it(X("input", Z({ id: i(n) }, O.$attrs, {
            ref_key: "input",
            ref: S,
            "onUpdate:modelValue": F[0] || (F[0] = (N) => kt($) ? $.value = N : null),
            checked: i($),
            class: i(C),
            type: "radio",
            disabled: i(y) || ((_ = i(p)) == null ? void 0 : _.disabled.value),
            required: i(k) ? !0 : void 0,
            name: e.name || ((P = i(p)) == null ? void 0 : P.name.value),
            form: e.form || ((L = i(p)) == null ? void 0 : L.form.value),
            "aria-label": e.ariaLabel,
            "aria-labelledby": e.ariaLabelledby,
            value: e.value,
            "aria-required": i(k) ? !0 : void 0
          }), null, 16, Ku), [
            [Xn, i($)]
          ]),
          i(h) || i(s) === !1 ? (g(), V("label", {
            key: 0,
            for: i(n),
            class: j(i(I))
          }, [
            x(O.$slots, "default")
          ], 10, Ju)) : J("", !0)
        ];
      }),
      _: 3
    }, 8, ["skip", "class"]));
  }
}), Zu = ["id"], Qu = ["innerHTML"], ed = ["textContent"], td = /* @__PURE__ */ H({
  __name: "BFormRadioGroup",
  props: {
    size: { default: "md" },
    form: { default: void 0 },
    id: { default: void 0 },
    name: { default: void 0 },
    modelValue: { type: [String, Boolean, Array, Object, Number, null], default: null },
    ariaInvalid: { default: void 0 },
    autofocus: { default: !1 },
    buttonVariant: { default: "secondary" },
    buttons: { default: !1 },
    disabled: { default: !1 },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    options: { default: () => [] },
    plain: { default: !1 },
    required: { default: !1 },
    stacked: { default: !1 },
    state: { default: null },
    textField: { default: "text" },
    validated: { default: !1 },
    valueField: { default: "value" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { emit: t }) {
    const a = e, l = xe(a, "modelValue", t), o = _e(d(a, "id"), "radio"), n = _e(d(a, "name"), "checkbox"), r = c(d(a, "autofocus")), s = c(d(a, "buttons")), f = c(d(a, "disabled")), m = c(d(a, "plain")), y = c(d(a, "required")), b = c(d(a, "stacked")), v = c(d(a, "state")), B = c(d(a, "validated")), p = z(null);
    qe(p, {
      initialValue: r.value
    }), Qe(To, {
      set: (w) => {
        t("input", w), l.value = w, Te(() => {
          t("change", w);
        });
      },
      modelValue: u(() => l.value),
      buttonVariant: Se(d(a, "buttonVariant")),
      form: Se(d(a, "form")),
      name: n,
      buttons: s,
      state: v,
      plain: m,
      size: Se(d(a, "size")),
      inline: u(() => !b.value),
      required: y,
      disabled: f
    });
    const S = u(
      () => a.options.map(
        (w, A) => typeof w == "string" || typeof w == "number" ? {
          props: {
            value: w,
            disabled: f.value
          },
          text: w.toString(),
          html: void 0,
          self: Symbol(`radioGroupOptionItem${A}`)
        } : {
          props: {
            value: w[a.valueField],
            disabled: w[a.disabledField],
            ...w.props ? w.props : {}
          },
          text: w[a.textField],
          html: w[a.htmlField],
          self: Symbol(`radioGroupOptionItem${A}`)
        }
      )
    ), h = u(() => ({
      required: y.value,
      ariaInvalid: a.ariaInvalid,
      state: v.value,
      validated: B.value,
      buttons: s.value,
      stacked: b.value,
      size: a.size
    })), $ = en(h), k = tn(h);
    return (w, A) => (g(), V("div", Z(i($), {
      id: i(o),
      ref_key: "element",
      ref: p,
      role: "radiogroup",
      class: [i(k), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      x(w.$slots, "first"),
      (g(!0), V(fe, null, we(i(S), (T) => (g(), D(kn, Z({
        key: T.self
      }, T.props), {
        default: q(() => [
          T.html ? (g(), V("span", {
            key: 0,
            innerHTML: T.html
          }, null, 8, Qu)) : (g(), V("span", {
            key: 1,
            textContent: Y(T.text)
          }, null, 8, ed))
        ]),
        _: 2
      }, 1040))), 128)),
      x(w.$slots, "default")
    ], 16, Zu));
  }
}), ad = ["value", "disabled"], Za = /* @__PURE__ */ H({
  __name: "BFormSelectOption",
  props: {
    value: { default: void 0 },
    disabled: { default: !1 }
  },
  setup(e) {
    const a = c(d(e, "disabled"));
    return (l, o) => (g(), V("option", {
      value: e.value,
      disabled: i(a)
    }, [
      x(l.$slots, "default")
    ], 8, ad));
  }
}), ld = ["label"], Sn = /* @__PURE__ */ H({
  __name: "BFormSelectOptionGroup",
  props: {
    label: { default: void 0 },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    options: { default: () => [] },
    textField: { default: "text" },
    valueField: { default: "value" }
  },
  setup(e) {
    const t = e, a = u(
      () => Ka(t.options, "BFormSelectOptionGroup", t)
    );
    return (l, o) => (g(), V("optgroup", { label: e.label }, [
      x(l.$slots, "first"),
      (g(!0), V(fe, null, we(i(a), (n, r) => (g(), D(Za, Z({
        key: r,
        value: n.value,
        disabled: n.disabled
      }, l.$attrs, {
        innerHTML: n.html || n.text
      }), null, 16, ["value", "disabled", "innerHTML"]))), 128)),
      x(l.$slots, "default")
    ], 8, ld));
  }
}), od = ["id", "name", "form", "multiple", "size", "disabled", "required", "aria-required", "aria-invalid"], nd = /* @__PURE__ */ H({
  __name: "BFormSelect",
  props: {
    ariaInvalid: { default: void 0 },
    autofocus: { default: !1 },
    disabled: { default: !1 },
    disabledField: { default: "disabled" },
    form: { default: void 0 },
    htmlField: { default: "html" },
    id: { default: void 0 },
    labelField: { default: "label" },
    multiple: { default: !1 },
    name: { default: void 0 },
    options: { default: () => [] },
    optionsField: { default: "options" },
    plain: { default: !1 },
    required: { default: !1 },
    selectSize: { default: 0 },
    size: { default: "md" },
    state: { default: null },
    textField: { default: "text" },
    valueField: { default: "value" },
    modelValue: { default: "" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { emit: t }) {
    const a = e, l = xe(a, "modelValue", t), o = _e(d(a, "id"), "input"), n = c(d(a, "autofocus")), r = c(d(a, "disabled")), s = c(d(a, "multiple")), f = c(d(a, "plain")), m = c(d(a, "required")), y = c(d(a, "state")), b = z();
    qe(b, {
      initialValue: n.value
    });
    const v = u(() => ({
      "form-control": f.value,
      [`form-control-${a.size}`]: a.size !== "md" && f.value,
      "form-select": !f.value,
      [`form-select-${a.size}`]: a.size !== "md" && !f.value,
      "is-valid": y.value === !0,
      "is-invalid": y.value === !1
    })), B = u(() => {
      if (a.selectSize || f.value)
        return a.selectSize;
    }), p = u(
      () => fa(a.ariaInvalid, y.value)
    ), S = u(() => Ka(a.options, "BFormSelect", a)), h = u({
      get: () => l.value,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set: ($) => {
        t("change", $), l.value = $, t("input", $);
      }
    });
    return ($, k) => it((g(), V("select", Z({
      id: i(o),
      ref_key: "input",
      ref: b
    }, $.$attrs, {
      "onUpdate:modelValue": k[0] || (k[0] = (w) => kt(h) ? h.value = w : null),
      class: i(v),
      name: e.name,
      form: e.form || void 0,
      multiple: i(s) || void 0,
      size: i(B),
      disabled: i(r),
      required: i(m),
      "aria-required": i(m) ? !0 : void 0,
      "aria-invalid": i(p)
    }), [
      x($.$slots, "first"),
      (g(!0), V(fe, null, we(i(S), (w, A) => (g(), V(fe, { key: A }, [
        Array.isArray(w.options) ? (g(), D(Sn, {
          key: 0,
          label: w.label,
          options: w.options
        }, null, 8, ["label", "options"])) : (g(), D(Za, {
          key: 1,
          value: w.value,
          disabled: w.disabled,
          innerHTML: w.html || w.text
        }, null, 8, ["value", "disabled", "innerHTML"]))
      ], 64))), 128)),
      x($.$slots, "default")
    ], 16, od)), [
      [Kn, i(h)]
    ]);
  }
}), sd = ["id"], Cn = /* @__PURE__ */ H({
  __name: "BFormTag",
  props: {
    id: { default: void 0 },
    title: { default: void 0 },
    disabled: { default: !1 },
    noRemove: { default: !1 },
    pill: { default: !1 },
    removeLabel: { default: "Remove tag" },
    tag: { default: "span" },
    variant: { default: "secondary" }
  },
  emits: ["remove"],
  setup(e, { emit: t }) {
    const a = e, l = Fe(), o = _e(d(a, "id")), n = c(d(a, "disabled")), r = c(d(a, "noRemove")), s = c(d(a, "pill")), f = u(
      () => {
        var b;
        return ((((b = l.default) == null ? void 0 : b.call(l)[0].children) ?? "").toString() || a.title) ?? "";
      }
    ), m = u(() => `${o.value}taglabel__`), y = u(() => [
      `bg-${a.variant}`,
      {
        "text-dark": ["warning", "info", "light"].includes(a.variant),
        "rounded-pill": s.value,
        disabled: n.value
      }
    ]);
    return (b, v) => (g(), D(le(e.tag), {
      id: i(o),
      title: i(f),
      class: j(["badge b-form-tag d-inline-flex align-items-center mw-100", i(y)]),
      "aria-labelledby": i(m)
    }, {
      default: q(() => [
        X("span", {
          id: i(m),
          class: "b-form-tag-content flex-grow-1 text-truncate"
        }, [
          x(b.$slots, "default", {}, () => [
            ie(Y(i(f)), 1)
          ])
        ], 8, sd),
        !i(n) && !i(r) ? (g(), D(_t, {
          key: 0,
          "aria-keyshortcuts": "Delete",
          "aria-label": e.removeLabel,
          class: "b-form-tag-remove",
          white: !["warning", "info", "light"].includes(e.variant),
          "aria-describedby": i(m),
          "aria-controls": e.id,
          onClick: v[0] || (v[0] = (B) => t("remove", i(f)))
        }, null, 8, ["aria-label", "white", "aria-describedby", "aria-controls"])) : J("", !0)
      ]),
      _: 3
    }, 8, ["id", "title", "class", "aria-labelledby"]));
  }
}), id = ["id"], rd = ["id", "for", "aria-live"], ud = ["id", "aria-live"], dd = ["id"], cd = ["aria-controls"], fd = {
  role: "group",
  class: "d-flex"
}, vd = ["id", "disabled", "value", "type", "placeholder", "form", "required"], md = ["disabled"], pd = {
  "aria-live": "polite",
  "aria-atomic": "true"
}, gd = {
  key: 0,
  class: "d-block invalid-feedback"
}, bd = {
  key: 1,
  class: "form-text text-muted"
}, hd = {
  key: 2,
  class: "form-text text-muted"
}, yd = ["name", "value"], Bd = /* @__PURE__ */ H({
  __name: "BFormTags",
  props: {
    addButtonText: { default: "Add" },
    addButtonVariant: { default: "outline-secondary" },
    addOnChange: { default: !1 },
    autofocus: { default: !1 },
    disabled: { default: !1 },
    duplicateTagText: { default: "Duplicate tag(s)" },
    inputAttrs: { default: void 0 },
    inputClass: { default: void 0 },
    inputId: { default: void 0 },
    inputType: { default: "text" },
    invalidTagText: { default: "Invalid tag(s)" },
    form: { default: void 0 },
    limit: { default: void 0 },
    limitTagsText: { default: "Tag limit reached" },
    modelValue: { default: () => [] },
    name: { default: void 0 },
    noAddOnEnter: { default: !1 },
    noOuterFocus: { default: !1 },
    noTagRemove: { default: !1 },
    placeholder: { default: "Add tag..." },
    removeOnDelete: { default: !1 },
    required: { default: !1 },
    separator: { default: void 0 },
    state: { default: null },
    size: { default: "md" },
    tagClass: { default: void 0 },
    tagPills: { default: !1 },
    tagRemoveLabel: { default: void 0 },
    tagRemovedLabel: { default: "Tag removed" },
    tagValidator: { type: Function, default: () => !0 },
    tagVariant: { default: "secondary" }
  },
  emits: ["update:modelValue", "input", "tag-state", "focus", "focusin", "focusout", "blur"],
  setup(e, { emit: t }) {
    const a = e, l = xe(a, "modelValue", t), o = _e(), n = c(d(a, "addOnChange")), r = c(d(a, "autofocus")), s = c(d(a, "disabled")), f = c(d(a, "noAddOnEnter")), m = c(d(a, "noOuterFocus")), y = c(d(a, "noTagRemove")), b = c(d(a, "removeOnDelete")), v = c(d(a, "required")), B = c(d(a, "state")), p = c(d(a, "tagPills")), S = z(null), { focused: h } = qe(S, {
      initialValue: r.value
    }), $ = u(() => a.inputId || `${o.value}input__`), k = z(l.value), w = z(""), A = z(l.value.length > 0), T = z(!1), C = z(""), I = z([]), O = z([]), F = z([]), _ = u(() => ({
      [`form-control-${a.size}`]: a.size !== "md",
      disabled: s.value,
      focus: T.value,
      "is-invalid": B.value === !1,
      "is-valid": B.value === !0
    })), P = u(() => k.value.includes(w.value)), L = u(
      () => w.value === "" ? !1 : !a.tagValidator(w.value)
    ), N = u(() => k.value.length === a.limit), ee = u(() => !L.value && !P.value), K = u(() => ({
      addButtonText: a.addButtonText,
      addButtonVariant: a.addButtonVariant,
      addTag: U,
      disableAddButton: ee.value,
      disabled: s.value,
      duplicateTagText: a.duplicateTagText,
      duplicateTags: F.value,
      form: a.form,
      inputAttrs: {
        ...a.inputAttrs,
        disabled: s.value,
        form: a.form,
        id: $,
        value: w
      },
      inputHandlers: {
        input: he,
        keydown: oe,
        change: Be
      },
      inputId: $,
      inputType: a.inputType,
      invalidTagText: a.invalidTagText,
      invalidTags: O.value,
      isDuplicate: P.value,
      isInvalid: L.value,
      isLimitReached: N.value,
      limitTagsText: a.limitTagsText,
      limit: a.limit,
      noTagRemove: y.value,
      placeholder: a.placeholder,
      removeTag: pe,
      required: v.value,
      separator: a.separator,
      size: a.size,
      state: B.value,
      tagClass: a.tagClass,
      tagPills: p.value,
      tagRemoveLabel: a.tagRemoveLabel,
      tagVariant: a.tagVariant,
      tags: k.value
    }));
    se(l, (Q) => {
      k.value = Q;
    });
    const G = (Q) => {
      if (s.value) {
        Q.target.blur();
        return;
      }
      t("focusin", Q);
    }, ae = (Q) => {
      s.value || m.value || (T.value = !0, t("focus", Q));
    }, de = (Q) => {
      T.value = !1, t("blur", Q);
    }, he = (Q) => {
      var ce, ye;
      const ne = typeof Q == "string" ? Q : Q.target.value;
      if (A.value = !1, (ce = a.separator) != null && ce.includes(ne.charAt(0)) && ne.length > 0) {
        S.value && (S.value.value = "");
        return;
      }
      if (w.value = ne, (ye = a.separator) != null && ye.includes(ne.charAt(ne.length - 1))) {
        U(ne.slice(0, ne.length - 1));
        return;
      }
      I.value = a.tagValidator(ne) && !P.value ? [ne] : [], O.value = a.tagValidator(ne) ? [] : [ne], F.value = P.value ? [ne] : [], t("tag-state", I.value, O.value, F.value);
    }, Be = (Q) => {
      n.value && (he(Q), P.value || U(w.value));
    }, oe = (Q) => {
      if (Q.key === "Enter" && !f.value) {
        U(w.value);
        return;
      }
      (Q.key === "Backspace" || Q.key === "Delete") && b.value && w.value === "" && A.value && k.value.length > 0 ? pe(k.value[k.value.length - 1]) : A.value = !0;
    }, ve = u(() => {
      if (a.separator)
        return typeof a.separator == "string" ? a.separator : a.separator.join("");
    }), R = u(() => {
      if (ve.value)
        return new RegExp(`[${is(ve.value)}]+`);
    }), U = (Q) => {
      Q = (Q ?? w.value).trim();
      const ne = R.value ? Q.split(R.value).map((Ae) => Ae.trim()) : [Q], ce = [];
      for (const Ae of ne)
        if (!(Ae === "" || P.value || !a.tagValidator(Ae))) {
          if (a.limit && N.value)
            break;
          ce.push(Ae);
        }
      const ye = [...l.value, ...ce];
      w.value = "", A.value = !0, l.value = ye, t("input", ye), h.value = !0;
    }, pe = (Q) => {
      const ne = k.value.indexOf((Q == null ? void 0 : Q.toString()) ?? "");
      C.value = k.value.splice(ne, 1).toString(), l.value = k.value;
    };
    return (Q, ne) => (g(), V("div", {
      id: i(o),
      class: j(["b-form-tags form-control h-auto", i(_)]),
      role: "group",
      tabindex: "-1",
      onFocusin: G,
      onFocusout: ne[1] || (ne[1] = (ce) => t("focusout", ce))
    }, [
      X("output", {
        id: `${i(o)}selected_tags__`,
        class: "visually-hidden",
        for: i($),
        "aria-live": T.value ? "polite" : "off",
        "aria-atomic": "true",
        "aria-relevant": "additions text"
      }, Y(k.value.join(", ")), 9, rd),
      X("div", {
        id: `${i(o)}removed_tags__`,
        role: "status",
        "aria-live": T.value ? "assertive" : "off",
        "aria-atomic": "true",
        class: "visually-hidden"
      }, " (" + Y(e.tagRemovedLabel) + ") " + Y(C.value), 9, ud),
      x(Q.$slots, "default", ke(Pe(i(K))), () => [
        X("ul", {
          id: `${i(o)}tag_list__`,
          class: "b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center"
        }, [
          (g(!0), V(fe, null, we(k.value, (ce, ye) => x(Q.$slots, "tag", ke(Z({ key: ye }, { tag: ce, tagClass: e.tagClass, tagVariant: e.tagVariant, tagPills: i(p), removeTag: pe })), () => [
            (g(), D(Cn, {
              key: ce,
              class: j(e.tagClass),
              tag: "li",
              variant: e.tagVariant,
              pill: e.tagPills,
              onRemove: pe
            }, {
              default: q(() => [
                ie(Y(ce), 1)
              ]),
              _: 2
            }, 1032, ["class", "variant", "pill"]))
          ])), 128)),
          X("li", {
            role: "none",
            "aria-live": "off",
            class: "b-from-tags-field flex-grow-1",
            "aria-controls": `${i(o)}tag_list__`
          }, [
            X("div", fd, [
              X("input", Z({
                id: i($),
                ref_key: "input",
                ref: S,
                disabled: i(s),
                value: w.value,
                type: e.inputType,
                placeholder: e.placeholder,
                class: "b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0",
                style: { outline: "currentcolor none 0px", "min-width": "5rem" }
              }, e.inputAttrs, {
                form: e.form,
                required: i(v),
                onInput: he,
                onChange: Be,
                onKeydown: oe,
                onFocus: ae,
                onBlur: de
              }), null, 16, vd),
              i(ee) ? (g(), V("button", {
                key: 0,
                type: "button",
                class: j(["btn b-form-tags-button py-0", [
                  `btn-${e.addButtonVariant}`,
                  {
                    "disabled invisible": w.value.length === 0
                  },
                  e.inputClass
                ]]),
                style: { "font-size": "90%" },
                disabled: i(s) || w.value.length === 0 || i(N),
                onClick: ne[0] || (ne[0] = (ce) => U(w.value))
              }, [
                x(Q.$slots, "add-button-text", {}, () => [
                  ie(Y(e.addButtonText), 1)
                ])
              ], 10, md)) : J("", !0)
            ])
          ], 8, cd)
        ], 8, dd),
        X("div", pd, [
          i(L) ? (g(), V("div", gd, Y(e.invalidTagText) + ": " + Y(w.value), 1)) : J("", !0),
          i(P) ? (g(), V("small", bd, Y(e.duplicateTagText) + ": " + Y(w.value), 1)) : J("", !0),
          k.value.length === e.limit ? (g(), V("small", hd, "Tag limit reached")) : J("", !0)
        ])
      ]),
      e.name ? (g(!0), V(fe, { key: 0 }, we(k.value, (ce, ye) => (g(), V("input", {
        key: ye,
        type: "hidden",
        name: e.name,
        value: ce
      }, null, 8, yd))), 128)) : J("", !0)
    ], 42, id));
  }
}), $d = H({
  props: {
    ...an,
    noResize: { type: [Boolean, String], default: !1 },
    rows: { type: [String, Number], required: !1, default: 2 },
    wrap: { type: String, default: "soft" }
  },
  emits: ["update:modelValue", "change", "blur", "input"],
  setup(e, { emit: t }) {
    const { input: a, computedId: l, computedAriaInvalid: o, onInput: n, onChange: r, onBlur: s, focus: f, blur: m } = ln(e, t), y = c(d(e, "noResize")), b = u(() => ({
      "form-control": !e.plaintext,
      "form-control-plaintext": e.plaintext,
      [`form-control-${e.size}`]: !!e.size,
      "is-valid": e.state === !0,
      "is-invalid": e.state === !1
    })), v = u(() => ({
      resize: y.value ? "none" : void 0
    }));
    return {
      input: a,
      computedId: l,
      computedAriaInvalid: o,
      onInput: n,
      onChange: r,
      onBlur: s,
      focus: f,
      blur: m,
      computedClasses: b,
      computedStyles: v
    };
  }
}), wd = ["id", "name", "form", "disabled", "placeholder", "required", "autocomplete", "readonly", "aria-required", "aria-invalid", "rows", "wrap"];
function kd(e, t, a, l, o, n) {
  return g(), V("textarea", {
    id: e.computedId,
    ref: "input",
    class: j(e.computedClasses),
    name: e.name || void 0,
    form: e.form || void 0,
    disabled: e.disabled,
    placeholder: e.placeholder,
    required: e.required,
    autocomplete: e.autocomplete || void 0,
    readonly: e.readonly || e.plaintext,
    "aria-required": e.required ? !0 : void 0,
    "aria-invalid": e.computedAriaInvalid,
    rows: e.rows,
    style: je(e.computedStyles),
    wrap: e.wrap || void 0,
    onInput: t[0] || (t[0] = (r) => e.onInput(r)),
    onChange: t[1] || (t[1] = (r) => e.onChange(r)),
    onBlur: t[2] || (t[2] = (r) => e.onBlur(r))
  }, null, 46, wd);
}
const Sd = /* @__PURE__ */ ze($d, [["render", kd]]), Cd = {
  key: 0,
  class: "input-group-text"
}, Td = ["innerHTML"], _d = { key: 1 }, xd = {
  key: 0,
  class: "input-group-text"
}, Ad = ["innerHTML"], Vd = { key: 1 }, Pd = /* @__PURE__ */ H({
  __name: "BInputGroup",
  props: {
    append: { default: void 0 },
    appendHtml: { default: void 0 },
    id: { default: void 0 },
    prepend: { default: void 0 },
    prependHtml: { default: void 0 },
    size: { default: "md" },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, a = u(() => ({
      [`input-group-${t.size}`]: t.size !== "md"
    })), l = u(() => !!t.append || !!t.appendHtml), o = u(() => !!t.prepend || !!t.prependHtml);
    return (n, r) => (g(), D(le(e.tag), {
      id: e.id,
      class: j(["input-group", i(a)]),
      role: "group"
    }, {
      default: q(() => [
        x(n.$slots, "prepend", {}, () => [
          i(o) ? (g(), V("span", Cd, [
            e.prependHtml ? (g(), V("span", {
              key: 0,
              innerHTML: e.prependHtml
            }, null, 8, Td)) : (g(), V("span", _d, Y(e.prepend), 1))
          ])) : J("", !0)
        ]),
        x(n.$slots, "default"),
        x(n.$slots, "append", {}, () => [
          i(l) ? (g(), V("span", xd, [
            e.appendHtml ? (g(), V("span", {
              key: 0,
              innerHTML: e.appendHtml
            }, null, 8, Ad)) : (g(), V("span", Vd, Y(e.append), 1))
          ])) : J("", !0)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), Tn = /* @__PURE__ */ H({
  __name: "BInputGroupText",
  props: {
    tag: { default: "div" },
    text: { default: void 0 }
  },
  setup(e) {
    return (t, a) => (g(), D(le(e.tag), { class: "input-group-text" }, {
      default: q(() => [
        x(t.$slots, "default", {}, () => [
          ie(Y(e.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), Qa = /* @__PURE__ */ H({
  __name: "BInputGroupAddon",
  props: {
    isText: { default: !1 }
  },
  setup(e) {
    const a = c(d(e, "isText"));
    return (l, o) => i(a) ? (g(), D(Tn, { key: 0 }, {
      default: q(() => [
        x(l.$slots, "default")
      ]),
      _: 3
    })) : x(l.$slots, "default", { key: 1 });
  }
}), Od = /* @__PURE__ */ H({
  __name: "BInputGroupAppend",
  props: {
    isText: { default: !1 }
  },
  setup(e) {
    return (t, a) => (g(), D(Qa, { "is-text": e.isText }, {
      default: q(() => [
        x(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["is-text"]));
  }
}), Ed = /* @__PURE__ */ H({
  __name: "BInputGroupPrepend",
  props: {
    isText: { default: !1 }
  },
  setup(e) {
    return (t, a) => (g(), D(Qa, { "is-text": e.isText }, {
      default: q(() => [
        x(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["is-text"]));
  }
}), Id = /* @__PURE__ */ H({
  __name: "BListGroup",
  props: {
    flush: { default: !1 },
    horizontal: { type: [Boolean, String], default: !1 },
    numbered: { default: !1 },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, a = c(d(t, "flush")), l = c(d(t, "numbered")), o = u(() => {
      const r = a.value ? !1 : t.horizontal;
      return {
        "list-group-flush": a.value,
        "list-group-horizontal": r === !0,
        [`list-group-horizontal-${r}`]: typeof r == "string",
        "list-group-numbered": l.value
      };
    }), n = u(() => l.value === !0 ? "ol" : t.tag);
    return Qe(wo, {
      numbered: l
    }), (r, s) => (g(), D(le(i(n)), {
      class: j(["list-group", i(o)])
    }, {
      default: q(() => [
        x(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Fd = /* @__PURE__ */ H({
  __name: "BListGroupItem",
  props: {
    action: { default: !1 },
    active: { default: !1 },
    button: { default: !1 },
    disabled: { default: !1 },
    href: { default: void 0 },
    tag: { default: "div" },
    target: { default: "_self" },
    to: { default: void 0 },
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = lo(), l = Ie(wo, null), o = c(d(t, "action")), n = c(d(t, "active")), r = c(d(t, "button")), s = c(d(t, "disabled")), f = u(() => !r.value && (!!t.href || !!t.to)), m = u(
      () => l != null && l.numbered.value ? "li" : r.value ? "button" : f.value ? Ne : t.tag
    ), y = u(
      () => o.value || f.value || r.value || ["a", "router-link", "button", "b-link"].includes(t.tag)
    ), b = u(() => ({
      [`list-group-item-${t.variant}`]: t.variant !== void 0,
      "list-group-item-action": y.value,
      active: n.value,
      disabled: s.value
    })), v = u(() => {
      const B = {};
      return r.value && ((!a || !a.type) && (B.type = "button"), s.value && (B.disabled = !0)), B;
    });
    return (B, p) => (g(), D(le(i(m)), Z({
      class: ["list-group-item", i(b)],
      "aria-current": i(n) ? !0 : void 0,
      "aria-disabled": i(s) ? !0 : void 0,
      target: i(f) ? e.target : void 0,
      href: i(r) ? void 0 : e.href,
      to: i(r) ? void 0 : e.to
    }, i(v)), {
      default: q(() => [
        x(B.$slots, "default")
      ]),
      _: 3
    }, 16, ["class", "aria-current", "aria-disabled", "target", "href", "to"]));
  }
}), Ld = ["id", "aria-labelledby", "aria-describedby"], Nd = ["id"], zd = {
  inheritAttrs: !1
}, Rd = /* @__PURE__ */ H({
  ...zd,
  __name: "BModal",
  props: {
    bodyBgVariant: { default: void 0 },
    bodyClass: { default: void 0 },
    bodyTextVariant: { default: void 0 },
    busy: { default: !1 },
    lazy: { default: !1 },
    buttonSize: { default: "md" },
    cancelDisabled: { default: !1 },
    cancelTitle: { default: "Cancel" },
    cancelVariant: { default: "secondary" },
    centered: { default: !1 },
    contentClass: { default: void 0 },
    dialogClass: { default: void 0 },
    footerBgVariant: { default: void 0 },
    footerBorderVariant: { default: void 0 },
    footerClass: { default: void 0 },
    footerTextVariant: { default: void 0 },
    fullscreen: { type: [Boolean, String], default: !1 },
    headerBgVariant: { default: void 0 },
    headerBorderVariant: { default: void 0 },
    headerClass: { default: void 0 },
    headerCloseLabel: { default: "Close" },
    headerCloseWhite: { default: !1 },
    headerTextVariant: { default: void 0 },
    hideBackdrop: { default: !1 },
    hideFooter: { default: !1 },
    hideHeader: { default: !1 },
    hideHeaderClose: { default: !1 },
    id: { default: void 0 },
    modalClass: { default: void 0 },
    modelValue: { default: !1 },
    noCloseOnBackdrop: { default: !1 },
    noCloseOnEsc: { default: !1 },
    noFade: { default: !1 },
    autoFocus: { default: !0 },
    okDisabled: { default: !1 },
    okOnly: { default: !1 },
    okTitle: { default: "Ok" },
    okVariant: { default: "primary" },
    scrollable: { default: !1 },
    show: { default: !1 },
    size: { default: "md" },
    title: { default: void 0 },
    titleClass: { default: void 0 },
    titleSrOnly: { default: !1 },
    titleTag: { default: "h5" },
    static: { default: !1 },
    autoFocusButton: { default: void 0 }
  },
  emits: ["update:modelValue", "show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "ok", "cancel", "close"],
  setup(e, { emit: t }) {
    const a = e, l = Fe(), o = _e(d(a, "id"), "modal"), n = xe(a, "modelValue", t), r = c(d(a, "busy")), s = c(d(a, "lazy")), f = c(d(a, "cancelDisabled")), m = c(d(a, "centered")), y = c(d(a, "hideBackdrop")), b = c(d(a, "hideFooter")), v = c(d(a, "hideHeader")), B = c(d(a, "hideHeaderClose")), p = c(n), S = c(d(a, "noCloseOnBackdrop")), h = c(d(a, "noCloseOnEsc")), $ = c(d(a, "noFade")), k = c(d(a, "autoFocus")), w = c(d(a, "okDisabled")), A = c(d(a, "okOnly")), T = c(d(a, "scrollable")), C = c(d(a, "titleSrOnly")), I = c(d(a, "static")), O = z(null), F = z(null), _ = z(null), P = z(null), L = z(p.value), N = z(!1), { focused: ee } = qe(O, {
      initialValue: p.value && a.autoFocusButton === void 0
    }), { focused: K } = qe(F, {
      initialValue: p.value && a.autoFocusButton === "ok"
    }), { focused: G } = qe(_, {
      initialValue: p.value && a.autoFocusButton === "cancel"
    }), { focused: ae } = qe(P, {
      initialValue: p.value && a.autoFocusButton === "close"
    }), de = u(() => [
      a.modalClass,
      {
        fade: !$.value,
        show: L.value
      }
    ]), he = u(
      () => s.value === !1 || s.value === !0 && N.value === !0 || s.value === !0 && p.value === !0
    ), Be = u(() => !Oe(l["header-close"])), oe = u(() => [
      a.dialogClass,
      {
        "modal-fullscreen": a.fullscreen === !0,
        [`modal-fullscreen-${a.fullscreen}-down`]: typeof a.fullscreen == "string",
        [`modal-${a.size}`]: a.size !== "md",
        "modal-dialog-centered": m.value,
        "modal-dialog-scrollable": T.value
      }
    ]), ve = u(() => [
      a.bodyClass,
      {
        [`bg-${a.bodyBgVariant}`]: a.bodyBgVariant !== void 0,
        [`text-${a.bodyTextVariant}`]: a.bodyTextVariant !== void 0
      }
    ]), R = u(() => [
      a.headerClass,
      {
        [`bg-${a.headerBgVariant}`]: a.headerBgVariant !== void 0,
        [`border-${a.headerBorderVariant}`]: a.headerBorderVariant !== void 0,
        [`text-${a.headerTextVariant}`]: a.headerTextVariant !== void 0
      }
    ]), U = u(() => [
      a.footerClass,
      {
        [`bg-${a.footerBgVariant}`]: a.footerBgVariant !== void 0,
        [`border-${a.footerBorderVariant}`]: a.footerBorderVariant !== void 0,
        [`text-${a.footerTextVariant}`]: a.footerTextVariant !== void 0
      }
    ]), pe = u(() => [
      a.titleClass,
      {
        ["visually-hidden"]: C.value
      }
    ]), Q = u(() => f.value || r.value), ne = u(() => w.value || r.value), ce = (M, me = {}) => new zt(M, {
      cancelable: !1,
      target: O.value || null,
      relatedTarget: null,
      trigger: null,
      ...me,
      componentId: o.value
    }), ye = (M = "") => {
      const me = ce("hide", { cancelable: M !== "", trigger: M });
      if (M === "ok" && t(M, me), M === "cancel" && t(M, me), M === "close" && t(M, me), t("hide", me), me.defaultPrevented || M === "backdrop" && S.value || M === "esc" && h.value) {
        t("hide-prevented");
        return;
      }
      n.value = !1;
    }, Ae = () => {
      const M = ce("show", { cancelable: !0 });
      if (t("show", M), M.defaultPrevented) {
        n.value = !1, t("show-prevented");
        return;
      }
      n.value = !0;
    }, te = () => {
      k.value !== !1 && (a.autoFocusButton === "ok" ? K.value = !0 : a.autoFocusButton === "close" ? ae.value = !0 : a.autoFocusButton === "cancel" ? G.value = !0 : ee.value = !0);
    }, ue = () => Ae(), E = () => {
      L.value = !0, te(), t("shown", ce("shown")), s.value === !0 && (N.value = !0);
    }, W = () => L.value = !1, ge = () => {
      t("hidden", ce("hidden")), s.value === !0 && (N.value = !1);
    };
    return qi(L), Ce(O, "bv-toggle", () => {
      p.value ? ye() : Ae();
    }), (M, me) => (g(), D(za, {
      to: "body",
      disabled: i(I)
    }, [
      $e(Tt, {
        "no-fade": !0,
        "trans-props": { enterToClass: "show" },
        onBeforeEnter: ue,
        onAfterEnter: E,
        onLeave: W,
        onAfterLeave: ge
      }, {
        default: q(() => [
          it(X("div", Z({
            id: i(o),
            ref_key: "element",
            ref: O,
            class: ["modal", i(de)],
            role: "dialog",
            "aria-labelledby": `${i(o)}-label`,
            "aria-describedby": `${i(o)}-body`,
            tabindex: "-1"
          }, M.$attrs, {
            onKeyup: me[5] || (me[5] = Ot((be) => ye("esc"), ["esc"]))
          }), [
            X("div", {
              class: j(["modal-dialog", i(oe)])
            }, [
              i(he) ? (g(), V("div", {
                key: 0,
                class: j(["modal-content", e.contentClass])
              }, [
                i(v) ? J("", !0) : (g(), V("div", {
                  key: 0,
                  class: j(["modal-header", i(R)])
                }, [
                  x(M.$slots, "header", {}, () => [
                    (g(), D(le(e.titleTag), {
                      id: `${i(o)}-label`,
                      class: j(["modal-title", i(pe)])
                    }, {
                      default: q(() => [
                        x(M.$slots, "title", {}, () => [
                          ie(Y(e.title), 1)
                        ], !0)
                      ]),
                      _: 3
                    }, 8, ["id", "class"])),
                    i(B) ? J("", !0) : (g(), V(fe, { key: 0 }, [
                      i(Be) ? (g(), V("button", {
                        key: 0,
                        type: "button",
                        onClick: me[0] || (me[0] = (be) => ye("close"))
                      }, [
                        x(M.$slots, "header-close", {}, void 0, !0)
                      ])) : (g(), D(_t, {
                        key: 1,
                        ref_key: "closeButton",
                        ref: P,
                        "aria-label": e.headerCloseLabel,
                        white: e.headerCloseWhite,
                        onClick: me[1] || (me[1] = (be) => ye("close"))
                      }, null, 8, ["aria-label", "white"]))
                    ], 64))
                  ], !0)
                ], 2)),
                X("div", {
                  id: `${i(o)}-body`,
                  class: j(["modal-body", i(ve)])
                }, [
                  x(M.$slots, "default", {}, void 0, !0)
                ], 10, Nd),
                i(b) ? J("", !0) : (g(), V("div", {
                  key: 1,
                  class: j(["modal-footer", i(U)])
                }, [
                  x(M.$slots, "footer", {}, () => [
                    x(M.$slots, "cancel", {}, () => [
                      i(A) ? J("", !0) : (g(), D(wt, {
                        key: 0,
                        ref_key: "cancelButton",
                        ref: _,
                        disabled: i(Q),
                        size: e.buttonSize,
                        variant: e.cancelVariant,
                        onClick: me[2] || (me[2] = (be) => ye("cancel"))
                      }, {
                        default: q(() => [
                          ie(Y(e.cancelTitle), 1)
                        ]),
                        _: 1
                      }, 8, ["disabled", "size", "variant"]))
                    ], !0),
                    x(M.$slots, "ok", {}, () => [
                      $e(wt, {
                        ref_key: "okButton",
                        ref: F,
                        disabled: i(ne),
                        size: e.buttonSize,
                        variant: e.okVariant,
                        onClick: me[3] || (me[3] = (be) => ye("ok"))
                      }, {
                        default: q(() => [
                          ie(Y(e.okTitle), 1)
                        ]),
                        _: 1
                      }, 8, ["disabled", "size", "variant"])
                    ], !0)
                  ], !0)
                ], 2))
              ], 2)) : J("", !0)
            ], 2),
            i(y) ? J("", !0) : x(M.$slots, "backdrop", { key: 0 }, () => [
              X("div", {
                class: "modal-backdrop fade show",
                onClick: me[4] || (me[4] = (be) => ye("backdrop"))
              })
            ], !0)
          ], 16, Ld), [
            [ra, i(p)]
          ])
        ]),
        _: 3
      })
    ], 8, ["disabled"]));
  }
});
const Hd = /* @__PURE__ */ ze(Rd, [["__scopeId", "data-v-082911c2"]]), Md = /* @__PURE__ */ H({
  __name: "BNav",
  props: {
    align: { default: void 0 },
    cardHeader: { default: !1 },
    fill: { default: !1 },
    justified: { default: !1 },
    pills: { default: !1 },
    small: { default: !1 },
    tabs: { default: !1 },
    tag: { default: "ul" },
    vertical: { default: !1 }
  },
  setup(e) {
    const t = e, a = c(d(t, "cardHeader")), l = c(d(t, "fill")), o = c(d(t, "justified")), n = c(d(t, "pills")), r = c(d(t, "small")), s = c(d(t, "tabs")), f = c(d(t, "vertical")), m = Ht(d(t, "align")), y = u(() => ({
      "nav-tabs": s.value,
      "nav-pills": n.value && !s.value,
      "card-header-tabs": !f.value && a.value && s.value,
      "card-header-pills": !f.value && a.value && n.value && !s.value,
      "flex-column": f.value,
      "nav-fill": !f.value && l.value,
      "nav-justified": !f.value && o.value,
      [m.value]: !f.value && t.align !== void 0,
      small: r.value
    }));
    return (b, v) => (g(), D(le(e.tag), {
      class: j(["nav", i(y)])
    }, {
      default: q(() => [
        x(b.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Dd = /* @__PURE__ */ H({
  __name: "BNavForm",
  props: {
    role: { default: void 0 },
    id: { default: void 0 },
    floating: { default: !1 },
    novalidate: { default: !1 },
    validated: { default: !1 }
  },
  emits: ["submit"],
  setup(e, { emit: t }) {
    const a = e, l = u(() => ({
      floating: a.floating,
      role: a.role,
      id: a.id,
      novalidate: a.novalidate,
      validated: a.validated
    })), o = (n) => t("submit", n);
    return (n, r) => (g(), D(Bn, Z(i(l), {
      class: "d-flex",
      onSubmit: ct(o, ["prevent"])
    }), {
      default: q(() => [
        x(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["onSubmit"]));
  }
}), jd = H({
  components: { BLink: Ne },
  props: {
    ...Rt(vt, ["event", "routerTag"])
  },
  setup(e) {
    return { disabledBoolean: c(d(e, "disabled")) };
  }
}), qd = { class: "nav-item" };
function Gd(e, t, a, l, o, n) {
  const r = ao("b-link");
  return g(), V("li", qd, [
    $e(r, Z({ class: "nav-link" }, e.$props, {
      "active-class": "active",
      tabindex: e.disabledBoolean ? -1 : void 0,
      "aria-disabled": e.disabledBoolean ? !0 : void 0
    }), {
      default: q(() => [
        x(e.$slots, "default")
      ]),
      _: 3
    }, 16, ["tabindex", "aria-disabled"])
  ]);
}
const Wd = /* @__PURE__ */ ze(jd, [["render", Gd]]), Ud = { class: "nav-item dropdown" }, Xd = /* @__PURE__ */ H({
  __name: "BNavItemDropdown",
  props: {
    id: { default: void 0 },
    text: { default: void 0 },
    toggleClass: { default: void 0 },
    size: { default: "md" },
    offset: { default: void 0 },
    autoClose: { type: [Boolean, String], default: void 0 },
    dark: { default: void 0 },
    splitVariant: { default: void 0 },
    noCaret: { default: void 0 },
    variant: { default: "link" },
    modelValue: { default: !1 },
    lazy: { default: void 0 },
    strategy: { default: void 0 },
    floatingMiddleware: { default: void 0 },
    noFlip: { default: void 0 },
    noShift: { default: void 0 },
    dropup: { default: void 0 },
    dropend: { default: void 0 },
    dropstart: { default: void 0 },
    center: { default: void 0 },
    end: { default: void 0 },
    menuClass: { default: void 0 }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = xe(a, "modelValue", t), o = c(l), n = u({
      get: () => o.value,
      set: (s) => l.value = s
    }), r = u(() => Rt(a, ["modelValue"]));
    return (s, f) => (g(), V("li", Ud, [
      $e(yn, Z({
        modelValue: i(n),
        "onUpdate:modelValue": f[0] || (f[0] = (m) => kt(n) ? n.value = m : null)
      }, i(r), { "is-nav": "" }), {
        "button-content": q(() => [
          x(s.$slots, "button-content")
        ]),
        "toggle-text": q(() => [
          x(s.$slots, "toggle-text")
        ]),
        default: q(() => [
          x(s.$slots, "default")
        ]),
        _: 3
      }, 16, ["modelValue"])
    ]));
  }
}), Kd = { class: "navbar-text" }, Jd = /* @__PURE__ */ H({
  __name: "BNavText",
  props: {
    text: { default: void 0 }
  },
  setup(e) {
    return (t, a) => (g(), V("li", Kd, [
      x(t.$slots, "default", {}, () => [
        ie(Y(e.text), 1)
      ])
    ]));
  }
}), Yd = /* @__PURE__ */ H({
  __name: "BNavbar",
  props: {
    fixed: { default: void 0 },
    print: { default: !1 },
    sticky: { default: void 0 },
    tag: { default: "nav" },
    toggleable: { type: [Boolean, String], default: !1 },
    dark: { default: !1 },
    variant: { default: void 0 },
    container: { type: [String, Boolean], default: "fluid" }
  },
  setup(e) {
    const t = e, a = c(d(t, "print")), l = c(d(t, "dark")), o = u(
      () => t.tag === "nav" ? void 0 : "navigation"
    ), n = u(
      () => typeof t.toggleable == "string" ? `navbar-expand-${t.toggleable}` : t.toggleable === !1 ? "navbar-expand" : void 0
    ), r = u(
      () => t.container === !0 ? "container" : "container-fluid"
    ), s = u(() => ({
      "d-print": a.value,
      [`sticky-${t.sticky}`]: t.sticky !== void 0,
      "navbar-dark": l.value,
      [`bg-${t.variant}`]: t.variant !== void 0,
      [`fixed-${t.fixed}`]: t.fixed !== void 0,
      [`${n.value}`]: n.value !== void 0
    }));
    return (f, m) => (g(), D(le(e.tag), {
      class: j(["navbar", i(s)]),
      role: i(o)
    }, {
      default: q(() => [
        e.container !== !1 ? (g(), V("div", {
          key: 0,
          class: j(i(r))
        }, [
          x(f.$slots, "default")
        ], 2)) : x(f.$slots, "default", { key: 1 })
      ]),
      _: 3
    }, 8, ["class", "role"]));
  }
}), Nl = Rt(vt, ["event", "routerTag"]), Zd = H({
  components: {
    BLink: Ne
  },
  props: {
    tag: { type: String, default: "div" },
    ...Nl
  },
  setup(e) {
    const t = u(() => Et(e)), a = u(
      () => t.value ? Ne : e.tag
    );
    return {
      computedLinkProps: u(
        () => t.value ? Da(e, Nl) : {}
      ),
      computedTag: a
    };
  }
});
function Qd(e, t, a, l, o, n) {
  return g(), D(le(e.computedTag), Z({ class: "navbar-brand" }, e.computedLinkProps), {
    default: q(() => [
      x(e.$slots, "default")
    ]),
    _: 3
  }, 16);
}
const ec = /* @__PURE__ */ ze(Zd, [["render", Qd]]), tc = /* @__PURE__ */ H({
  __name: "BNavbarNav",
  props: {
    align: { default: void 0 },
    fill: { default: !1 },
    justified: { default: !1 },
    small: { default: !1 },
    tag: { default: "ul" }
  },
  setup(e) {
    const t = e, a = c(d(t, "fill")), l = c(d(t, "justified")), o = c(d(t, "small")), n = Ht(d(t, "align")), r = u(() => ({
      "nav-fill": a.value,
      "nav-justified": l.value,
      [n.value]: t.align !== void 0,
      small: o.value
    }));
    return (s, f) => (g(), V("ul", {
      class: j(["navbar-nav", i(r)])
    }, [
      x(s.$slots, "default")
    ], 2));
  }
}), zl = (e, t) => e.setAttribute("data-bs-theme", t), ac = {
  mounted(e, t) {
    zl(e, t.value);
  },
  updated(e, t) {
    zl(e, t.value);
  }
}, el = (e, t) => {
  const { modifiers: a, arg: l, value: o } = e, n = Object.keys(a || {}), r = typeof o == "string" ? o.split(Ut) : o;
  if (Cs(t.tagName, "a")) {
    const s = Ma(t, "href") || "";
    ts.test(s) && n.push(s.replace(es, ""));
  }
  return Array.prototype.concat.apply([], [l, r]).forEach((s) => typeof s == "string" && n.push(s)), n.filter((s, f, m) => s && m.indexOf(s) === f);
}, lc = (e, t) => {
  el(e, t).forEach((l) => {
    const o = document.getElementById(l);
    o !== null && o.dispatchEvent(new Event("bv-toggle"));
  }), setTimeout(() => _n(e, t), 50);
}, _n = (e, t) => {
  const a = el(e, t);
  let l = !1;
  a.forEach((o) => {
    const n = document.getElementById(o);
    n != null && n.classList.contains("show") && (l = !0), n != null && n.classList.contains("closing") && (l = !1);
  }), t.setAttribute("aria-expanded", l ? "true" : "false");
}, Ia = {
  mounted(e, t) {
    e.__toggle = () => lc(t, e), e.addEventListener("click", e.__toggle), _n(t, e), e.setAttribute("aria-controls", el(t, e).join(" "));
  },
  unmounted(e) {
    e.removeEventListener("click", e.__toggle), e.removeAttribute("aria-controls"), e.removeAttribute("aria-expanded");
  }
}, oc = {
  mounted(e, t) {
    const a = oa(t.value, e);
    e.$__state = z({
      ...na(t, e),
      ...a
    }), on(e, t);
  },
  updated(e, t) {
    const a = oa(t.value, e);
    e.$__state && (e.$__state.value = {
      ...na(t, e),
      ...a
    });
  },
  beforeUnmount(e) {
    nn(e);
  }
}, nc = {
  mounted(e, t) {
    const a = oa(t.value, e);
    e.$__state = z({
      ...na(t, e),
      title: a.title ?? a.content ?? "",
      tooltip: !0
    }), on(e, t);
  },
  updated(e, t) {
    const a = oa(t.value, e);
    e.$__state && (e.$__state.value = {
      ...na(t, e),
      title: a.title ?? a.content ?? "",
      tooltip: !0
    });
  },
  beforeUnmount(e) {
    nn(e);
  }
}, sc = /* @__PURE__ */ X("span", { class: "navbar-toggler-icon" }, null, -1), ic = /* @__PURE__ */ H({
  __name: "BNavbarToggle",
  props: {
    disabled: { default: !1 },
    label: { default: "Toggle navigation" },
    target: { default: void 0 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = e, l = c(d(a, "disabled")), o = u(() => ({
      disabled: l.value,
      "aria-label": a.label
    })), n = u(() => ({
      disabled: l.value
    })), r = (s) => {
      l.value || t("click", s);
    };
    return (s, f) => it((g(), V("button", Z({
      class: ["navbar-toggler", i(n)],
      type: "button"
    }, i(o), { onClick: r }), [
      x(s.$slots, "default", {}, () => [
        sc
      ])
    ], 16)), [
      [i(Ia), i(l) ? void 0 : e.target]
    ]);
  }
}), xn = /* @__PURE__ */ H({
  __name: "BOverlay",
  props: {
    bgColor: { default: void 0 },
    blur: { default: "2px" },
    fixed: { default: !1 },
    noCenter: { default: !1 },
    noFade: { default: !1 },
    noWrap: { default: !1 },
    opacity: { default: 0.85 },
    overlayTag: { default: "div" },
    rounded: { type: [Boolean, String], default: !1 },
    show: { default: !1 },
    spinnerSmall: { default: !1 },
    spinnerType: { default: "border" },
    spinnerVariant: { default: void 0 },
    noSpinner: { default: !1 },
    variant: { default: "light" },
    wrapTag: { default: "div" },
    zIndex: { default: 10 }
  },
  emits: ["click", "hidden", "shown"],
  setup(e, { emit: t }) {
    const a = e, l = { top: 0, left: 0, bottom: 0, right: 0 }, o = c(d(a, "fixed")), n = c(d(a, "noSpinner")), r = c(d(a, "noCenter")), s = c(d(a, "noWrap")), f = c(d(a, "show")), m = c(d(a, "spinnerSmall")), y = u(
      () => a.rounded === !0 || a.rounded === "" ? "rounded" : a.rounded === !1 ? "" : `rounded-${a.rounded}`
    ), b = u(
      () => a.variant && !a.bgColor ? `bg-${a.variant}` : ""
    ), v = u(() => f.value ? !0 : null), B = u(() => ({
      type: a.spinnerType || void 0,
      variant: a.spinnerVariant || void 0,
      small: m.value
    })), p = u(() => ({
      ...l,
      zIndex: a.zIndex || 10
    })), S = u(() => [
      "b-overlay",
      {
        "position-absolute": !s.value || !o.value,
        "position-fixed": s.value && o.value
      }
    ]), h = u(() => [b.value, y.value]), $ = u(() => ({
      ...l,
      opacity: a.opacity,
      backgroundColor: a.bgColor || void 0,
      backdropFilter: blur ? `blur(${blur})` : void 0
    })), k = u(
      () => r.value ? l : {
        top: "50%",
        left: "50%",
        transform: "translateX(-50%) translateY(-50%)"
      }
    );
    return (w, A) => (g(), D(le(e.wrapTag), {
      class: "b-overlay-wrap position-relative",
      "aria-busy": i(v)
    }, {
      default: q(() => [
        x(w.$slots, "default"),
        $e(Tt, {
          "no-fade": e.noFade,
          "trans-props": { enterToClass: "show" },
          name: "fade",
          onOnAfterEnter: A[1] || (A[1] = (T) => t("shown")),
          onOnAfterLeave: A[2] || (A[2] = (T) => t("hidden"))
        }, {
          default: q(() => [
            i(f) ? (g(), D(le(e.overlayTag), {
              key: 0,
              class: j(i(S)),
              style: je(i(p)),
              onClick: A[0] || (A[0] = (T) => t("click", T))
            }, {
              default: q(() => [
                X("div", {
                  class: j(["position-absolute", i(h)]),
                  style: je(i($))
                }, null, 6),
                X("div", {
                  class: "position-absolute",
                  style: je(i(k))
                }, [
                  x(w.$slots, "overlay", ke(Pe(i(B))), () => [
                    i(n) ? J("", !0) : (g(), D(pa, ke(Z({ key: 0 }, i(B))), null, 16))
                  ])
                ], 4)
              ]),
              _: 3
            }, 8, ["class", "style"])) : J("", !0)
          ]),
          _: 3
        }, 8, ["no-fade"])
      ]),
      _: 3
    }, 8, ["aria-busy"]));
  }
}), rc = {
  key: 0,
  class: "offcanvas-header"
}, uc = {
  id: "offcanvasLabel",
  class: "offcanvas-title"
}, dc = { class: "offcanvas-body" }, cc = { key: 1 }, fc = {
  inheritAttrs: !1
}, vc = /* @__PURE__ */ H({
  ...fc,
  __name: "BOffcanvas",
  props: {
    dismissLabel: { default: "Close" },
    modelValue: { default: !1 },
    bodyScrolling: { default: !1 },
    backdrop: { default: !0 },
    noCloseOnBackdrop: { default: !1 },
    noCloseOnEsc: { default: !1 },
    placement: { default: "start" },
    title: { default: void 0 },
    noHeaderClose: { default: !1 },
    noHeader: { default: !1 },
    lazy: { default: !1 },
    id: { default: void 0 },
    noFocus: { default: !1 },
    static: { default: !1 },
    backdropVariant: { default: "dark" }
  },
  emits: ["update:modelValue", "show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "esc", "close"],
  setup(e, { emit: t }) {
    const a = e, l = Fe(), o = xe(a, "modelValue", t), n = c(o);
    c(d(a, "bodyScrolling"));
    const r = c(d(a, "backdrop")), s = c(d(a, "noHeaderClose")), f = c(d(a, "noHeader")), m = c(d(a, "noFocus")), y = c(d(a, "noCloseOnBackdrop")), b = c(d(a, "noCloseOnEsc")), v = c(d(a, "lazy")), B = c(d(a, "static")), p = _e(d(a, "id"), "offcanvas"), S = z(null), { focused: h } = qe(S, {
      initialValue: n.value && m.value === !1
    }), $ = z(n.value), k = z(!1), w = u(
      () => r.value === !0 && n.value === !0
    ), A = u(
      () => v.value === !1 || v.value === !0 && k.value === !0 || v.value === !0 && n.value === !0
    ), T = u(() => !Oe(l.footer)), C = u(() => [
      // props.responsive === undefined ? 'offcanvas' : `offcanvas-${props.responsive}`,
      "offcanvas",
      // Remove when above check is fixed
      `offcanvas-${a.placement}`,
      {
        show: n.value && $.value === !0
      }
    ]), I = (K, G = {}) => new zt(K, {
      cancelable: !1,
      target: S.value || null,
      relatedTarget: null,
      trigger: null,
      ...G,
      componentId: p.value
    }), O = (K = "") => {
      const G = I("hide", { cancelable: K !== "", trigger: K });
      if (K === "close" && t(K, G), K === "esc" && t(K, G), t("hide", G), G.defaultPrevented || K === "backdrop" && y.value || K === "esc" && b.value) {
        t("hide-prevented");
        return;
      }
      o.value = !1;
    }, F = () => {
      const K = I("show", { cancelable: !0 });
      if (t("show", K), K.defaultPrevented) {
        o.value = !1, t("show-prevented");
        return;
      }
      o.value = !0;
    }, _ = () => {
      Te(() => {
        m.value === !1 && (h.value = !0);
      });
    }, P = () => F(), L = () => {
      $.value = !0, _(), t("shown", I("shown")), v.value === !0 && (k.value = !0);
    }, N = () => $.value = !1, ee = () => {
      t("hidden", I("hidden")), v.value === !0 && (k.value = !1);
    };
    return Ce(S, "bv-toggle", () => {
      n.value ? O() : F();
    }), (K, G) => (g(), D(za, {
      to: "body",
      disabled: i(B)
    }, [
      $e(Tt, {
        "no-fade": !0,
        "trans-props": {
          enterToClass: "showing",
          enterFromClass: "",
          leaveToClass: "hiding show",
          leaveFromClass: "show"
        },
        onBeforeEnter: P,
        onAfterEnter: L,
        onLeave: N,
        onAfterLeave: ee
      }, {
        default: q(() => [
          it(X("div", Z({
            ref_key: "element",
            ref: S,
            "aria-modal": "true",
            role: "dialog",
            class: i(C),
            tabindex: "-1",
            "aria-labelledby": "offcanvasLabel",
            "data-bs-backdrop": "false"
          }, K.$attrs, {
            onKeyup: G[1] || (G[1] = Ot((ae) => O("esc"), ["esc"]))
          }), [
            i(A) ? (g(), V(fe, { key: 0 }, [
              i(f) ? J("", !0) : (g(), V("div", rc, [
                x(K.$slots, "header", ke(Pe({ visible: i(n), placement: e.placement, hide: O })), () => [
                  X("h5", uc, [
                    x(K.$slots, "title", {}, () => [
                      ie(Y(e.title), 1)
                    ])
                  ]),
                  i(s) ? J("", !0) : (g(), D(_t, {
                    key: 0,
                    class: "text-reset",
                    "aria-label": e.dismissLabel,
                    onClick: G[0] || (G[0] = (ae) => O("close"))
                  }, null, 8, ["aria-label"]))
                ])
              ])),
              X("div", dc, [
                x(K.$slots, "default")
              ]),
              i(T) ? (g(), V("div", cc, [
                x(K.$slots, "footer", ke(Pe({ visible: i(n), placement: e.placement, hide: O })))
              ])) : J("", !0)
            ], 64)) : J("", !0)
          ], 16), [
            [ra, i(o)]
          ])
        ]),
        _: 3
      }),
      $e(xn, {
        variant: e.backdropVariant,
        show: i(w),
        fixed: !0,
        "no-wrap": "",
        "no-spinner": !0,
        onClick: G[2] || (G[2] = (ae) => O("backdrop"))
      }, null, 8, ["variant", "show"])
    ], 8, ["disabled"]));
  }
}), mc = 5, An = 20, Vn = 0, Ke = 3, pc = "ellipsis-text", gc = "first-text", bc = "last-text", hc = "next-text", yc = "page", Bc = "prev-text", Rl = (e) => Math.max(ot(e) || An, 1), Hl = (e) => Math.max(ot(e) || Vn, 0), $c = (e, t) => {
  const a = ot(e) || 1;
  return a > t ? t : a < 1 ? 1 : a;
}, wc = H({
  name: "BPagination",
  props: {
    align: { type: String, default: "start" },
    ariaControls: { type: String, default: void 0 },
    ariaLabel: { type: String, default: "Pagination" },
    disabled: { type: [Boolean, String], default: !1 },
    ellipsisClass: { type: [Array, String], default: () => [] },
    ellipsisText: { type: String, default: "â¦" },
    firstClass: { type: [Array, String], default: () => [] },
    firstNumber: { type: [Boolean, String], default: !1 },
    firstText: { type: String, default: "Â«" },
    hideEllipsis: { type: [Boolean, String], default: !1 },
    hideGotoEndButtons: { type: [Boolean, String], default: !1 },
    labelFirstPage: { type: String, default: "Go to first page" },
    labelLastPage: { type: String, default: "Go to last page" },
    labelNextPage: { type: String, default: "Go to next page" },
    labelPage: { type: String, default: "Go to page" },
    labelPrevPage: { type: String, default: "Go to previous page" },
    lastClass: { type: [Array, String], default: () => [] },
    lastNumber: { type: [Boolean, String], default: !1 },
    lastText: { type: String, default: "Â»" },
    limit: { type: Number, default: mc },
    modelValue: { type: Number, default: 1 },
    // V-model prop
    nextClass: { type: [Array, String], default: () => [] },
    nextText: { type: String, default: "âº" },
    pageClass: { type: [Array, String], default: () => [] },
    perPage: { type: Number, default: An },
    pills: { type: [Boolean, String], default: !1 },
    prevClass: { type: [Array, String], default: () => [] },
    prevText: { type: String, default: "â¹" },
    size: { type: String, default: "md" },
    totalRows: { type: Number, default: Vn }
  },
  emits: ["update:modelValue", "page-click"],
  setup(e, { emit: t, slots: a }) {
    const l = xe(e, "modelValue", t), o = c(d(e, "disabled")), n = c(d(e, "firstNumber")), r = c(d(e, "hideEllipsis")), s = c(d(e, "hideGotoEndButtons")), f = c(d(e, "lastNumber")), m = c(d(e, "pills")), y = u(
      () => e.align === "fill" ? "start" : e.align
    ), b = Ht(d(y, "value")), v = u(
      () => Math.ceil(Hl(e.totalRows) / Rl(e.perPage))
    ), B = u(() => {
      let C;
      return v.value - l.value + 2 < e.limit && e.limit > Ke ? C = v.value - S.value + 1 : C = l.value - Math.floor(S.value / 2), C < 1 ? C = 1 : C > v.value - S.value && (C = v.value - S.value + 1), e.limit <= Ke && f.value && v.value === C + S.value - 1 && (C = Math.max(C - 1, 1)), C;
    }), p = u(() => {
      const C = v.value - l.value;
      let I = !1;
      return C + 2 < e.limit && e.limit > Ke ? e.limit > Ke && (I = !0) : e.limit > Ke && (I = !!(!r.value || n.value)), B.value <= 1 && (I = !1), I && n.value && B.value < 4 && (I = !1), I;
    }), S = u(() => {
      let C = e.limit;
      return v.value <= e.limit ? C = v.value : l.value < e.limit - 1 && e.limit > Ke ? ((!r.value || f.value) && (C = e.limit - (n.value ? 0 : 1)), C = Math.min(C, e.limit)) : v.value - l.value + 2 < e.limit && e.limit > Ke ? (!r.value || n.value) && (C = e.limit - (f.value ? 0 : 1)) : e.limit > Ke && (C = e.limit - (r.value ? 0 : 2)), C;
    }), h = u(() => {
      const C = v.value - S.value;
      let I = !1;
      l.value < e.limit - 1 && e.limit > Ke ? (!r.value || f.value) && (I = !0) : e.limit > Ke && (I = !!(!r.value || f.value)), B.value > C && (I = !1);
      const O = B.value + S.value - 1;
      return I && f.value && O > v.value - 3 && (I = !1), I;
    }), $ = dt({
      pageSize: Rl(e.perPage),
      totalRows: Hl(e.totalRows),
      numberOfPages: v.value
    }), k = (C, I) => {
      if (I === l.value)
        return;
      const { target: O } = C, F = new Ze("page-click", {
        cancelable: !0,
        target: O
      });
      t("page-click", F, I), !F.defaultPrevented && (l.value = I);
    }, w = u(() => e.size ? `pagination-${e.size}` : ""), A = u(() => m.value ? "b-pagination-pills" : "");
    se(l, (C) => {
      const I = $c(C, v.value);
      I !== l.value && (l.value = I);
    }), se($, (C, I) => {
      C != null && (I.pageSize !== C.pageSize && I.totalRows === C.totalRows || I.numberOfPages !== C.numberOfPages && l.value > I.numberOfPages) && (l.value = 1);
    });
    const T = u(() => {
      const C = [];
      for (let I = 0; I < S.value; I++)
        C.push({ number: B.value + I, classes: null });
      return C;
    });
    return () => {
      const C = [], I = T.value.map((G) => G.number), O = (G) => G === l.value, F = l.value < 1, _ = e.align === "fill", P = (G, ae, de, he, Be, oe) => {
        const ve = o.value || O(oe) || F || G < 1 || G > v.value, R = G < 1 ? 1 : G > v.value ? v.value : G, U = { disabled: ve, page: R, index: R - 1 }, pe = Me(de, U, a) || he || "";
        return re(
          "li",
          {
            class: [
              "page-item",
              {
                disabled: ve,
                "flex-fill": _,
                "d-flex": _ && !ve
              },
              Be
            ]
          },
          // render inner content
          re(
            ve ? "span" : "button",
            {
              class: ["page-link", { "flex-grow-1": !ve && _ }],
              "aria-label": ae,
              "aria-controls": e.ariaControls || null,
              "aria-disabled": ve ? !0 : null,
              role: "menuitem",
              type: ve ? null : "button",
              tabindex: ve ? null : "-1",
              onClick: (Q) => {
                ve || k(Q, R);
              }
            },
            pe
          )
        );
      }, L = (G) => re(
        "li",
        {
          class: [
            "page-item",
            "disabled",
            "bv-d-xs-down-none",
            _ ? "flex-fill" : "",
            e.ellipsisClass
          ],
          role: "separator",
          key: `ellipsis-${G ? "last" : "first"}`
        },
        [
          re(
            "span",
            { class: ["page-link"] },
            Me(pc, {}, a) || e.ellipsisText || "..."
          )
        ]
      ), N = (G, ae) => {
        const de = O(G.number) && !F, he = o.value ? null : de || F && ae === 0 ? "0" : "-1", Be = {
          active: de,
          disabled: o.value,
          page: G.number,
          index: G.number - 1,
          content: G.number
        }, oe = Me(yc, Be, a) || G.number, ve = re(
          o.value ? "span" : "button",
          {
            class: ["page-link", { "flex-grow-1": !o.value && _ }],
            "aria-controls": e.ariaControls || null,
            "aria-disabled": o.value ? !0 : null,
            "aria-label": e.labelPage ? `${e.labelPage} ${G.number}` : null,
            role: "menuitemradio",
            type: o.value ? null : "button",
            tabindex: he,
            onClick: (R) => {
              o.value || k(R, G.number);
            }
          },
          oe
        );
        return re(
          "li",
          {
            class: [
              "page-item",
              {
                disabled: o.value,
                active: de,
                "flex-fill": _,
                "d-flex": _ && !o.value
              },
              e.pageClass
            ],
            role: "presentation",
            key: `page-${G.number}`
          },
          ve
        );
      };
      if (!s.value && !n.value) {
        const G = P(
          1,
          e.labelFirstPage,
          gc,
          e.firstText,
          e.firstClass,
          1
        );
        C.push(G);
      }
      const ee = P(
        l.value - 1,
        e.labelFirstPage,
        Bc,
        e.prevText,
        e.prevClass,
        1
      );
      C.push(ee), n.value && I[0] !== 1 && C.push(N({ number: 1 }, 0)), p.value && C.push(L(!1)), T.value.forEach((G, ae) => {
        const de = p.value && n.value && I[0] !== 1 ? 1 : 0;
        C.push(N(G, ae + de));
      }), h.value && C.push(L(!0)), f.value && I[I.length - 1] !== v.value && C.push(N({ number: v.value }, -1));
      const K = P(
        l.value + 1,
        e.labelNextPage,
        hc,
        e.nextText,
        e.nextClass,
        v.value
      );
      if (C.push(K), !f.value && !s.value) {
        const G = P(
          v.value,
          e.labelLastPage,
          bc,
          e.lastText,
          e.lastClass,
          v.value
        );
        C.push(G);
      }
      return re(
        "ul",
        {
          class: ["pagination", w.value, b.value, A.value],
          role: "menubar",
          "aria-disabled": o.value,
          "aria-label": e.ariaLabel || null
        },
        C
      );
    };
  }
}), kc = {
  inheritAttrs: !1
}, He = /* @__PURE__ */ H({
  ...kc,
  __name: "BPlaceholder",
  props: {
    tag: { default: "span" },
    wrapperTag: { default: "span" },
    width: { default: void 0 },
    cols: { default: 12 },
    variant: { default: void 0 },
    size: { default: "md" },
    animation: { default: void 0 }
  },
  setup(e) {
    const t = e, a = u(
      () => t.width === void 0 ? void 0 : typeof t.width == "number" ? t.width.toString() : t.width.replace("%", "")
    ), l = u(
      () => t.cols === void 0 ? void 0 : typeof t.cols == "number" ? t.cols.toString() : t.cols
    ), o = u(() => ({
      [`col-${l.value}`]: l.value !== void 0 && a.value === void 0,
      [`bg-${t.variant}`]: t.variant !== void 0,
      [`placeholder-${t.size}`]: t.size !== "md"
    })), n = u(() => ({
      [`placeholder-${t.animation}`]: t.animation !== void 0
    })), r = u(() => ({
      width: a.value === void 0 ? void 0 : `${a.value}%`
    }));
    return (s, f) => (g(), D(le(e.wrapperTag), {
      class: j(i(n))
    }, {
      default: q(() => [
        (g(), D(le(e.tag), Z(s.$attrs, {
          class: ["placeholder", i(o)],
          style: i(r)
        }), null, 16, ["class", "style"]))
      ]),
      _: 1
    }, 8, ["class"]));
  }
}), Pn = /* @__PURE__ */ H({
  __name: "BPlaceholderButton",
  props: {
    tag: { default: "div" },
    width: { default: void 0 },
    cols: { default: void 0 },
    variant: { default: "primary" },
    animation: { default: void 0 }
  },
  setup(e) {
    const t = e, a = u(() => ["btn", `btn-${t.variant}`, "disabled"]), l = u(() => ({
      animation: t.animation,
      width: t.width,
      cols: t.cols,
      tag: t.tag
    }));
    return (o, n) => (g(), D(He, Z({ class: i(a) }, i(l)), null, 16, ["class"]));
  }
}), Sc = /* @__PURE__ */ H({
  __name: "BPlaceholderCard",
  props: {
    noHeader: { default: !1 },
    headerWidth: { default: 100 },
    headerVariant: { default: void 0 },
    headerAnimation: { default: void 0 },
    headerSize: { default: "md" },
    noFooter: { default: !1 },
    footerWidth: { default: 100 },
    footerVariant: { default: void 0 },
    footerAnimation: { default: void 0 },
    footerSize: { default: "md" },
    animation: { default: void 0 },
    size: { default: "md" },
    variant: { default: void 0 },
    noButton: { default: !1 },
    imgBottom: { default: !1 },
    imgSrc: { default: void 0 },
    imgBlankColor: { default: "#868e96" },
    imgHeight: { default: 100 },
    noImg: { default: !1 }
  },
  setup(e) {
    const t = e, a = c(d(t, "noButton")), l = c(d(t, "noHeader")), o = c(d(t, "noFooter")), n = c(d(t, "noImg")), r = u(() => ({
      width: t.headerWidth,
      variant: t.headerVariant,
      animation: t.headerAnimation,
      size: t.headerSize
    })), s = u(() => ({
      width: t.footerWidth,
      animation: t.footerAnimation,
      size: a.value ? t.footerSize : void 0,
      variant: t.footerVariant
    })), f = u(() => ({
      animation: t.animation,
      size: t.size,
      variant: t.variant
    })), m = u(() => ({
      blank: !t.imgSrc,
      blankColor: t.imgBlankColor,
      height: t.imgSrc ? void 0 : t.imgHeight,
      src: t.imgSrc,
      top: !t.imgBottom,
      bottom: t.imgBottom
    }));
    return (y, b) => (g(), D(pn, { "img-bottom": e.imgBottom }, oo({
      default: q(() => [
        x(y.$slots, "default", {}, () => [
          $e(He, Z({ cols: "7" }, i(f)), null, 16),
          $e(He, Z({ cols: "4" }, i(f)), null, 16),
          $e(He, Z({ cols: "4" }, i(f)), null, 16),
          $e(He, Z({ cols: "6" }, i(f)), null, 16),
          $e(He, Z({ cols: "8" }, i(f)), null, 16)
        ])
      ]),
      _: 2
    }, [
      i(n) ? void 0 : {
        name: "img",
        fn: q(() => [
          x(y.$slots, "img", {}, () => [
            $e(sa, ke(Pe(i(m))), null, 16)
          ])
        ]),
        key: "0"
      },
      i(l) ? void 0 : {
        name: "header",
        fn: q(() => [
          x(y.$slots, "header", {}, () => [
            $e(He, ke(Pe(i(r))), null, 16)
          ])
        ]),
        key: "1"
      },
      i(o) ? void 0 : {
        name: "footer",
        fn: q(() => [
          x(y.$slots, "footer", {}, () => [
            i(a) ? (g(), D(He, ke(Z({ key: 1 }, i(s))), null, 16)) : (g(), D(Pn, ke(Z({ key: 0 }, i(s))), null, 16))
          ])
        ]),
        key: "2"
      }
    ]), 1032, ["img-bottom"]));
  }
}), tl = /* @__PURE__ */ H({
  __name: "BTableSimple",
  props: {
    bordered: { default: !1 },
    borderless: { default: !1 },
    borderVariant: { default: void 0 },
    captionTop: { default: !1 },
    dark: { default: !1 },
    hover: { default: !1 },
    responsive: { type: [Boolean, String], default: !1 },
    stacked: { type: [Boolean, String], default: !1 },
    striped: { default: !1 },
    small: { default: !1 },
    tableClass: { default: void 0 },
    tableVariant: { default: void 0 },
    stickyHeader: { default: !1 }
  },
  setup(e) {
    const t = e, a = c(d(t, "captionTop")), l = c(d(t, "borderless")), o = c(d(t, "bordered")), n = c(d(t, "dark")), r = c(d(t, "hover")), s = c(d(t, "small")), f = c(d(t, "striped")), m = c(d(t, "stickyHeader")), y = u(() => [
      "table",
      "b-table",
      {
        "table-bordered": o.value,
        "table-borderless": l.value,
        [`border-${t.borderVariant}`]: t.borderVariant !== void 0,
        "caption-top": a.value,
        "table-dark": n.value,
        "table-hover": r.value,
        "b-table-stacked": typeof t.stacked == "boolean" && t.stacked,
        [`b-table-stacked-${t.stacked}`]: typeof t.stacked == "string",
        "table-striped": f.value,
        "table-sm": s.value,
        [`table-${t.tableVariant}`]: t.tableVariant !== void 0
      },
      t.tableClass
    ]), b = u(() => [
      {
        "table-responsive": t.responsive === !0,
        [`table-responsive-${t.responsive}`]: typeof t.responsive == "string",
        "b-table-sticky-header": m.value
      }
    ]);
    return (v, B) => e.responsive ? (g(), V("div", {
      key: 1,
      class: j(i(b))
    }, [
      X("table", {
        class: j(i(y))
      }, [
        x(v.$slots, "default")
      ], 2)
    ], 2)) : (g(), V("table", {
      key: 0,
      class: j(i(y))
    }, [
      x(v.$slots, "default")
    ], 2));
  }
}), Cc = /* @__PURE__ */ H({
  __name: "BPlaceholderTable",
  props: {
    rows: { default: 3 },
    columns: { default: 5 },
    cellWidth: { default: 100 },
    size: { default: "md" },
    animation: { default: void 0 },
    variant: { default: void 0 },
    headerColumns: { default: void 0 },
    hideHeader: { default: !1 },
    headerCellWidth: { default: 100 },
    headerSize: { default: "md" },
    headerAnimation: { default: void 0 },
    headerVariant: { default: void 0 },
    footerColumns: { default: void 0 },
    showFooter: { default: !1 },
    footerCellWidth: { default: 100 },
    footerSize: { default: "md" },
    footerAnimation: { default: void 0 },
    footerVariant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = yt(d(t, "columns"), { nanToZero: !0, method: "parseInt" }), l = yt(d(t, "rows"), { nanToZero: !0, method: "parseInt" }), o = u(() => t.headerColumns ?? NaN), n = u(() => t.footerColumns ?? NaN), r = yt(o, {
      nanToZero: !0,
      method: "parseInt"
    }), s = yt(n, {
      nanToZero: !0,
      method: "parseInt"
    }), f = u(() => a.value || 5), m = u(() => l.value || 3), y = u(
      () => t.headerColumns === void 0 ? f.value : r.value
    ), b = u(
      () => t.footerColumns === void 0 ? f.value : s.value
    ), v = u(() => ({
      size: t.size,
      variant: t.variant,
      animation: t.animation,
      width: t.cellWidth
    })), B = u(() => ({
      size: t.headerSize,
      variant: t.headerVariant,
      animation: t.headerAnimation,
      width: t.headerCellWidth
    })), p = u(() => ({
      size: t.footerSize,
      variant: t.footerVariant,
      animation: t.footerAnimation,
      width: t.footerCellWidth
    })), S = c(d(t, "hideHeader")), h = c(d(t, "showFooter"));
    return ($, k) => (g(), D(tl, null, {
      default: q(() => [
        i(S) ? J("", !0) : x($.$slots, "thead", { key: 0 }, () => [
          X("thead", null, [
            X("tr", null, [
              (g(!0), V(fe, null, we(i(y), (w, A) => (g(), V("th", { key: A }, [
                $e(He, ke(Pe(i(B))), null, 16)
              ]))), 128))
            ])
          ])
        ]),
        x($.$slots, "default", {}, () => [
          X("tbody", null, [
            (g(!0), V(fe, null, we(i(m), (w, A) => (g(), V("tr", { key: A }, [
              (g(!0), V(fe, null, we(i(f), (T, C) => (g(), V("td", { key: C }, [
                $e(He, ke(Pe(i(v))), null, 16)
              ]))), 128))
            ]))), 128))
          ])
        ]),
        i(h) ? x($.$slots, "tfoot", { key: 1 }, () => [
          X("tfoot", null, [
            X("tr", null, [
              (g(!0), V(fe, null, we(i(b), (w, A) => (g(), V("th", { key: A }, [
                $e(He, ke(Pe(i(p))), null, 16)
              ]))), 128))
            ])
          ])
        ]) : J("", !0)
      ]),
      _: 3
    }));
  }
}), Tc = /* @__PURE__ */ H({
  __name: "BPlaceholderWrapper",
  props: {
    loading: { default: !1 }
  },
  setup(e) {
    const a = c(d(e, "loading"));
    return (l, o) => i(a) ? x(l.$slots, "loading", { key: 0 }) : x(l.$slots, "default", { key: 1 });
  }
}), _c = ["aria-valuenow", "aria-valuemax"], On = /* @__PURE__ */ H({
  __name: "BProgressBar",
  props: {
    animated: { default: !1 },
    label: { default: void 0 },
    labelHtml: { default: void 0 },
    max: { default: void 0 },
    precision: { default: 0 },
    showProgress: { default: !1 },
    showValue: { default: !1 },
    striped: { default: !1 },
    value: { default: 0 },
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = Ie($o, null), l = c(d(t, "animated")), o = c(d(t, "showProgress")), n = c(d(t, "showValue")), r = c(d(t, "striped")), s = u(() => ({
      "progress-bar-animated": l.value || (a == null ? void 0 : a.animated.value),
      "progress-bar-striped": r.value || (a == null ? void 0 : a.striped.value) || l.value || (a == null ? void 0 : a.animated.value),
      [`bg-${t.variant}`]: t.variant !== void 0
    })), f = u(
      () => typeof t.precision == "number" ? t.precision : Number.parseFloat(t.precision)
    ), m = u(
      () => typeof t.value == "number" ? t.value : Number.parseFloat(t.value)
    ), y = u(
      () => typeof t.max == "number" ? t.max : t.max === void 0 ? void 0 : Number.parseFloat(t.max)
    ), b = u(
      () => t.labelHtml !== void 0 ? t.labelHtml : n.value || a != null && a.showValue.value ? m.value.toFixed(f.value) : o.value || a != null && a.showProgress.value ? (m.value * 100 / (y.value || 100)).toFixed(f.value) : t.label !== void 0 ? t.label : ""
    ), v = u(
      () => a != null && a.max.value ? `${m.value * 100 / (typeof a.max.value == "number" ? a.max.value : Number.parseInt(a.max.value))}%` : t.max ? `${m.value * 100 / (typeof t.max == "number" ? t.max : Number.parseInt(t.max))}%` : typeof t.value == "string" ? t.value : `${t.value}%`
    );
    return (B, p) => (g(), V("div", {
      class: j(["progress-bar", i(s)]),
      role: "progressbar",
      "aria-valuenow": e.value,
      "aria-valuemin": "0",
      "aria-valuemax": e.max,
      style: je({ width: i(v) })
    }, [
      x(B.$slots, "default", {}, () => [
        ie(Y(i(b)), 1)
      ])
    ], 14, _c));
  }
}), xc = /* @__PURE__ */ H({
  __name: "BProgress",
  props: {
    variant: { default: void 0 },
    max: { default: void 0 },
    height: { default: void 0 },
    animated: { default: !1 },
    precision: { default: 0 },
    showProgress: { default: !1 },
    showValue: { default: !1 },
    striped: { default: !1 },
    value: { default: 0 }
  },
  setup(e) {
    const t = e, a = c(d(t, "animated")), l = c(d(t, "showProgress")), o = c(d(t, "showValue")), n = c(d(t, "striped")), r = u(() => ({
      animated: t.animated,
      max: t.max,
      precision: t.precision,
      showProgress: t.showProgress,
      showValue: t.showValue,
      striped: t.striped,
      value: t.value,
      variant: t.variant
    }));
    return Qe($o, {
      animated: a,
      max: Se(d(t, "max")),
      showProgress: l,
      showValue: o,
      striped: n
    }), (s, f) => (g(), V("div", {
      class: "progress",
      style: je({ height: e.height })
    }, [
      x(s.$slots, "default", {}, () => [
        $e(On, ke(Pe(i(r))), null, 16)
      ])
    ], 4));
  }
}), Ml = ca("cols", [""], { type: [String, Number], default: null }), Ac = H({
  name: "BRow",
  props: {
    tag: { type: String, default: "div" },
    gutterX: { type: String, default: null },
    gutterY: { type: String, default: null },
    noGutters: { type: [Boolean, String], default: !1 },
    alignV: { type: String, default: null },
    alignH: { type: String, default: null },
    alignContent: { type: String, default: null },
    ...Ml
  },
  setup(e) {
    const t = c(d(e, "noGutters")), a = Ht(d(e, "alignH")), l = u(() => bo(e, Ml, "cols", "row-cols"));
    return {
      computedClasses: u(() => [
        l.value,
        {
          [`gx-${e.gutterX}`]: e.gutterX !== null,
          [`gy-${e.gutterY}`]: e.gutterY !== null,
          "g-0": t.value,
          [`align-items-${e.alignV}`]: e.alignV !== null,
          [a.value]: e.alignH !== null,
          [`align-content-${e.alignContent}`]: e.alignContent !== null
        }
      ])
    };
  }
});
function Vc(e, t, a, l, o, n) {
  return g(), D(le(e.tag), {
    class: j(["row", e.computedClasses])
  }, {
    default: q(() => [
      x(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
const Pc = /* @__PURE__ */ ze(Ac, [["render", Vc]]), Dl = [
  "ar",
  "az",
  "ckb",
  "fa",
  "he",
  "ks",
  "lrc",
  "mzn",
  "ps",
  "sd",
  "te",
  "ug",
  "ur",
  "yi"
].map((e) => e.toLowerCase()), Oc = (e) => {
  const t = Jt(e).toLowerCase().replace(as, "").split("-"), a = t.slice(0, 2).join("-"), [l] = t;
  return Dl.includes(a) || Dl.includes(l);
}, Ec = (e) => vs ? Ba(e) ? e : { capture: !!e || !1 } : !!(Ba(e) ? e.capture : e), Ic = (e, t, a, l) => {
  e && e.addEventListener && e.addEventListener(t, a, Ec(l));
}, Fc = (e, t, a, l) => {
  e && e.removeEventListener && e.removeEventListener(t, a, l);
}, jl = (e, t) => {
  (e ? Ic : Fc)(...t);
}, Gt = (e, { preventDefault: t = !0, propagation: a = !0, immediatePropagation: l = !1 } = {}) => {
  t && e.preventDefault(), a && e.stopPropagation(), l && e.stopImmediatePropagation();
}, Fa = "ArrowDown", En = "End", In = "Home", Fn = "PageDown", Ln = "PageUp", La = "ArrowUp", ql = 1, Gl = 100, Wl = 1, Ul = 500, Xl = 100, Kl = 10, Jl = 4, Yl = [La, Fa, In, En, Ln, Fn], Lc = H({
  props: {
    ariaControls: { type: String, default: void 0 },
    ariaLabel: { type: String, default: void 0 },
    labelIncrement: { type: String, default: "Increment" },
    labelDecrement: { type: String, default: "Decrement" },
    modelValue: { type: Number, default: null },
    // V-model prop
    name: { type: String, default: "BFormSpinbutton" },
    disabled: { type: [Boolean, String], default: !1 },
    placeholder: { type: String, default: void 0 },
    locale: { type: String, default: "locale" },
    form: { type: String, default: void 0 },
    inline: { type: Boolean, default: !1 },
    size: { type: String, default: void 0 },
    formatterFn: {
      type: Function,
      default: void 0
    },
    readonly: { type: Boolean, default: !1 },
    vertical: { type: Boolean, default: !1 },
    repeatDelay: {
      type: [String, Number],
      default: Ul
    },
    repeatInterval: {
      type: [String, Number],
      default: Xl
    },
    repeatStepMultiplier: {
      type: [String, Number],
      default: Jl
    },
    repeatThreshold: {
      type: [String, Number],
      default: Kl
    },
    required: { type: [Boolean, String], default: !1 },
    step: { type: [String, Number], default: Wl },
    min: { type: [String, Number], default: ql },
    max: { type: [String, Number], default: Gl },
    wrap: { type: Boolean, default: !1 },
    state: { type: [Boolean, String], default: null }
  },
  emits: ["update:modelValue", "change"],
  setup(e, { emit: t }) {
    const a = xe(e, "modelValue", t), l = z(!1), o = u(() => 1), n = () => {
      t("change", s.value);
    }, r = z(null), s = u({
      get: () => a.value === null ? r.value : a.value,
      set: (R) => {
        a.value === null ? r.value = R : a.value = R;
      }
    });
    let f, m, y = !1;
    const b = u(() => At(e.step, Wl)), v = u(() => At(e.min, ql)), B = u(() => {
      const R = At(e.max, Gl), U = b.value, pe = v.value;
      return Math.floor((R - pe) / U) * U + pe;
    }), p = u(() => {
      const R = ot(e.repeatDelay, 0);
      return R > 0 ? R : Ul;
    }), S = u(() => {
      const R = ot(e.repeatInterval, 0);
      return R > 0 ? R : Xl;
    }), h = u(
      () => Math.max(ot(e.repeatThreshold, Kl), 1)
    ), $ = u(
      () => Math.max(ot(e.repeatStepMultiplier, Jl), 1)
    ), k = u(() => {
      const R = b.value;
      return Math.floor(R) === R ? 0 : (R.toString().split(".")[1] || "").length;
    }), w = u(() => Math.pow(10, k.value || 0)), A = u(() => {
      const { value: R } = s;
      return R === null ? "" : R.toFixed(k.value);
    }), T = u(() => {
      const R = [e.locale];
      return new Intl.NumberFormat(R).resolvedOptions().locale;
    }), C = u(
      () => (
        //todo
        Oc(T.value)
      )
    ), I = () => {
      const R = k.value;
      return new Intl.NumberFormat(T.value, {
        style: "decimal",
        useGrouping: !1,
        minimumIntegerDigits: 1,
        minimumFractionDigits: R,
        maximumFractionDigits: R,
        notation: "standard"
      }).format;
    }, O = u(() => e.formatterFn ?? I()), F = u(() => ({
      role: "group",
      lang: T.value,
      tabindex: e.disabled ? null : "-1",
      title: e.ariaLabel
    })), _ = u(() => a.value !== null || r.value !== null), P = u(() => ({
      dir: C.value,
      spinId: o.value,
      tabindex: e.disabled ? null : "0",
      role: "spinbutton",
      "aria-live": "off",
      "aria-label": e.ariaLabel || null,
      "aria-controls": e.ariaControls || null,
      "aria-invalid": e.state === !1 || !_.value && e.required ? !0 : null,
      "aria-required": e.required ? !0 : null,
      "aria-valuemin": v.value,
      "aria-valuemax": B.value,
      "aria-valuenow": s.value !== null ? s.value : null,
      "aria-valuetext": s.value !== null ? O.value(s.value) : null
    })), L = (R) => {
      let { value: U } = s;
      if (!e.disabled && U !== null) {
        const pe = b.value * R, Q = v.value, ne = B.value, ce = w.value, { wrap: ye } = e;
        U = Math.round((U - Q) / pe) * pe + Q + pe, U = Math.round(U * ce) / ce, s.value = U > ne ? ye ? Q : ne : U < Q ? ye ? ne : Q : U;
      }
    }, N = (R = 1) => {
      s.value === null ? s.value = v.value : L(1 * R);
    }, ee = (R = 1) => {
      s.value === null ? s.value = e.wrap ? B.value : v.value : L(-1 * R);
    }, K = (R) => {
      const { code: U, altKey: pe, ctrlKey: Q, metaKey: ne } = R;
      if (!(e.disabled || e.readonly || pe || Q || ne) && Yl.includes(U)) {
        if (Gt(R, { propagation: !1 }), y)
          return;
        oe(), [La, Fa].includes(U) ? (y = !0, U === La ? ae(R, N) : U === Fa && ae(R, ee)) : U === Ln ? N($.value) : U === Fn ? ee($.value) : U === In ? s.value = v.value : U === En && (s.value = B.value);
      }
    }, G = (R) => {
      const { code: U, altKey: pe, ctrlKey: Q, metaKey: ne } = R;
      e.disabled || e.readonly || pe || Q || ne || Yl.includes(U) && (Gt(R, { propagation: !1 }), oe(), y = !1, n());
    }, ae = (R, U) => {
      const { type: pe } = R || {};
      if (!e.disabled && !e.readonly) {
        if (de(R) && pe === "mousedown" && R.button)
          return;
        oe(), U(1);
        const Q = h.value, ne = $.value, ce = p.value, ye = S.value;
        f = setTimeout(() => {
          let Ae = 0;
          m = setInterval(() => {
            U(Ae < Q ? 1 : ne), Ae++;
          }, ye);
        }, ce);
      }
    };
    function de(R) {
      return R.type === "mouseup" || R.type === "mousedown";
    }
    const he = (R) => {
      de(R) && R.type === "mouseup" && R.button || (Gt(R, { propagation: !1 }), oe(), Be(!1), n());
    }, Be = (R) => {
      try {
        jl(R, [document.body, "mouseup", he, !1]), jl(R, [document.body, "touchend", he, !1]);
      } catch {
        return 0;
      }
    }, oe = () => {
      clearTimeout(f), clearInterval(m), f = void 0, m = void 0;
    }, ve = (R, U, pe, Q, ne, ce, ye) => {
      const Ae = re(pe, {
        props: { scale: l.value ? 1.5 : 1.25 },
        attrs: { "aria-hidden": !0 }
      }), te = { hasFocus: l.value }, ue = (E) => {
        !e.disabled && !e.readonly && (Gt(E, { propagation: !1 }), Be(!0), ae(E, R));
      };
      return re(
        "button",
        {
          class: [{ "py-0": !e.vertical }, "btn", "btn-sm", "border-0", "rounded-0"],
          tabindex: "-1",
          type: "button",
          disabled: e.disabled || e.readonly || ce,
          "aria-disabled": e.disabled || e.readonly || ce ? !0 : null,
          "aria-controls": o.value,
          "aria-label": U || null,
          "aria-keyshortcuts": ne || null,
          onmousedown: ue,
          ontouchstart: ue
          // 'ref': keyRef,
        },
        [Me(ye, te) || Ae]
      );
    };
    return () => {
      const R = ve(
        N,
        e.labelIncrement,
        re(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            width: "16",
            height: "16",
            fill: "currentColor",
            class: "bi bi-plus",
            viewBox: "0 0 16 16"
          },
          re("path", {
            d: "M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"
          })
        ),
        "inc",
        "ArrowUp",
        !1,
        "increment"
      ), U = ve(
        ee,
        e.labelDecrement,
        re(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            width: "16",
            height: "16",
            fill: "currentColor",
            class: "bi bi-dash",
            viewBox: "0 0 16 16"
          },
          re("path", { d: "M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z" })
        ),
        "dec",
        "ArrowDown",
        !1,
        "decrement"
      ), pe = [];
      e.name && !e.disabled && pe.push(
        re("input", {
          type: "hidden",
          name: e.name,
          form: e.form || null,
          // TODO: Should this be set to '' if value is out of range?
          value: A.value,
          key: "hidden"
        })
      );
      const Q = re(
        // We use 'output' element to make this accept a `<label for="id">` (Except IE)
        "output",
        {
          class: [
            { "d-flex": e.vertical },
            { "align-self-center": !e.vertical },
            { "align-items-center": e.vertical },
            { "border-top": e.vertical },
            { "border-bottom": e.vertical },
            { "border-start": !e.vertical },
            { "border-end": !e.vertical },
            "flex-grow-1"
          ],
          ...P.value,
          key: "output"
          // ref: 'spinner',
        },
        [
          re(
            "bdi",
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            //@ts-ignore How can we narrow this type down
            _.value ? O.value(s.value) : e.placeholder || ""
          )
        ]
      );
      return re(
        "div",
        {
          class: [
            "b-form-spinbutton form-control",
            { disabled: e.disabled },
            { readonly: e.readonly },
            { focus: l },
            { "d-inline-flex": e.inline || e.vertical },
            { "d-flex": !e.inline && !e.vertical },
            { "align-items-stretch": !e.vertical },
            { "flex-column": e.vertical },
            e.size ? `form-control-${e.size}` : null
            // this.stateClass //TODO
          ],
          ...F.value,
          onkeydown: K,
          onkeyup: G
          // We use capture phase (`!` prefix) since focus and blur do not bubble
          // 'focus': onFocusBlur, //TODO
          // 'blur': onFocusBlur, //TODO
        },
        e.vertical ? [R, pe, Q, U] : [U, pe, Q, R]
      );
    };
  }
}), Nc = ["TD", "TH", "TR"], zc = [
  "a",
  "a *",
  // Include content inside links
  "button",
  "button *",
  // Include content inside buttons
  "input:not(.disabled):not([disabled])",
  "select:not(.disabled):not([disabled])",
  "textarea:not(.disabled):not([disabled])",
  '[role="link"]',
  '[role="link"] *',
  '[role="button"]',
  '[role="button"] *',
  "[tabindex]:not(.disabled):not([disabled])"
].join(","), Wt = (e) => {
  if (!e || !e.target)
    return !1;
  const t = e.target;
  if ("disabled" in t && t.disabled || Nc.indexOf(t.tagName) !== -1)
    return !1;
  if (nl(".dropdown-menu", t))
    return !0;
  const a = t.tagName === "LABEL" ? t : nl("label", t);
  if (a) {
    const l = Ma(a, "for"), o = l ? ws(l) : po("input, select, textarea", a);
    if (o && !o.disabled)
      return !0;
  }
  return go(t, zc);
}, Rc = () => {
  const e = (m, y) => {
    const b = [];
    return !(m != null && m.length) && (y != null && y.length) ? (Object.keys(y[0]).forEach((v) => b.push({ key: v, label: al(v) })), b) : (Array.isArray(m) && m.forEach((v) => {
      typeof v == "string" ? b.push({ key: v, label: al(v) }) : Ba(v) && v.key && typeof v.key == "string" && b.push({ ...v });
    }), b);
  }, t = z([]), a = (m, y, b, v) => (t.value = Yt(y), "isFilterableTable" in v && v.isFilterableTable.value === !0 && b.filter && (t.value = n(t.value, b.filter, b.filterable)), "isSortable" in v && v.isSortable.value === !0 && (t.value = o(
    m,
    t.value,
    {
      key: b.sortBy,
      desc: v.sortDescBoolean.value
    },
    b.sortCompare
  )), t.value), l = z(void 0), o = (m, y, b, v) => {
    if (!b || !b.key)
      return y;
    const B = b.key;
    return y.sort((p, S) => {
      if (v !== void 0)
        return v(p, S, b.key, b.desc);
      const h = (w) => typeof w == "object" ? JSON.stringify(w) : w;
      return h(p[B]) > h(S[B]) ? b.desc ? -1 : 1 : h(S[B]) > h(p[B]) ? b.desc ? 1 : -1 : 0;
    });
  }, n = (m, y, b) => m.filter(
    (v) => Object.entries(v).filter((B) => {
      const [p, S] = B;
      return !S || p[0] === "_" || b.length > 0 && !b.includes(p) ? !1 : (typeof S == "object" ? JSON.stringify(Object.values(S)) : typeof S == "string" ? S : S.toString()).toLowerCase().includes(y.toLowerCase());
    }).length > 0
  );
  return {
    normaliseFields: e,
    mapItems: a,
    internalItems: t,
    updateInternalItems: async (m) => {
      try {
        return t.value = await wa(m), t.value;
      } catch {
        return;
      }
    },
    filterEvent: l,
    notifyFilteredItems: () => {
      l.value && l.value(t.value);
    },
    formatItem: (m, y) => {
      const b = m[y.key];
      return y.formatter && typeof y.formatter == "function" ? y.formatter(b, y.key, m) : m[y.key];
    }
  };
}, Hc = ["title", "abbr", "onClick"], Mc = { class: "d-inline-flex flex-nowrap align-items-center gap-1" }, Dc = { key: 1 }, jc = ["onClick", "onDblclick", "onMouseenter", "onMouseleave"], qc = {
  key: 0,
  class: "b-table-stacked-label"
}, Gc = ["colspan"], Wc = ["colspan"], Uc = { class: "d-flex align-items-center justify-content-center gap-2" }, Xc = /* @__PURE__ */ X("strong", null, "Loading...", -1), Kc = {
  key: 1,
  class: "b-table-empty-slot"
}, Jc = ["colspan"], Yc = { key: 0 }, Zc = ["title", "abbr", "onClick"], Qc = { key: 1 }, ef = { key: 2 }, tf = { key: 3 }, af = /* @__PURE__ */ H({
  __name: "BTable",
  props: {
    align: { default: void 0 },
    caption: { default: void 0 },
    captionTop: { default: !1 },
    borderless: { default: !1 },
    bordered: { default: !1 },
    borderVariant: { default: void 0 },
    dark: { default: !1 },
    fields: { default: () => [] },
    footClone: { default: !1 },
    hover: { default: !1 },
    items: { default: () => [] },
    provider: { default: void 0 },
    sortCompare: { default: void 0 },
    noProvider: { default: void 0 },
    noProviderPaging: { default: void 0 },
    noProviderSorting: { default: void 0 },
    noProviderFiltering: { default: void 0 },
    responsive: { type: [Boolean, String], default: !1 },
    small: { default: !1 },
    striped: { default: !1 },
    stacked: { type: [Boolean, String], default: !1 },
    labelStacked: { type: Boolean, default: !1 },
    variant: { default: void 0 },
    sortBy: { default: void 0 },
    sortDesc: { default: !1 },
    sortInternal: { default: !0 },
    selectable: { default: !1 },
    stickySelect: { default: !1 },
    selectHead: { type: [Boolean, String], default: !0 },
    selectMode: { default: "single" },
    selectionVariant: { default: "primary" },
    stickyHeader: { default: !1 },
    busy: { default: !1 },
    showEmpty: { default: !1 },
    perPage: { default: void 0 },
    currentPage: { default: 1 },
    filter: { default: void 0 },
    filterable: { default: void 0 },
    emptyText: { default: "There are no records to show" },
    emptyFilteredText: { default: "There are no records matching your request" }
  },
  emits: ["headClicked", "rowClicked", "rowDblClicked", "rowHovered", "rowUnhovered", "rowSelected", "rowUnselected", "selection", "update:busy", "update:sortBy", "update:sortDesc", "sorted", "filtered"],
  setup(e, { expose: t, emit: a }) {
    const l = e, o = Fe(), n = Rc(), r = c(d(l, "footClone")), s = c(d(l, "sortDesc")), f = c(d(l, "sortInternal")), m = c(d(l, "selectable")), y = c(d(l, "stickySelect")), b = c(d(l, "labelStacked")), v = c(d(l, "busy")), B = c(d(l, "showEmpty")), p = c(d(l, "noProviderPaging")), S = c(d(l, "noProviderSorting")), h = c(d(l, "noProviderFiltering")), $ = z(v.value);
    n.filterEvent.value = async (E) => {
      if (F.value) {
        await R();
        return;
      }
      const W = await wa(E);
      a("filtered", W);
    };
    const k = z(/* @__PURE__ */ new Set([])), w = u(() => k.value.size > 0), A = u(() => ({
      [`align-${l.align}`]: l.align !== void 0,
      "b-table-selectable": m.value,
      [`b-table-select-${l.selectMode}`]: m.value,
      "b-table-selecting user-select-none": m.value && w.value,
      "b-table-busy": $.value,
      "b-table-sortable": P.value,
      "b-table-sort-desc": P.value && s.value === !0,
      "b-table-sort-asc": P.value && s.value === !1
    })), T = u(() => ({
      bordered: l.bordered,
      borderless: l.borderless,
      borderVariant: l.borderVariant,
      captionTop: l.captionTop,
      dark: l.dark,
      hover: l.hover,
      responsive: l.responsive,
      striped: l.striped,
      stacked: l.stacked,
      small: l.small,
      tableClass: A.value,
      tableVariant: l.variant,
      stickyHeader: l.stickyHeader
    })), C = u(() => n.normaliseFields(l.fields, l.items)), I = u(
      () => C.value.length + (m.value ? 1 : 0)
    ), O = u(() => l.filter !== void 0 && l.filter !== ""), F = u(() => l.provider !== void 0), _ = u(
      () => m.value && (!!l.selectHead || o.selectHead !== void 0)
    ), P = u(
      () => l.fields.filter((E) => typeof E == "string" ? !1 : E.sortable).length > 0
    ), L = u(() => P.value && f.value === !0), N = u(() => {
      const E = F.value ? n.internalItems.value : L.value ? n.mapItems(l.fields, l.items, l, {
        isSortable: P,
        isFilterableTable: O,
        sortDescBoolean: s
      }) : l.items;
      if (l.perPage !== void 0) {
        const W = (l.currentPage - 1) * l.perPage, ge = W + l.perPage > E.length ? E.length : W + l.perPage;
        return E.slice(W, ge);
      }
      return E;
    }), ee = (E) => typeof E == "string" ? ll(E) : E.label !== void 0 ? E.label : typeof E.key == "string" ? ll(E.key) : E.key, K = (E, W, ge = !1) => {
      const M = typeof E == "string" ? E : E.key;
      a("headClicked", M, E, W, ge), Be(E);
    }, G = (E, W, ge) => {
      a("rowClicked", E, W, ge), ve(E, W, ge.shiftKey);
    }, ae = (E, W, ge) => a("rowDblClicked", E, W, ge), de = (E, W, ge) => a("rowHovered", E, W, ge), he = (E, W, ge) => a("rowUnhovered", E, W, ge), Be = (E) => {
      if (!P.value)
        return;
      const W = typeof E == "string" ? E : E.key, ge = typeof E == "string" ? !1 : E.sortable;
      if (P.value === !0 && ge === !0) {
        const M = !s.value;
        W !== l.sortBy && a("update:sortBy", W), a("update:sortDesc", M), a("sorted", W, M);
      }
    }, oe = () => {
      m.value && a("selection", Array.from(k.value));
    }, ve = (E, W, ge = !1) => {
      if (m.value) {
        if (k.value.has(E))
          k.value.delete(E), a("rowUnselected", E);
        else if (l.selectMode === "single" && k.value.size > 0 && (k.value.forEach((M) => a("rowUnselected", M)), k.value.clear()), l.selectMode === "range" && k.value.size > 0 && ge) {
          const M = Array.from(k.value).pop(), me = N.value.findIndex((rt) => rt === M), be = Math.min(me, W), ga = Math.max(me, W);
          N.value.slice(be, ga + 1).forEach((rt) => {
            k.value.has(rt) || (k.value.add(rt), a("rowSelected", rt));
          });
        } else
          k.value.add(E), a("rowSelected", E);
        oe();
      }
    }, R = async () => {
      if (!F.value || !l.provider || $.value)
        return;
      $.value = !0;
      const E = new Proxy(
        {
          currentPage: l.currentPage,
          filter: l.filter,
          sortBy: l.sortBy,
          sortDesc: l.sortDesc,
          perPage: l.perPage
        },
        {
          get: (ge, M) => M in ge ? ge[M] : void 0,
          set: () => (console.error("BTable provider context is a read-only object."), !0)
        }
      ), W = l.provider(E, n.updateInternalItems);
      if (W !== void 0) {
        if (W instanceof Promise)
          try {
            const ge = await W;
            return Array.isArray(ge) ? await n.updateInternalItems(ge) : void 0;
          } finally {
            $.value && ($.value = !1);
          }
        try {
          return await n.updateInternalItems(W);
        } finally {
          $.value && ($.value = !1);
        }
      }
    }, U = (E) => {
      E._showDetails = !E._showDetails;
    }, pe = (E) => [
      E.class,
      E.thClass,
      E.variant ? `table-${E.variant}` : void 0,
      {
        "b-table-sortable-column": P.value && E.sortable,
        "b-table-sticky-column": E.stickyColumn
      }
    ], Q = (E, W) => [
      E.class,
      E.tdClass,
      E.variant ? `table-${E.variant}` : void 0,
      W != null && W._cellVariants && (W != null && W._cellVariants[E.key]) ? `table-${W == null ? void 0 : W._cellVariants[E.key]}` : void 0,
      {
        "b-table-sticky-column": E.stickyColumn
      }
    ], ne = (E) => [
      E._rowVariant ? `table-${E._rowVariant}` : null,
      E._rowVariant ? `table-${E._rowVariant}` : null,
      m.value && k.value.has(E) ? `selected table-${l.selectionVariant}` : null
    ], ce = () => {
      if (!m.value)
        return;
      const E = k.value.size > 0 ? Array.from(k.value) : [];
      k.value = /* @__PURE__ */ new Set([...N.value]), k.value.forEach((W) => {
        E.includes(W) || a("rowSelected", W);
      }), oe();
    }, ye = () => {
      m.value && (k.value.forEach((E) => {
        a("rowUnselected", E);
      }), k.value = /* @__PURE__ */ new Set([]), oe());
    }, Ae = (E) => {
      if (!m.value)
        return;
      const W = N.value[E];
      !W || k.value.has(W) || (k.value.add(W), a("rowSelected", W), oe());
    }, te = (E) => {
      if (!m.value)
        return;
      const W = N.value[E];
      !W || !k.value.has(W) || (k.value.delete(W), a("rowUnselected", W), oe());
    }, ue = async (E, W, ge) => {
      if (W === ge)
        return;
      const M = (Nn) => l.noProvider && l.noProvider.includes(Nn), me = !["currentPage", "perPage"].includes(E), be = ["currentPage", "perPage"].includes(E) && (M("paging") || p.value === !0), ga = ["filter"].includes(E) && (M("filtering") || h.value === !0), rt = ["sortBy", "sortDesc"].includes(E) && (M("sorting") || S.value === !0);
      be || ga || rt || (await R(), me && n.notifyFilteredItems());
    };
    return se(
      () => l.filter,
      (E, W) => {
        E === W || F.value || E || wa(l.items).then((ge) => a("filtered", ge));
      }
    ), se(
      $,
      () => $.value !== v.value && a("update:busy", $.value)
    ), se(
      v,
      () => $.value !== v.value && ($.value = v.value)
    ), se(
      () => l.filter,
      (E, W) => ue("filter", E, W)
    ), se(
      () => l.currentPage,
      (E, W) => ue("currentPage", E, W)
    ), se(
      () => l.perPage,
      (E, W) => ue("perPage", E, W)
    ), se(
      () => l.sortBy,
      (E, W) => ue("sortBy", E, W)
    ), se(
      () => l.sortDesc,
      (E, W) => ue("sortDesc", E, W)
    ), Xe(() => {
      F.value && R();
    }), t({
      selectAllRows: ce,
      clearSelected: ye,
      selectRow: Ae,
      unselectRow: te,
      refresh: R
    }), (E, W) => (g(), D(tl, ke(Pe(i(T))), {
      default: q(() => {
        var ge;
        return [
          X("thead", null, [
            E.$slots["thead-top"] ? x(E.$slots, "thead-top", { key: 0 }) : J("", !0),
            X("tr", null, [
              i(_) ? (g(), V("th", {
                key: 0,
                class: j(["b-table-selection-column", {
                  "b-table-sticky-column": i(y)
                }])
              }, [
                x(E.$slots, "select-head", {}, () => [
                  ie(Y(typeof e.selectHead == "boolean" ? "Selected" : e.selectHead), 1)
                ])
              ], 2)) : J("", !0),
              (g(!0), V(fe, null, we(i(C), (M) => (g(), V("th", Z({
                key: M.key,
                scope: "col",
                class: pe(M),
                title: M.headerTitle,
                abbr: M.headerAbbr,
                style: M.thStyle
              }, M.thAttr, {
                onClick: (me) => K(M, me)
              }), [
                X("div", Mc, [
                  x(E.$slots, "sort-icon", {
                    field: M,
                    sortBy: e.sortBy,
                    selected: M.key === e.sortBy,
                    isDesc: i(s),
                    direction: i(s) ? "desc" : "asc"
                  }, () => [
                    i(P) && M.sortable ? (g(), V("span", {
                      key: 0,
                      class: j(["b-table-sort-icon", {
                        sorted: M.key === e.sortBy,
                        [`sorted-${i(s) ? "desc" : "asc"}`]: M.key === e.sortBy
                      }])
                    }, null, 2)) : J("", !0)
                  ]),
                  X("div", null, [
                    E.$slots["head(" + M.key + ")"] || E.$slots["head()"] ? x(E.$slots, E.$slots["head(" + M.key + ")"] ? "head(" + M.key + ")" : "head()", {
                      key: 0,
                      label: M.label
                    }) : (g(), V(fe, { key: 1 }, [
                      ie(Y(ee(M)), 1)
                    ], 64))
                  ])
                ])
              ], 16, Hc))), 128))
            ]),
            E.$slots["thead-sub"] ? (g(), V("tr", Dc, [
              (g(!0), V(fe, null, we(i(C), (M) => (g(), V("td", {
                key: M.key,
                scope: "col",
                class: j([M.class, M.thClass, M.variant ? `table-${M.variant}` : ""])
              }, [
                E.$slots["thead-sub"] ? x(E.$slots, "thead-sub", Z({
                  key: 0,
                  items: i(C)
                }, M)) : (g(), V(fe, { key: 1 }, [
                  ie(Y(M.label), 1)
                ], 64))
              ], 2))), 128))
            ])) : J("", !0)
          ]),
          X("tbody", null, [
            (g(!0), V(fe, null, we(i(N), (M, me) => (g(), V(fe, { key: me }, [
              X("tr", {
                class: j(ne(M)),
                onClick: (be) => !i(Wt)(be) && G(M, me, be),
                onDblclick: (be) => !i(Wt)(be) && ae(M, me, be),
                onMouseenter: (be) => !i(Wt)(be) && de(M, me, be),
                onMouseleave: (be) => !i(Wt)(be) && he(M, me, be)
              }, [
                i(_) ? (g(), V("td", {
                  key: 0,
                  class: j(["b-table-selection-column", {
                    "b-table-sticky-column": i(y)
                  }])
                }, [
                  x(E.$slots, "select-cell", {}, () => [
                    X("span", {
                      class: j(k.value.has(M) ? "text-primary" : "")
                    }, "ð¹", 2)
                  ])
                ], 2)) : J("", !0),
                (g(!0), V(fe, null, we(i(C), (be) => (g(), V("td", Z({
                  key: be.key
                }, be.tdAttr, {
                  class: Q(be, M)
                }), [
                  e.stacked && i(b) ? (g(), V("label", qc, Y(ee(be)), 1)) : J("", !0),
                  E.$slots["cell(" + be.key + ")"] || E.$slots["cell()"] ? x(E.$slots, E.$slots["cell(" + be.key + ")"] ? "cell(" + be.key + ")" : "cell()", {
                    key: 1,
                    value: M[be.key],
                    index: me,
                    item: M,
                    field: be,
                    items: e.items,
                    toggleDetails: () => U(M),
                    detailsShowing: M._showDetails
                  }) : (g(), V(fe, { key: 2 }, [
                    ie(Y(i(n).formatItem(M, be)), 1)
                  ], 64))
                ], 16))), 128))
              ], 42, jc),
              M._showDetails === !0 && E.$slots["row-details"] ? (g(), V("tr", {
                key: 0,
                class: j(ne(M))
              }, [
                X("td", { colspan: i(I) }, [
                  x(E.$slots, "row-details", {
                    item: M,
                    toggleDetails: () => U(M)
                  })
                ], 8, Gc)
              ], 2)) : J("", !0)
            ], 64))), 128)),
            $.value ? (g(), V("tr", {
              key: 0,
              class: j(["b-table-busy-slot", { "b-table-static-busy": i(N).length === 0 }])
            }, [
              X("td", { colspan: i(I) }, [
                x(E.$slots, "table-busy", {}, () => [
                  X("div", Uc, [
                    $e(pa, { class: "align-middle" }),
                    Xc
                  ])
                ])
              ], 8, Wc)
            ], 2)) : J("", !0),
            i(B) && i(N).length === 0 ? (g(), V("tr", Kc, [
              X("td", { colspan: i(I) }, [
                x(E.$slots, "empty", {
                  items: i(N),
                  filtered: i(O)
                }, () => [
                  ie(Y(i(O) ? e.emptyFilteredText : e.emptyText), 1)
                ])
              ], 8, Jc)
            ])) : J("", !0)
          ]),
          i(r) ? (g(), V("tfoot", Yc, [
            X("tr", null, [
              (g(!0), V(fe, null, we(i(C), (M) => (g(), V("th", Z({
                key: M.key
              }, M.thAttr, {
                scope: "col",
                class: [M.class, M.thClass, M.variant ? `table-${M.variant}` : ""],
                title: M.headerTitle,
                abbr: M.headerAbbr,
                style: M.thStyle,
                onClick: (me) => K(M, me, !0)
              }), Y(M.label), 17, Zc))), 128))
            ])
          ])) : E.$slots["custom-foot"] ? (g(), V("tfoot", Qc, [
            x(E.$slots, "custom-foot", {
              fields: i(C),
              items: e.items,
              columns: (ge = i(C)) == null ? void 0 : ge.length
            })
          ])) : J("", !0),
          E.$slots["table-caption"] ? (g(), V("caption", ef, [
            x(E.$slots, "table-caption")
          ])) : e.caption ? (g(), V("caption", tf, Y(e.caption), 1)) : J("", !0)
        ];
      }),
      _: 3
    }, 16));
  }
}), lf = /* @__PURE__ */ H({
  __name: "BTbody",
  props: {
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = u(() => ({
      [`thead-${t.variant}`]: t.variant !== void 0
    }));
    return (l, o) => (g(), V("tbody", {
      class: j(i(a))
    }, [
      x(l.$slots, "default")
    ], 2));
  }
}), of = ["scope", "colspan", "rowspan", "data-label"], nf = { key: 0 }, sf = /* @__PURE__ */ H({
  __name: "BTd",
  props: {
    colspan: { default: void 0 },
    rowspan: { default: void 0 },
    stackedHeading: { default: void 0 },
    stickyColumn: { default: !1 },
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = c(d(t, "stickyColumn")), l = u(() => ({
      [`table-${t.variant}`]: t.variant !== void 0,
      "b-table-sticky-column": a.value,
      "table-b-table-default": a.value && t.variant === void 0
    })), o = u(() => t.colspan ? "colspan" : t.rowspan ? "rowspan" : "col");
    return (n, r) => (g(), V("td", {
      scope: i(o),
      class: j(i(l)),
      colspan: e.colspan,
      rowspan: e.rowspan,
      "data-label": e.stackedHeading
    }, [
      e.stackedHeading ? (g(), V("div", nf, [
        x(n.$slots, "default")
      ])) : x(n.$slots, "default", { key: 1 })
    ], 10, of));
  }
}), rf = /* @__PURE__ */ H({
  __name: "BTfoot",
  props: {
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = u(() => ({
      [`table-${t.variant}`]: t.variant !== void 0
    }));
    return (l, o) => (g(), V("tfoot", {
      class: j(i(a))
    }, [
      x(l.$slots, "default")
    ], 2));
  }
}), uf = ["scope", "colspan", "rowspan", "data-label"], df = { key: 0 }, cf = /* @__PURE__ */ H({
  __name: "BTh",
  props: {
    colspan: { default: void 0 },
    rowspan: { default: void 0 },
    stackedHeading: { default: void 0 },
    stickyColumn: { default: !1 },
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = c(d(t, "stickyColumn")), l = u(() => ({
      [`table-${t.variant}`]: t.variant !== void 0,
      "b-table-sticky-column": a.value,
      "table-b-table-default": a.value && t.variant === void 0
    })), o = u(() => t.colspan ? "colspan" : t.rowspan ? "rowspan" : "col");
    return (n, r) => (g(), V("th", {
      scope: i(o),
      class: j(i(l)),
      colspan: e.colspan,
      rowspan: e.rowspan,
      "data-label": e.stackedHeading
    }, [
      e.stackedHeading !== void 0 ? (g(), V("div", df, [
        x(n.$slots, "default")
      ])) : x(n.$slots, "default", { key: 1 })
    ], 10, uf));
  }
}), ff = /* @__PURE__ */ H({
  __name: "BThead",
  props: {
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = u(() => ({
      [`table-${t.variant}`]: t.variant !== void 0
    }));
    return (l, o) => (g(), V("thead", {
      class: j(i(a))
    }, [
      x(l.$slots, "default")
    ], 2));
  }
}), vf = /* @__PURE__ */ H({
  __name: "BTr",
  props: {
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = u(() => ({
      [`table-${t.variant}`]: t.variant !== void 0
    }));
    return (l, o) => (g(), V("tr", {
      class: j(i(a))
    }, [
      x(l.$slots, "default")
    ], 2));
  }
}), mf = /* @__PURE__ */ H({
  __name: "BTab",
  props: {
    id: { default: void 0 },
    title: { default: void 0 },
    active: { default: !1 },
    buttonId: { default: void 0 },
    disabled: { default: !1 },
    lazy: { default: void 0 },
    lazyOnce: { default: void 0 },
    noBody: { type: [Boolean, String], default: !1 },
    tag: { default: "div" },
    titleItemClass: { default: void 0 },
    titleLinkAttributes: { default: void 0 },
    titleLinkClass: { default: void 0 }
  },
  setup(e) {
    const t = e, a = Ie(yo, null), l = c(d(t, "active")), o = c(d(t, "disabled")), n = c(d(t, t.lazyOnce !== void 0 ? "lazyOnce" : "lazy")), r = z(!1), s = u(() => !!(a != null && a.lazy.value || n.value)), f = u(() => t.lazyOnce !== void 0), m = u(() => l.value && !o.value), y = u(() => {
      const B = s.value && f.value && r.value;
      return m.value || !s.value || B;
    }), b = z(l.value);
    se(l, (B) => {
      setTimeout(() => {
        b.value = B;
      }, 0);
    });
    const v = u(() => ({
      active: l.value,
      show: b.value,
      "card-body": (a == null ? void 0 : a.card.value) && t.noBody === !1
    }));
    return se(y, (B) => {
      B && !r.value && (r.value = !0);
    }), (B, p) => (g(), D(le(e.tag), {
      id: e.id,
      class: j(["tab-pane", i(v)]),
      role: "tabpanel",
      "aria-labelledby": "profile-tab"
    }, {
      default: q(() => [
        i(y) ? x(B.$slots, "default", { key: 0 }) : J("", !0)
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), pf = ["id", "data-bs-target", "aria-controls", "aria-selected", "onClick"], gf = /* @__PURE__ */ H({
  __name: "BTabs",
  props: {
    activeNavItemClass: { default: void 0 },
    activeTabClass: { default: void 0 },
    align: { default: void 0 },
    contentClass: { default: void 0 },
    card: { default: !1 },
    end: { default: !1 },
    fill: { default: !1 },
    id: { default: void 0 },
    justified: { default: !1 },
    lazy: { default: !1 },
    navClass: { default: void 0 },
    navWrapperClass: { default: void 0 },
    noFade: { default: !1 },
    noNavStyle: { default: !1 },
    pills: { default: !1 },
    small: { default: !1 },
    tag: { default: "div" },
    vertical: { default: !1 },
    modelValue: { default: -1 }
  },
  emits: ["update:modelValue", "activate-tab", "click"],
  setup(e, { emit: t }) {
    const a = e, l = xe(a, "modelValue", t), o = Fe(), n = c(d(a, "card")), r = c(d(a, "end")), s = c(d(a, "fill")), f = c(d(a, "justified")), m = c(d(a, "lazy")), y = c(d(a, "noFade")), b = c(d(a, "noNavStyle")), v = c(d(a, "pills")), B = c(d(a, "small")), p = c(d(a, "vertical")), S = z(l.value), h = z(""), $ = u({
      get: () => S.value,
      set: (_) => {
        S.value = _, w.value.length > 0 && _ >= 0 && _ < w.value.length ? h.value = w.value[_].buttonId : h.value = "", l.value = _;
      }
    }), k = z([]);
    se(
      () => {
        var _;
        return (_ = o.default) == null ? void 0 : _.call(o);
      },
      () => {
        k.value = o.default === void 0 ? [] : ka(o.default, "BTab").map((_, P) => {
          _.props || (_.props = {});
          const L = _.props["button-id"] || lt("tab"), N = _.props.id || lt(), ee = _.props["title-item-class"], K = _.props["title-link-attributes"];
          return {
            buttonId: L,
            contentId: N,
            disabled: _.props.disabled === "" || _.props.disabled === !0,
            target: `#${N}`,
            title: _.props.title,
            titleItemClass: ee,
            titleLinkAttributes: K,
            onClick: _.props.onClick,
            tab: _,
            tabComponent: () => ka(o.default, "BTab")[P]
          };
        });
      },
      { immediate: !0 }
    );
    const w = u(
      () => k.value.map((_, P) => {
        const { tab: L } = _;
        L.props || (L.props = {});
        const N = $.value > -1 ? P === $.value : L.props.active === "";
        return {
          ..._,
          active: N,
          navItemClasses: [
            {
              active: N,
              disabled: L.props.disabled === "" || L.props.disabled === !0
            },
            N && a.activeNavItemClass ? a.activeNavItemClass : null,
            L.props["title-link-class"]
          ],
          tabClasses: [
            {
              fade: !y.value
            },
            N && a.activeTabClass ? a.activeTabClass : null
          ]
        };
      })
    ), A = u(() => !(w != null && w.value && w.value.length > 0)), T = u(() => ({
      "d-flex": p.value,
      "align-items-start": p.value
    })), C = Ht(d(a, "align")), I = u(() => ({
      "nav-pills": v.value,
      "flex-column me-3": p.value,
      [C.value]: a.align !== void 0,
      "nav-fill": s.value,
      "card-header-tabs": n.value,
      "nav-justified": f.value,
      "nav-tabs": !b.value && !v.value,
      small: B.value
    })), O = (_) => {
      let P = !1;
      if (_ !== void 0 && _ > -1 && _ < w.value.length && !w.value[_].disabled && ($.value < 0 || w.value[_].buttonId !== h.value)) {
        const L = new Ze("activate-tab", { cancelable: !0 });
        t("activate-tab", _, $.value, L), L.defaultPrevented || ($.value = _, P = !0);
      }
      return !P && l.value !== $.value && (l.value = $.value), P;
    }, F = (_, P) => {
      var L;
      O(P), P >= 0 && !w.value[P].disabled && ((L = w.value[P]) != null && L.onClick) && typeof w.value[P].onClick == "function" && w.value[P].onClick(_);
    };
    return O(S.value), se(l, (_, P) => {
      if (_ === P)
        return;
      if (_ = Math.max(_, -1), P = Math.max(P, -1), w.value.length <= 0) {
        $.value = -1;
        return;
      }
      const L = _ > P;
      let N = _;
      const ee = w.value.length - 1;
      for (; N >= 0 && N <= ee && w.value[N].disabled; )
        N += L ? 1 : -1;
      if (N < 0) {
        O(0);
        return;
      }
      if (N >= w.value.length) {
        O(w.value.length - 1);
        return;
      }
      O(N);
    }), se(w, () => {
      let _ = w.value.map((P) => P.active && !P.disabled).lastIndexOf(!0);
      _ < 0 && ($.value >= w.value.length ? _ = w.value.map((P) => !P.disabled).lastIndexOf(!0) : w.value[$.value] && !w.value[$.value].disabled && (_ = $.value)), _ < 0 && (_ = w.value.map((P) => !P.disabled).indexOf(!0)), w.value.forEach((P, L) => P.active = L === _), O(_);
    }), Xe(() => {
      if ($.value < 0 && w.value.length > 0 && !w.value.some((_) => _.active)) {
        const _ = w.value.map((P) => !P.disabled).indexOf(!0);
        O(_ >= 0 ? _ : -1);
      }
    }), Qe(yo, {
      lazy: m,
      card: n
    }), (_, P) => (g(), D(le(e.tag), {
      id: e.id,
      class: j(["tabs", i(T)])
    }, {
      default: q(() => [
        i(r) ? (g(), V("div", {
          key: 0,
          class: j(["tab-content", e.contentClass])
        }, [
          (g(!0), V(fe, null, we(i(w), ({ tabComponent: L, contentId: N, tabClasses: ee, active: K }, G) => (g(), D(le(L()), {
            id: N,
            key: G,
            class: j(ee),
            active: K
          }, null, 8, ["id", "class", "active"]))), 128)),
          i(A) ? (g(), V("div", {
            key: "bv-empty-tab",
            class: j(["tab-pane active", { "card-body": i(n) }])
          }, [
            x(_.$slots, "empty")
          ], 2)) : J("", !0)
        ], 2)) : J("", !0),
        X("div", {
          class: j([e.navWrapperClass, { "card-header": i(n), "ms-auto": e.vertical && i(r) }])
        }, [
          X("ul", {
            class: j(["nav", [i(I), e.navClass]]),
            role: "tablist"
          }, [
            x(_.$slots, "tabs-start"),
            (g(!0), V(fe, null, we(i(w), ({ tab: L, buttonId: N, contentId: ee, navItemClasses: K, active: G, target: ae }, de) => {
              var he, Be, oe;
              return g(), V("li", {
                key: de,
                class: j(["nav-item", (he = L == null ? void 0 : L.props) == null ? void 0 : he["title-item-class"]]),
                role: "presentation"
              }, [
                X("button", Z({
                  id: N,
                  class: ["nav-link", K],
                  "data-bs-toggle": "tab",
                  "data-bs-target": ae,
                  role: "tab",
                  "aria-controls": ee,
                  "aria-selected": G
                }, (Be = L == null ? void 0 : L.props) == null ? void 0 : Be["title-link-attributes"], {
                  onClick: ct((ve) => F(ve, de), ["stop", "prevent"])
                }), [
                  L.children && L.children.title ? (g(), D(le(L.children.title), { key: 0 })) : (g(), V(fe, { key: 1 }, [
                    ie(Y((oe = L == null ? void 0 : L.props) == null ? void 0 : oe.title), 1)
                  ], 64))
                ], 16, pf)
              ], 2);
            }), 128)),
            x(_.$slots, "tabs-end")
          ], 2)
        ], 2),
        i(r) ? J("", !0) : (g(), V("div", {
          key: 1,
          class: j(["tab-content", e.contentClass])
        }, [
          (g(!0), V(fe, null, we(i(w), ({ tabComponent: L, contentId: N, tabClasses: ee, active: K }, G) => (g(), D(le(L()), {
            id: N,
            key: G,
            class: j(ee),
            active: K
          }, null, 8, ["id", "class", "active"]))), 128)),
          i(A) ? (g(), V("div", {
            key: "bv-empty-tab",
            class: j(["tab-pane active", { "card-body": i(n) }])
          }, [
            x(_.$slots, "empty")
          ], 2)) : J("", !0)
        ], 2))
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), bf = /* @__PURE__ */ H({
  __name: "BTooltip",
  setup(e) {
    return (t, a) => (g(), D(Ja, { tooltip: "" }, oo({ _: 2 }, [
      we(t.$slots, (l, o) => ({
        name: o,
        fn: q((n) => [
          x(t.$slots, o, ke(Pe(n)))
        ])
      }))
    ]), 1024));
  }
}), hf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BAccordion: Zi,
  BAccordionItem: or,
  BAlert: fr,
  BAvatar: gr,
  BAvatarGroup: br,
  BBadge: Br,
  BBreadcrumb: Cr,
  BBreadcrumbItem: rn,
  BButton: wt,
  BButtonGroup: Tr,
  BButtonToolbar: xr,
  BCard: pn,
  BCardBody: vn,
  BCardFooter: mn,
  BCardGroup: Vr,
  BCardHeader: dn,
  BCardImg: sa,
  BCardSubtitle: fn,
  BCardText: Pr,
  BCardTitle: cn,
  BCarousel: Hr,
  BCarouselSlide: Gr,
  BCloseButton: _t,
  BCol: xt,
  BCollapse: sn,
  BContainer: Qr,
  BDropdown: yn,
  BDropdownDivider: ou,
  BDropdownForm: uu,
  BDropdownGroup: vu,
  BDropdownHeader: bu,
  BDropdownItem: yu,
  BDropdownItemButton: wu,
  BDropdownText: Cu,
  BForm: Bn,
  BFormCheckbox: $n,
  BFormCheckboxGroup: Lu,
  BFormFloatingLabel: Au,
  BFormGroup: qu,
  BFormInput: Xu,
  BFormInvalidFeedback: Pa,
  BFormRadio: kn,
  BFormRadioGroup: td,
  BFormRow: Kt,
  BFormSelect: nd,
  BFormSelectOption: Za,
  BFormSelectOptionGroup: Sn,
  BFormSpinButton: Lc,
  BFormTag: Cn,
  BFormTags: Bd,
  BFormText: Oa,
  BFormTextarea: Sd,
  BFormValidFeedback: Ea,
  BImg: Ya,
  BInputGroup: Pd,
  BInputGroupAddon: Qa,
  BInputGroupAppend: Od,
  BInputGroupPrepend: Ed,
  BInputGroupText: Tn,
  BLink: Ne,
  BListGroup: Id,
  BListGroupItem: Fd,
  BModal: Hd,
  BNav: Md,
  BNavForm: Dd,
  BNavItem: Wd,
  BNavItemDropdown: Xd,
  BNavText: Jd,
  BNavbar: Yd,
  BNavbarBrand: ec,
  BNavbarNav: tc,
  BNavbarToggle: ic,
  BOffcanvas: vc,
  BOverlay: xn,
  BPagination: wc,
  BPlaceholder: He,
  BPlaceholderButton: Pn,
  BPlaceholderCard: Sc,
  BPlaceholderTable: Cc,
  BPlaceholderWrapper: Tc,
  BPopover: Ja,
  BProgress: xc,
  BProgressBar: On,
  BRow: Pc,
  BSpinner: pa,
  BTab: mf,
  BTable: af,
  BTableSimple: tl,
  BTabs: gf,
  BTbody: lf,
  BTd: sf,
  BTfoot: rf,
  BTh: cf,
  BThead: ff,
  BToast: hn,
  BToastContainer: Va,
  BToastPlugin: Yr,
  BToaster: Va,
  BTooltip: bf,
  BTr: vf,
  BTransition: Tt
}, Symbol.toStringTag, { value: "Module" })), yf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  vBColorMode: ac,
  vBModal: Ia,
  vBPopover: oc,
  vBToggle: Ia,
  vBTooltip: nc
}, Symbol.toStringTag, { value: "Module" })), wf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createBreadcrumb: Ko,
  useBreadcrumb: Jo,
  useColorMode: Mi
}, Symbol.toStringTag, { value: "Module" })), kf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BvCarouselEvent: so,
  BvEvent: Ze,
  BvTriggerableEvent: zt
}, Symbol.toStringTag, { value: "Module" })), Sf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), Cf = {
  // TODO: use options in the future
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  install(e, t = {}) {
    Object.entries(hf).forEach(([a, l]) => {
      e.component(a, l);
    }), Object.entries(yf).forEach(([a, l]) => {
      a.toLowerCase().startsWith("v") ? e.directive(a.slice(1), l) : e.directive(a, l);
    }), Ko(e);
  }
};
export {
  Zi as BAccordion,
  or as BAccordionItem,
  fr as BAlert,
  gr as BAvatar,
  br as BAvatarGroup,
  Br as BBadge,
  Cr as BBreadcrumb,
  rn as BBreadcrumbItem,
  wt as BButton,
  Tr as BButtonGroup,
  xr as BButtonToolbar,
  pn as BCard,
  vn as BCardBody,
  mn as BCardFooter,
  Vr as BCardGroup,
  dn as BCardHeader,
  sa as BCardImg,
  fn as BCardSubtitle,
  Pr as BCardText,
  cn as BCardTitle,
  Hr as BCarousel,
  Gr as BCarouselSlide,
  _t as BCloseButton,
  xt as BCol,
  sn as BCollapse,
  Qr as BContainer,
  yn as BDropdown,
  ou as BDropdownDivider,
  uu as BDropdownForm,
  vu as BDropdownGroup,
  bu as BDropdownHeader,
  yu as BDropdownItem,
  wu as BDropdownItemButton,
  Cu as BDropdownText,
  Bn as BForm,
  $n as BFormCheckbox,
  Lu as BFormCheckboxGroup,
  Au as BFormFloatingLabel,
  qu as BFormGroup,
  Xu as BFormInput,
  Pa as BFormInvalidFeedback,
  kn as BFormRadio,
  td as BFormRadioGroup,
  Kt as BFormRow,
  nd as BFormSelect,
  Za as BFormSelectOption,
  Sn as BFormSelectOptionGroup,
  Lc as BFormSpinButton,
  Cn as BFormTag,
  Bd as BFormTags,
  Oa as BFormText,
  Sd as BFormTextarea,
  Ea as BFormValidFeedback,
  Ya as BImg,
  Pd as BInputGroup,
  Qa as BInputGroupAddon,
  Od as BInputGroupAppend,
  Ed as BInputGroupPrepend,
  Tn as BInputGroupText,
  Ne as BLink,
  Id as BListGroup,
  Fd as BListGroupItem,
  Hd as BModal,
  Md as BNav,
  Dd as BNavForm,
  Wd as BNavItem,
  Xd as BNavItemDropdown,
  Jd as BNavText,
  Yd as BNavbar,
  ec as BNavbarBrand,
  tc as BNavbarNav,
  ic as BNavbarToggle,
  vc as BOffcanvas,
  xn as BOverlay,
  wc as BPagination,
  He as BPlaceholder,
  Pn as BPlaceholderButton,
  Sc as BPlaceholderCard,
  Cc as BPlaceholderTable,
  Tc as BPlaceholderWrapper,
  Ja as BPopover,
  xc as BProgress,
  On as BProgressBar,
  Pc as BRow,
  pa as BSpinner,
  mf as BTab,
  af as BTable,
  tl as BTableSimple,
  gf as BTabs,
  lf as BTbody,
  sf as BTd,
  rf as BTfoot,
  cf as BTh,
  ff as BThead,
  hn as BToast,
  Va as BToastContainer,
  Yr as BToastPlugin,
  Va as BToaster,
  bf as BTooltip,
  vf as BTr,
  Tt as BTransition,
  Cf as BootstrapVueNext,
  so as BvCarouselEvent,
  Ze as BvEvent,
  zt as BvTriggerableEvent,
  hf as Components,
  wf as Composables,
  yf as Directives,
  Sf as Types,
  kf as Utils,
  Ko as createBreadcrumb,
  Cf as default,
  Jo as useBreadcrumb,
  Mi as useColorMode,
  bn as useToast,
  ac as vBColorMode,
  Ia as vBModal,
  oc as vBPopover,
  Ia as vBToggle,
  nc as vBTooltip
};
//# sourceMappingURL=bootstrap-vue-next.mjs.map
